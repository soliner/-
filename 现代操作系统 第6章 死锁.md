# 第6章 死锁

- 在计算机系统中有很多独占性的资源，在任一时刻它们都只能被一个进程使用
  - 打印机、磁带以及系统内部表中的表项
  - 操作系统都具有授权一个进程（临时）排他地访问某一种资源的能力
- 访问若干种资源而不是一种
- 死锁，deadlock
  - 发生在机器之间
  - 别的情况也有可能引起死锁
  - 几类死锁
    - 了解它们是如何出现的



## 6.1 资源

- resource，资源
  - 硬件设备（如磁带机）或是一组信息
- 资源就是随着时间的推移，必须能获得、使用以及释放的任何东西

### 6.1.1 可抢占资源和不可抢占资源

- 资源分为两类：
  - 可抢占资源，preemptable resource
    - 进程B开始运行并请求打印机，但是没有成功。这时有潜在的死锁危险。由于进程A拥有打印机，而进程B占有内存，两个进程都缺少另外一个进程拥有的资源，所以任何一个都不能继续执行
    - 通过把进程B换出内存、把进程A换入内存就可以实现抢占进程B的内存
  - nonpreemptable resource，不可抢占资源
    - 指在不引起先关的计算失败的情况下，无法把它从占有它的进程处抢占过来
    - 我们的重点
- 使用一个资源所需要的事件顺序（抽象的形式）
  - 请求资源
    - 请求时资源不可用
      - 被迫等待
    - 请求资源失败时
      - 小循环中：
        - 请求资源，休眠，再请求
    - 在后面的讨论中，我们假设
      - 如果某个进程请求资源失败，那么它就进入休眠状态
    - 请求资源的过程是非常依赖于系统的
      - request系统调用，用于允许进程资源请求
      - 资源是一些特殊文件
        - 用open调用打开
  - 使用资源
  - 释放资源

### 6.1.2 资源获取

- 资源应该由用户进程来管理其使用

  - 为每一个资源配置一个信号量

    - 信号量的down操作来获取资源，使用资源，最后使用up操作来释放资源
    - 一个资源

    ```c
    typedef int semappheore;
    semaphore resource_1;

    void process_A(void){
      down(&resource_1);
      use_resource_1();
      up(&resource_1);
    }
    ```

    - 两个资源

    ```c
    typedef int semaphore；
    semaphore resource_1;
    semaphore resource_2;

    void process_A(void){
      down(&resource_1);
      down(&resource_2);
      use_both_resources();
      up(&resource_2);
      up(&resource_1);
    }
    ```

    ​

    - 如果需要两个以上的资源，通常都是连续获取

    - 在只有一个进程参与时，所有的工作都可以很好地完成

    - 考虑两个进程（A和B）以及两个资源的情况

      - 一个进程先于另一个进程获取资源，无死锁

      ```c
      typedef int semaphore;
      	semaphore resource_1;
      	semaphore resource_2;
      	
      void process_A(void){
        down(&resource_1);
        down(&resource_2);
        use_both_resource();
        up(&resource_2);
        up(&resource_1);
      }

      void process_B(void){
        down(&resource_1);
        down(&resource_2);
        use_both_resource();
        up(&resource_2);
        up(&resource_1);
      }
      ```

      - 死锁的情况

      ```c
      semaphore resource_1;
      semaphore resource_2;

      void process_A(void){
        down(&resource_1);
        down(&resource_2);
        use_both_resources();
        up(&resource_2);
        up(&resource_1);
      }

      void process_B(void){
        down(&resource_2);
        down(&resource_1);
        use_both_resources();
        up(&resource_1);
        up(&resource_2);
      }
      ```

## 6.2 死锁概述

- 死锁的规范定义如下：
  - 如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么，该进程集合就是死锁的
    - 在这个模型中，假设进程只含有一个线程，并且被阻塞的进程无法有中断唤醒
- 每个进程所等待的事件是释放该进程集合中其他进程所占有的资源
  - resource deadlock，资源死锁
    - 进程的数量以及占有或者请求的资源数量和种类都是无关紧要的，而且无论资源是何种类型（软件或者硬件）都会发生这种结果
    - 最常见的类型

### 6.2.1 资源死锁的条件

- 发生（资源）死锁的四个必要条件
  - 互斥条件
  - 占有和等待条件
  - 不可抢占条件
  - 环路等待条件
- 死锁发生时，以上四个条件一定是同时满足的

### 6.2.2 死锁建模

- 用有向图建立上述四个条件的模型
  - 在有向图中有两类节点：
    - 用圆形表示的进程
    - 用方形表示的资源
  - 从资源节点到进程节点的有向边代表该资源已被请求、授权并被进程占用
  - 由进程节点到资源节点的有向边表明当前进程正在请求该资源，并且该进程已被阻塞，处于等待该资源的状态。
- 上述的执行次序不会引起死锁（因为没有资源的竞争），但程序也没有任何并行性。
- 如果假设进程操作包含 I/ O 和计算，那么轮转法是一种合适的调度算法。
- 对于一个有可能引起死锁的资源请求，操作系统可以干脆不批准请求，并把该进程挂起（即不参与调度）一直到处于安全状态为止。
- 资源分配图可以用作一种分析工具，考察对一给定的请求/释放的序列是否会引起死锁。
  - 只需要按照请求和释放的次序一步步进行，每一步之后都检查图中是否包括了环路。
    - 如果有环路，那么就有死锁；反之，则没有死锁。在
- 四种处理死锁的策略：

  - 1) 忽略该问题
  - 2) 检测死锁并恢复
  - 3) 仔细对资源进行分配，动态地避免死
  - 4) 通过破坏引起死锁的四个必要条件之一，防止死锁的产生。

## 6.3 鸵鸟算法

- 最简单的解决方法是鸵鸟算法：把头埋到沙子里，假装根本没有问题发生
  - 当一个open 系统调用因物理设备（例如CD-ROM 驱动程序或者打印机）忙而不能得到响应的时候，操作系统会阻塞调用该系统调用的进程。

## 6.4 死锁检测和死锁恢复

- 第二种技术是死锁检测和恢复。

### 6.4.1 每种类型一个资源的死锁检测

- 每种类型只有一个资源
  - 对这样的系统构造一张资源分配图，
    - 如果这张图包含了一个或一个以上的环，那么死锁就存在。在此环中的任何一个进程都是死锁进程。
- 假设一个系统包括 A 到 G 共 7 个进程， R 到 W 共 6 种资源。
  - 1) A 进程持有R 资源，且需要S 资源
  - 2) B 进程不持有任何资源，但需要T 资源。
  - 3) C 进程不持有任何资源，但需要S 资源。
  - 4) D 进程持有U 资源，且需要S 资源和T 资源。
  - 5) E 进程持有T 资源，且需要V 资源。
  - 6) F 进程持有W 资源，且需要S 资源。
  - 7) G 进程持有V 资源，且需要U 资源。
- 可以构造一张资源分配图，
  - 进程 D、E、 G 已经死锁，进程 A、 C、 F 没有死锁
  - 这一算法使用了数据结构L，L 代表一些节点的集合。
  - 通过执行下列步骤完成上述算法：
    - 1) 对图中的每一个节点N，将N 作为起始点执行下面5 个步骤。
    - 2) 将L 初始化为空表，并清除所有的有向边标记。
    - 3) 将当前节点添加到L 的尾部，并检测该节点是否在L 中已出现过两次。如果是，那么该图包含了一个环（已列在L 中），算法结束。
    - 4) 从给定的节点开始，检测是否存在没有标记的从该节点出发的弧（有向边）。如果存在的话，做第5 步；如果不存在，跳到第6 步。
    - 5) 随机选取一条没有标记的从该节点出发的弧（有向边），标记它。然后顺着这条弧线找到新的当前节点，返回到第3 步。
    - 6) 如果这一节点是起始节点，那么表明该图不存在任何环，算法结束。否则意味着我们走进了死胡同，所以需要移走该节点，返回到前一个节点，即当前节点前面的一个节点，并将它作为新的当前节点，同时转到第3 步。
- 这一算法是依次将每一个节点作为一棵树的根节点，并进行深度优先搜索。
- 这种算法远不是最佳算法，较好的一种算法参见

### 6.4.2 每种类型多个资源的死锁检测

- 一种基于矩阵的算法来检测从P1到Pn这n个进程中的死锁。
  - E 是现有资源向量（ existing resource vector）
    - 代表每种已存在的资源总数。
  - 假设A 是可用资源向量（available resource vector），那么Ai 表示当前可供使用的资源数（即没有被分配的资源）。
  - 两个数组：
    - C代表当前分配矩阵（ current allocation matrix），
    - R代表请求矩阵（request matrix）。
    - 所以，Cij代表进程 i 所持有的资源 j 的数量。同理，Rij代表Pi所需要的资源j的数量。
- 这四种数据结构之间有一个重要的恒等式。
  - 如果我们将所有已分配的资源 j 的数量加起来再和所有可供使用的资源数相加，结果就是该类资源的资源总数。死锁检测算法就是基于向量的比较
- 该算法假定了一个最坏情形：所有的
- 死锁检测算法如下：
  - 1) 寻找一个没有标记的进程Pi，对于它而言 R 矩阵的第 i 行向量小于或等于 A。
  - 2) 如果找到了这样一个进程，那么将 C矩阵的第 i 行向量加到 A 中，标记该进程，并转到第 1 步。 
  - 3) 如果没有这样的进程，那么算法终止。
- 该进程的特点是它有资源请求并且该请求可被当前的可用资源满足。
- 要运行死锁检测算法，首先找出哪一个进程的资源请求可被满足。
- 何时去检测它们。
  - 一种方法是每当有资源请求时去检测。
    - 会占用昂贵的 CPU 时间。
  - 另一种方法是每隔 k 分钟检测一次，或者当 CPU 的使用率降到某一域值时去检测

### 6.4.3 从死锁中恢复

- 各种从死锁中恢复的方法，

#### 1. 利用抢占恢复

- 将某个资源从它的当前所有者那里转移到另一个进程。
  - 尤其是对运行在大型主机上的批处理操作系统来说，需要人工进行干预。
  - 用这种方法恢复通常比较困难或者说不太可能。

标注 (黄色) - 6.4 死锁检测和死锁恢复 >  位置 8405

#### 2. 用回滚恢复

- 检查点（checkpointed）
  - 进程检查点检查就是将进程的状态写入一个文件以备以后重启。
  - 不仅包括存储映像，还包括了资源状态，
  - 新的检查点不应覆盖原有的文件，而应写到新文件中。


- 一旦检测到死锁
  - 将该进程复位到一个更早的状态，那时它还没有取得所需的资源，接着就把这个资源分配给一个死锁进程

#### 3. 通过杀死进程恢复 

- 最直接也是最简单的解决死锁的方法是杀死一个或若干个进程。
  - 一种方法是杀掉环中的一个进程。
  - 另一种方法是选一个环外的进程作为牺牲品以释放该进程的资源。
- 最好杀死从头开始重新运行而且不会带来副作用的进程
- 另一方面，更新数据库的进程在第二次运行时并非总是安全的。

## 6.5 死锁避免

- 在讨论死锁检测时，我们假设当一个进程请求资源时，它一次就请求所有的资源
- 本节我们会讨论几种死锁避免的方法。 

### 6.5.1 资源轨迹图

- 避免死锁的主要算法是基于一个安全状态的概念
- 处理两个进程和两种资源（打印机和绘图仪）的模型。横轴表示进程 A 执行的指令，纵轴表示进程 B 执行的指令。

![1](C:\Users\Administrator\Documents\我的导图\1.png)

- 图 6-8 中的每一点都表示出两个进程的连接状态。初始点为 p，没有进程执行任何指令。
  - 运动方向一定是向上或向右，不会向左或向下，因为进程的执行不可能后退。
  - 阴影部分是我们感兴趣的
    - 而互斥使用的规则决定了不可能进入该区域
  - 在点 t 进程 B 请求资源。系统必须决定是否分配

### 6.5.2 安全状态和不安全状态

- 如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。
- 总共有10个资源实例，其中有 7 个资源已经分配，还有 3 个资源是空闲的。


- 图 6-9a 的状态是安全的，这是由于存在一个分配序列使得所有的进程都能完成。

![6-9](C:\Users\Administrator\Documents\我的导图\6-9.jpg)

-  A 请求并得到另一个资源
  - 最终，进程 B 完成，状态如图 6-10d 所示，此时进入困境
  - 只有 4 个资源实例空闲，并且所有活动进程都需要 5 个资源实例。
  - 从图 6-10a 到图 6-10b的分配方案，从安全状态进入到了不安全状态。

![6-10](C:\Users\Administrator\Documents\我的导图\6-10.jpg)

- 安全状态和不安全状态的区别是：从安全状态出发，系统能够保证所有进程都能完成；而从不安全状态出发，就没有这样的保证。

### 6.5.3 单个资源的银行家算法

- 银行家算法（banker's algorithm）
  - 能够避免死锁的调度算法
  - 死锁检测算法的扩展。
  - 该模型基于一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度
  - 算法要做的是判断对请求的满足是否会导致进入不安全状态。
- 在图6-11a中我们看到 4 个客户 A、 B、 C、 D，每个客户都被授予一定数量的贷款单位
  - 这里将客户比作进程，贷款单位比作资源，银行家比作操作系统。

![6-11](C:\Users\Administrator\Documents\我的导图\6-11.jpg)

- 在某一时刻，具体情况如图 6-11b 所示。
  - 这个状态是安全的
    - 由于保留着 2 个单位，银行家能够拖延除了 C 以外的其他请求。因而可以让 C 先完成，然后释放 C 所占的 4 个单位资源。
- 考虑假如向B 提供了另一个他所请求的贷款单位，如图6-11b 所示
  - 那么我们就有如图6-11c 所示的状态，该状态是不安全的。
- 银行家算法就是对每一个请求进行检查，检查如果满足这一请求是否会达到安全状态

### 6.5.4 多个资源的银行家算法

- 可以把银行家算法进行推广以处理多个资源

![6-12](C:\Users\Administrator\Documents\我的导图\6-12.jpg)

- 左边的矩阵显示出为 5 个进程分别已分配的各种资源数，右边的矩阵显示了使各进程完成运行所需的各种资源数。
  - 在系统的每一步中都可以计算出右边的矩阵。
- 图 6-12 最右边的三个向量分别表示现有资源 E、已分配资源 P 和可用资源 A。
  - 该向量可通过将左边矩阵的各列相加获得，可用资源向量可通过从现有资源中减去已分配资源获得。
- 检查一个状态是否安全的算法如下：
  - 1) 查找右边矩阵中是否有一行，其没有被满足的资源数均小于或等于A。如果不存在这样的行，那么系统将会死锁，因为任何进程都无法运行结束（假定进程会一直占有资源直到它们终止为止）。
  - 2) 假若找到这样一行，那么可以假设它获得所需的资源并运行结束，将该进程标记为终止，并将其资源加到向量A 上。
  - 3) 重复以上两步，或者直到所有的进程都标记为终止，其初始状态是安全的；或者所有进程的资源需求都得不到满足，此时就是发生了死锁。
- 图 6-12 中所示的状态是安全的
- E 的请求不能立即满足，必须延迟一段时间。
  - 每本操作系统的专著都详细地描述它，很多论文的内容也围绕该算法讨论了它的不同方面。
  - 该算法虽然很有意义但缺乏实用价值
    - 因为很少有进程能够在运行前就知道其所需资源的最大值
    - 进程数也不是固定的，往往在不断地变化
    - 原本可用的资源也可能突然间变成不可用
- 只有极少的系统使用银行家算法来避免死锁。

## 6.6 死锁预防 

- 死锁避免从本质上来说是不可能的，因为它需要获知未来的请求，而这些请求是不可知的
- 如果能够保证四个条件中至少有一个不成立，那么死锁将不会产生

### 6.6.1 破坏互斥条件

- 通过采用假脱机打印机（spooling printer）技术可以允许若干个进程同时产生输出。该模型中惟一真正请求使用物理打印机的进程是打印机守护进程
- 假设守护进程被设计为在所有输出进入假脱机之前就开始打印
- 打印机就可能空置。为了避免这种现象，一般将守护进程设计成在完整的输出文件就绪后才开始打印。
- 不过，有一个小思路是经常可适用的
  - 避免分配那些不是绝对必需的资源，尽量做到尽可能少的进程可以真正请求资源。  

### 6.6.2 破坏占有和等待条件

- 一种实现方法是规定所有进程在开始执行前请求所需的全部资源
  - 一个直接问题是很多进程直到运行时才知道它需要多少资源
  - 另一个问题是这种方法的资源利用率不是最优的
- 一些大型机批处理系统要求用户在所提交的作业的第一行列出它们需要多少资源
  - 加重了编程人员的负担，也造成了资源的浪费，但这的确防止了死锁。
- 另一种破坏占有和等待条件的略有不同的方案是，要求当一个进程请求资源时，先暂时释放其当前占用的所有资源，然后再尝试一次获得所需的全部资源。

### 6.6.3 破坏不可抢占条件

- 虚拟化的方式
  - 假脱机打印机向磁盘输出，并且只允许打印机守护进程访问真正的物理打印机，
  - 并不是所有的资源都可以进行类似的虚拟化

### 6.6.4 破坏环路等待条件

- 一种是保证每一个进程在任何时刻只能占用一个资源，
- 另一种避免出现环路等待的方法是将所有资源统一编号
  - 规则是：进程可以在任何时刻提出资源请求，但是所有请求必须按照资源编号的顺序（升序）提出
- 若按此规则，资源分配图中肯定不会出现环。
- 对于多于两个进程的情况，同样的逻辑依然成立。在任何时候，总有一个已分配的资源是编号最高的。
- 该算法的一个变种是摈弃必须按升序请求资源的限制，而仅仅要求不允许进程请求比当前所占有资源编号低的资源。
- 尽管对资源编号的方法消除了死锁的问题，但几乎找不出一种使每个人都满意的编号次序。
- 死锁预防的各种方法如图 6-14 所示。

## 6.7 其他问题

- 讨论一些和死锁相关的问题，包括两阶段加锁、通信死锁、活锁和饥饿。 

### 6.7.1 两阶段加锁

- 一些特殊的应用方面，有很多卓越的专用算法。
  - 在很多数据库系统中，一个经常发生的操作是请求锁住一些记录，然后更新所有锁住的记录。
- 常用的方法是两阶段加锁（two-phase locking）。在第一阶段，进程试图对所有所需的记录进行加锁，一次锁一个记录。
- 如果在第一阶段某个进程需要的记录已经被加锁，那么该进程释放它所有加锁的记录，然后重新开始第一阶段。
- 在一般意义下，这种策略并不通用
- 在实时系统和进程控制系统中，由于一个进程缺少一个可用资源就半途中断它，并重新开始该进程，这是不可接受的。

### 6.7.2 通信死锁

- 资源死锁。一个进程需要使用另外一个进程拥有的资源，因此必须
  - 资源死锁是最普遍的一种类型，但不是惟一的一种。

  - 一个进程都成功调用一个资源（互斥锁之一）而且死锁的进程尝试去调用另外的资源（另一个互斥锁）


- 死锁发生在通信系统中（比如说网络），即两个或两个以上进程利用发送信息来通信时。

  - 在一系列进程中，每个进程因为等待另外一个进程引发的事件

  - 在一系列进程中，每个进程因为等待另外一个进程引发的事件而产生阻塞


- 通信死锁（communication deadlock）。

  - 用来中断通信死锁：超时。

  - 多数网络通信系统中，只要一个信息被发送至一个特定的地方，并等待其返回一个预期的回复，发送者就同时启动计时器。若计时器在回复到达前计时就停止了，则信息的发送者可以认定信息已经丢失，并重新发送（如果需要，则一直重复）。


- 如果原始信息没有丢失，而仅仅是回复延时，接收者可能收到两次或者更多次信息，甚至导致意想不到的结果。


- 不应该仅仅因为网速缓慢或者超时设定太短，就重复（并执行）多次。应该将通信规则——通常称为协议（protocol）——设计为让所有事情都正确


- 并非所有在通信系统或者网络发生的死锁都是通信死锁。资源死锁也会发生


- 因特网由两类计算机组成：主机和路由器。
  - 主机（host）是一台用户计算
  - 路由器（router）是专用的通信计算机，将数据包从源发送至目的地。每台主机都连接一个或更多的路由器


- 当一个数据包从一个主机进入路由器时，它被放入一个缓冲器中，然后传输到另外一个路由器，再到另一个，直至目的地。这些

### 6.7.3　活锁

- 轮询（忙等待）可用于进入临界区


- 假设守护进程被设计为在所有输出进入假脱机之前就开始打印，打印机就可能空置。

## 习题

1. 给出一个由策略产生的死锁的例子

- 在美国，考虑总统选举，三个或更多的候选人正在争取某个政党的提名。初选结束后，当代表们到达党的选举大会时，可能没有候选人获得多数票，也没有任何代表愿意改变自己的投票。这是一个死锁。每个候选人都有一些资源（选票），但需要更多的选票才能胜出。在议会中有多个政党的国家，每个政党都支持不同版本的年度预算，但无法通过召集多数党来通过预算。这也是一个死锁。

2. 学生们在机房的个人计算机上将自己要打印的文件发送给服务器，服务器会将这些文件暂存在它的硬盘上。如果服务器磁盘空间有限，那么什么情况下会产生死锁？这样的死锁应该怎样避免？

- 磁盘缓冲区是有限的资源。每个新到达的任务都需要请求更多的资源。如果具备10M的缓冲空间，如何10个2MB的任务的一半到来，磁盘缓冲区将会填满，没有更多的空间可以存储，就会发生一个死锁。死锁可以通过让一个任务在缓冲区填满之前就开始打印，并且在打印完成后释放空间。这样一来，任务实际上会打印完成，然后下一个可以做同样的事情。如果在缓冲区被填满前，任务还不能开始打印，死锁是可能的。

3. 在图6-1中，资源释放的顺序与获得的顺序相反，以其他的顺序释放资源能否得到同样的结果？

![20170528232132182](F:\文档\我的导图\20170528232132182.png)

- 对。它没有任何区别。

4. 一个资源死锁的发生有四个必要条件（互斥使用资源、占用和等待资源、不可抢占资源和环路等待资源）。举一个例子说明这些条件对于一个资源死锁的发生不是充分的。何时这些对一个资源死锁的发生时充分条件？
5. 图6-3给出了资源费配图的概念，试问

![img](https://img-blog.csdn.net/20170528232157539?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3p0cXdhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

- 是的，不合理的资源分配图存在。我们指出资源只能由一个进程获取。从方框代表的资源到圆代表的进程的弧表示进程拥有该资源。因此，一个方框如果指向两个或两个以上的圆意味着所有这些进程都持有该资源，这违反了规则。因此，在一个图中多个弧从一个方框指向不同的圆违反了规则，除非有多个资源的副本。从方框到方框或从圆到圆的弧线也违反规则。

6. 假设一个系统中存在一个资源死锁。举一个例子说明死锁的进程资源集合中可能包括了不在相应的资源分配图中循环链中的进程。

- 考虑三个过程A，B和C和两个资源R和S。假设A等待B持有的S，B等待A持有的R，和C是等待A持有的R。所有这三个进程，A，B和C发生死锁。然而，只有A和B属于循环链。 

7. 鸵鸟算法中提到了填充进程表表项或者其他系统表的可能。能否给出一种能够使系统管理员从这种状况下恢复系统的方法？

- 这些资源的一部分只能由管理员拥有的进程保留使用，所以管理员总是可以运行一个shell和程序来评估死锁并决定哪些进程要被杀死以便系统再次可用。

8. 解释系统是如何从前面问题的死锁中恢复的，使用a)抢占；b)回滚；c)终止进程

- 通过抢占恢复的过程：P2和P3完成后，进程P1可以强制抢占1个RS3 资源。这将使A =（0 2 1 3 2），并让进程P4完成。一旦P4完成并释放其资源P1可能完成。通过回滚恢复的过程：P1回滚到请求RS3之前的状态。通过杀死进程恢复的过程：杀死P1。 

9. 假设在图 6-6 中，对某个 i，有$C_{ij}+R_{ij}=E_j$ ，这意味着什么？

![6-6](F:\文档\我的导图\6-6.jpg)

- 这个过程需要比系统更多的资源。它没有可能可以得到这些资源，所以它永远无法完成，即使没有其他进程需要任何资源。

10. 请说明表 6-8 中的模型与 6.5.2 节描述的安全状态和不不安全状态有什么主要的差异。差异带来的后果是什么？

![6-8](C:\Users\Administrator\Documents\我的导图\6-8.jpg)

- 图6-8所示的模型需要知道进程何时释放其资源。另一方面，决定一个状态是否安全或不安全并不需要这方面的知识。这样做的后果是，图6-8的模型可以用来识别如果一个状态进入由I1，I2，I5和I6边围成的框中，保证系统最终会死锁，不安全状态意味着不能保证不会发生死锁。

11. 图 6-8 所示的资源轨迹模式是否可用来说明三个进程和三个资源的死锁问题？如果可以，它是怎样说明的？如果不可以，请解释为什么。

- 可以。在三个维度中考虑。z轴代测量第三进程请求的资源数。 

12.  理论上，资源轨迹图可以用于避免死锁。通过合理的调度，操作系统可避免进入不安全区域。请列举一个在实际运用这种方法时会带来的问题。

- 该方法仅能在提前知道资源被请求的确切时刻时才能用于指导调度，但在实践中，这种情况很少。

13. 一个系统是否可能处于既非死锁也不安全的状态？如果可以，举出例子；如果不可以，请证明所有状态只能处于死锁或安全两种状态之一。

- 有些状态家既不安全也不是死锁，但是会导致死锁。例如，假设有四个资源：磁带，绘图仪，扫描仪和CD-ROM，如下表所示，有三个进程存在竞争。可能存在以下情况： 
- 拥有      需要      可用A： 2 0 0 0   1 0 2 0   01 2 1B： 1 0 0 0   0 1 3 1C： 0 1 2 1   1 0 1 0       
- 这种状态不会发生死锁，因为许多操作还可以发生，例如A仍然可以得到两台打印机。但是，如果每个进程请求其剩余的要求，就会产生死锁。

14. 考虑一个使用银行家算法避免死锁的系统。某个时刻一个进程 P 请求资源 R，但即使R当前可用这个请求也被拒绝了。如果系统分配R给P，是否意味着系统将会死锁？

- 否。如果系统通过该请求有可能发生死锁，使用银行家算法的系统就会拒绝该进程获得请求的可用资源，如果同意该进程的请求，系统当然也可能不会发生死锁。

15. 银行家算法的一个主要限制就是需要所有进程的最大资源需求的信息。有没有可能设计一个不需要这些信息而避免死锁的算法？解释你的方法。

- 如果所有进程的最大资源需求的信息不知道，只能强制顺序执行进程，这不可能避免死锁。考虑要在CD-ROM上记录扫描文档的两个进程的示例。当进程B请求CD-ROM刻录机时，无法确定授予该请求是否会进入不安全状态，由于不知道A是否需要CD-ROM刻录机，而B稍后需要扫描仪。 

16. 仔细考察图 6-11b，如果 D再多请求1个单位，会导致安全状态还是不安全状态？如果换成C提出同样请求，情形会怎样？

![6-11](C:\Users\Administrator\Documents\我的导图\6-11.jpg)

- D请求1个单位是不安全的，但换成C请求则是安全的。

17. 某一系统有两个进程和三个相同的资源。每个进程最多需要两个资源。这种情况有没有可能发生死锁？为什么？

- 该系统不可能发生死锁。假设每个进程都拥有一个资源。有一个资源是空闲的。任何一个进程可以要求它，并获得它，在这种情况下，它可以完成和释放这两种资源。因此，死锁是不会发生的。

18. 再考虑上一个问题，但现在有 p 个进程，每个进程最多需要m个资源，并且由r个资源可用。什么样的条件可以保证死锁不会发生？

- 如果进程有m个资源，它可以完成并且不会发生死锁。因此，最糟糕的情况是每个进程都有m-1个资源，需要另外一个资源。如果剩下一个资源，一个进程可以完成和释放所有资源，让其余的进程完成。因此，避免死锁的条件为r≥p(m-1)+ 1。

19. 假设图 6-12 中的进程 A 请求最后一台磁带机，这一操作会引起死锁吗？

![6-12](C:\Users\Administrator\Documents\我的导图\6-12.jpg)

- 不会，进程D还能完成，当它完成时，它返回足够的资源以允许进程E（或进程A）完成，等等。

20. 一个计算机有 6 台磁带机，由n个进程竞争使用，每个进程可能需要两台磁带机，那么n是多少时系统才没有死锁的危险？

- 对于三个进程，每个进程可以有两个磁带机。对于四个进程，磁带机的分配将是（2,2,1,1），允许前两个进程完成。对于五个进程，分配将是（2,1,1,1,1），这仍然允许第一个进程完成。对于六个进程，每个持有一个磁带机，但需要另一个磁带机，发生了死锁。因此，对于n <6，系统无死锁。

21. 银行家算法在一个有 m 个资源类型和 n 个进程的系统中运行。当 m 和 n 都很大时，为检查状态是否安全而进行的操作次数正比于$m^an^b$ 。a和b的值是多少？

- 将矩阵中的一行与可用资源的向量进行比较，可以进行m次操作，此步骤必须按顺序重复n次，以找到可以完成的进程并对其进行标记。因此，按照顺序标记一个进程需要进行mn步。对所有n个进程重复该算法意味着操作数为mn2。因此a = 1和b = 2

22. 一个系统有 4 个进程和 5 个可分配资源，当前分配和最大需求如下：

- 需求矩阵如下：0 1 0 0 20 2 1 0 01 0 3 0 00 0 1 1 1       如果x为0，会立即死锁。如果x为1，则进程D可以运行完成。完成后，可用的资源为1 1 2 2 1，不幸的是，现在已经死锁了。如果x为2，进程D运行后，可用资源为1 1 3 2 1，进程C可以运行完成，并返回其资源，可用的资源为2 2 3 3 1，这将允许进程B运行和完成，然后进程A运行并完成。因此，避免死锁的x的最小值是2。

23. 一个消除环路等待的方法是用规则说明一个进程在任意时刻只能得到一个资源。举例说明在很多情况下这个限制是不可接受的。

- 考虑一个需要将大型文件从磁带复制到打印机的过程。因为内存量是有限的，整个文件不能直接复制到这个内存，所以该进程必须循环遍历以下语句直到整个文件被打印出来：获取磁带机将文件的下一部分复制到内存中（限制内存大小）释放磁带机获取打印机从内存打印文件释放打印机这将延长进程的执行时间。此外，由于打印机在每次打印步骤之后被释放，所以不能保证文件的所有部分都将被打印在连续的页面上。

24. 两个进程 A 和 B，每个进程都需要数据库中的3个记录1、2、3。如果A和B都以1、2、 3的次序请求，将不会发生死锁。但是如果B以3、 2、 1的次序请求，那么死锁就有可能会发生。对于这3种资源，每个进程共有3！（即6）种次序请求，这些组合中有多大的可能可以保证不会发生死锁？

- 假设进程A以a，b，c的顺序请求记录。如果进程B首先请求a，其中一个进程将获得a，另一个将阻塞。这种情况总是不会死锁的，因为赢家现在可以完成而没有干扰。在其他四种组合中，有些可能导致死锁，有些可能不会导致死锁。六种情况如下：

  a b c无死锁

  a c b无死锁

  b a c可能死锁

  b c a可能死锁

  c a b可能死锁

  c b a可能死锁

  由于六种情况中的四种可能导致死锁，所以有1/3的机会避免死锁和2/3的机会导致死锁。

25. 一个使用信箱的分布式系统有两条IPC原语：send和receive。receive原语用于指定从哪个进程接收消息，并且如果指定的进程没有可用消息，即使有从其他进程发来的消息，该进程也等待。不存在共享资源，但是进程由于其他原因经常需要通信。死锁会产生吗？请讨论这一问题。

- 会。假设所有的邮箱最初都是空的。现在A发送消息到B并等待回复，B发送到C并等待回复，C发送到A并等待回复。通信死锁的所有条件现在已经满足了。

26. 在一个电子资金转账系统中，有很多相同进程按如下方式工作：每一进程读取一行输入，该输入给出一定数目的款项、贷方账户、借方账户。然后该进程锁定两个账户，传送这笔钱，完成后释放锁。由于很多进程并行运行，所以存在这样的危险：锁定x会无法锁定y，因为y已被一个正在等待x的进程锁定。设计一个方案来避免死锁。在没有完成事务处理前不要释放该账户记录。（换句话说，在锁定一个账户时，如果发现另一个账户被锁定就立即释放这个已锁定的账户）

- 为了避免循环等待，使用资源（帐户）的号码进行编号。读取输入行后，进程首先锁定较小编号的帐户，然后在成功锁定该账户后（可能需要等待）再去锁定另一个帐户。由于没有任何进程等待一个编号小于现有账户的账户，所以永远不会构成循环等待，因此永远不会发生死锁。

27. 一种预防死锁的方法是去除占有和等待条件。在本书中，假设在请求一个新的资源以前，进程必须释放所有它已经占有的资源（假设这是可能的）。然而，这样做会引入这样的危险性：使竞争的进程得到新的资源但却丢失了原有的资源。请给出这一方法的改进。

- 更改请求新资源的语义如下。如果一个进程请求一个新的资源并且该资源是可用的，它就获取该资源并保持它已经拥有的资源。如果新资源不可用，则该进程所有已经占有的资源都将被释放。在这种情况下，死锁是不会发生的，并且没有新的资源获得后原有的资源丢失的危险性。当然这个进程只能工作在资源能够释放的情况下（你可以在页之间释放扫描仪，CD之间释放CD刻录机）。

28.  计算机系学生想到了下面这个消除死锁的方法。当某一进程请求一个资源时，规定一个时间限。如果进程由于得不到需要的资源而阻塞，定时器开始运行。当超过时间限时，进程会被释放掉，并且允许该进程重新运行。如果你是教授，你会给这样的学生多少分？为什么？

- 我会给它一个F（失败）的成绩。进程会做什么？很显然由于它需要资源，所以它再次询问并再次阻塞，这不如保持阻塞。事实上，可能会更糟糕的是，系统可能会跟踪竞争进程等待了多长时间，并将新释放的资源分配给等待时间最长的进程。通过定期释放和重新运行，一个进程丢失了它已经等待的时间的记录。 

29. 解释死锁、活锁和饥饿的区别

- 当一组进程被阻塞等待只有该集合中的其他进程可以释放的事件时，会发生死锁。另一方面，活锁中的进程不会被阻塞。相反，它们会继续检查永远不会成立的执行条件是否成立。因此，除了持有的资源之外，活动中的进程继续消耗宝贵的CPU时间。最后，会发生进程的饥饿，由于存在其他进程以及新的进程流，最终会导致饿死高优先级的进程。不像死锁或活锁，饥饿可以自己终止，例如当具有较高优先级的现有进程终止并且没有更高优先级的新进程到来时。

30. Cinderella 和 Prince 要离婚，为分割财产，他们商定了以下算法。每天早晨每个人发函给对方律师要求财产中的一项。由于邮递信件需要一天的时间，他们商定如果发现在同一天两人请求了同一项财产，第二天他们会发信取消这一要求。他们的财产包括狗Woofer、Woofer的狗屋、金丝雀Tweeter和Tweeter的鸟笼。由于这些动物喜爱它们的房屋，所以又商定任何将动物和它们房屋分开的方案都无效，而且整个分配从头开始。Cinderella和Prince都非常想要Woofer。于是他们分别去度假，并且每个都编写程序用一台个人计算机处理这一谈判工作。当他们度假回来时，发现计算机仍在谈判，为什么？产生死锁了吗？产生饥饿了吗?请讨论。

- 如果两个程序首先要求Woofer，那么电脑会无休止的饥饿：请求Woofer，取消请求，请求Woofer，取消请求等。如果其中一个请求狗窝，另一个请求狗，会发生死锁，双方会检测到该死锁，然后取消，但会在下一个循环中重复发生。无论哪种方式，如果两台计算机都被编程为首先去请求狗或狗屋，那么饥饿或死锁就会发生。两者之间没有太大的区别。在大多数死锁问题中，饥饿似乎并不严重，因为引入随机延迟通常会使它不太可能发生，但这种方法在这里不起作用。

31.一个主修人类学、辅修计算机科学的学生参加了一个研究课题，调查是否可以教会非洲狒拂理解死锁。他找到一处很深的峡谷，在上边固定了一根橫跨峡谷的绳索，这样狒拂就可以攀住绳索越过峡谷。同一时刻，只要朝着相同的方向就可以有几只狒狒通过。但如果向东和向西的狒拂同时攀在绳索上那么会产生死锁（拂拂会被卡在中间），因为它们无法在绳索上从另一只的背上翻过去。如果一只狒拂想越过峡谷，它必须看当前是否有别的狒拂正在逆向通行。利用信号量编写一个避免死锁的程序来解决该问题。不考虑连续东行的狒拂会使得西行的狒拂无限制地等待的情况。

答：略。

 

32.重复上一个习题，但此次要避免饥饿。当一只想向东去的狒狒来到绳索跟前，但发现有别的狒狒正在向西越过峡谷时，它会一直等到绳索可用为止。但在至少有一只狒拂向东越过峡谷之前，不允许再有拂狒开始从东向西越过峡谷。

答：略。

 

33.编写银行家算法的模拟程序。该程序应该能够循环检查每一个提出请求的银行客户，并且能判断这一请求是否安全。请把有关请求和相应决定的列表输出到一个文件中。

答：略。

 

34.写一个程序实现每种类型多个资源的死锁检测算法。你的程序应该从一个文件中读取下面的输入：进程数、资源类型数、每种存在类型的资源数（向量E）、 当前分配矩阵C （第一行，接着第二行，以此类推）、需求矩阵R（第一行，接着第二行，以此类推）。你的程序输出应表明在此系统屮是否有死锁。如果系统中有死锁，程序应该打印出所有死锁的进程id号。

答：略。



35.写一个程序使用资源分配图检测系统中是否存在死锁。你的程序应该从一个文件中读取下面的输入：进程数和资源数。对每个进程，你应该读取4个数：进程当前持有的资源数、它持有的资源的ID、它当前请求的资源数、它请求的资源ID。程序的输出应表明在此系统中是否有死锁。如果系统中有死锁，程序应该打印出所有死锁的进程id号。

答：略。



​  