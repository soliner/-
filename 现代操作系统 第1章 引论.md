第1章 引论

1.1 什么是操作系统

- 现代计算机系统由一个或多个处理器、主存、磁盘、打印机、键盘、鼠标、显示器、网络接口以及各种其他输入/输出设备组成
- 操作系统的任务是为用户程序提供一个更好、更简单、更清晰的计算机模型，蹦管理所有设备
- 用户阈值交互的程序，基于文本的通常称为shell，而基于图标的则称为图形用户界面（Graphical User Interface，GUI）
- 多数计算机有两种运行模式：内核态和用户态
- 操作系统运行在内核态（管态、核心态）

1.1 什么是操作系统

- 操作系统是一种运行在内核态的软件

1.1.1 作为拓展机器的操作系统

- 在机器语言一级上，多数计算机的体系结构（指令集、存储组织、I/O和总线结构）是很原始的

- 抽象是管理复杂性的一个关键

1.1.2 作为资源管理者的操作系统

- 把操作系统看做是想应用程序提供基本抽象的概念，是一种自顶向下的观点
- 自底向上的观点，操作系统则用来管理一个复杂系统的各个部分
- 现代操作系统允许同时运行多道程序。
- 资源管理包括用一下两种不同方式实现多路复用（共享）资源：在时间上复用和在空间上复用

1.2 操作系统的历史

- 操作系统已经存在许多年了

1.2.1 第一代（1945~1955）：真空管和穿孔卡片

1.2.2 第二代（1955~1965）：晶体管和批处理系统

1.2.3 第三代（1965~1980）：集成电路芯片和多道程序设计

- 多道程序设计，multiprogramming
  - 采取某种措施减少（昂贵的）CPU空闲时间的浪费
  - 将内存分为几个部分，每一部分存放不同的作业
- 同时的外部设备联机操作，Simultaneous Peripheral Operation On Line，SPOOLing
  - 任何时刻当一个作业运行结束时，操作系统就能将一个新作业从磁盘读出，装进空出来的内存区域运行
- 分时系统，timessharing，兼容分时系统（Compatible Time Sharing System，CTSS）是第一个通用的分时系统
- 公用计算机服务系统，MULTiplexed Information and Computing Service，MULTICS
- Ken Thompson 开发一个简化的、单用户版MULTICS，即UNIX
- UNIX两个主要版本：
  - 源自AT&T的SystemV
  - 加州伯克利大学的BSD（Berkeley Software Distribution）
- POSIX，IEEE提出的UNIX标准

1.2.4 第四代（1980年至今）：个人计算机

- Kildall编写了基于磁盘的操作系统，CP/M，Control Program for Microcomputer
- Seattle Computer Products的操作系统DOS，Disk Operating System
- Tim Paterson修改DOS称为MS-DOS，Microsoft DIsk Operation System
- Doug Engelbart发明图形用户界面，包括窗口、图标、菜单以及鼠标
- Steve Jobs看到GUI，推出Lisa，后失败，在尝试Macintosh，成功
- Windows95、Windows98（16位）、Windows NT（32位）、Windows2000（Windows NT 5.0）、Windows Me（Windows 98 另一个版本）、Windows XP、Vista
- UNIX在网络和企业服务器等领域强大
- FreeBSD是源自于Berkeley的BSD项目
- Macintosh计算机运行着FreeBSD的一个修改版
- UNIX系统都支持由MIT开发的称为X Windows的视窗系统，X11
- X11上还提供了一个完整的GUI，诸如Gnome或KDE
- 运行网络操作系统和分布式操作系统的个人计算机网络的增长

1.3 计算机硬件介绍

- 操作系统与运行该操作系统的计算机硬件密切联系
- CPU、内存以及I/O设备都由一条系统总线连接起来并通过总线与其他设备通信

1.3.1 处理器

- 计算机的“大脑”是CPU，它从内存中取出指令并执行之
- 所有的CPU内都有一些用来保存关键变量和临时数据的寄存器、程序计数器、堆栈指针、程序状态字（Program Status Word，PSW）寄存器
- 流水线（pipeline）机制
- 比流水线更先进的设计是超标量CPU
- 当在内核态运行时，CPU可以执行指令集中的每一条指令，并且使用硬件的每种功能
- 用户程序在用户态下运行，仅允许执行整个指令集的一个子集和访问所有功能的一个子集
- 系统调用（System call），TRAP指令把用户态切换成内核态，并启用操作系统
- 多线程和多核芯片
  - 具有多个功能部件的超标量体系结构
  - 多线程或超线程
    - 多线程允许CPU保持两个不同的线程状态，然后再纳秒级的时间尺度内来回切换

1.3.2 存储器

- 在任何一种计算机中的第二种主要部件都是存储器
- 存储器胸膛呢采用一种分层次的结构
- 存储器系统的顶层是CPU中的寄存器。
  - 用与CPU相同的材料制成，和CPU一样快，
  - 在32位CPU中为32×32位，在64位中为64×64位
- 下一层是高速缓存，
  - 它多数由硬件控制
  - 高速缓存命中
  - 任何缓存系统中，需要考虑的问题：
    - 何时把一个新的内容放入缓存
    - 把新内容发在缓存的哪一行上
    - 在需要时，应该吧哪些内容从缓存中移走
    - 应该吧新移走的内容放在某个较大存储器的何处
- 现代CPU中设计了两个缓存
  - 第一级或称为L1缓存，用来将已解码的指令调入CPU的执行引擎
  - 二级缓存，L2缓存，用来存放近来所使用过若干兆字节的内存字
- 主存
  - 存储器系统的主力
  - 称为随机访问存储器（Random Access Memory，RAM），磁芯存储器
  - 非易失性随机访问存储器
  - 只读存储器（Read Only Memory，ROM），用于启动计算机的引导加载模块，I/O卡
  - EEPROM（Electrically Erasabel PROM，电可擦除可编程ROM）和闪存（flash memory）也是非易失性的
  - CMOS存储器，易失性的，保持当前时间和日期

1.3.3 磁盘

- 磁盘是一种机械装置
- 在一个任意一个给定臂的位置，每个磁头可以读取一段环形区域，称为磁道（track）
- 把一个给定臂的位置上的所有磁道合并起来，组成一个柱面（cylinder）
- Memory Management Unit，MMU，存储管理单元，CPU的一个部件，需要快速地映像内存地址，以便把程序生成的地址转换为有关字节在RAM中的物理地址

1.3.4 磁带

- 在存储器体系中的最后一层是磁带
- 这种介质经常用于磁盘的备份，并且可以保存非常大量的数据集

1.3.5 I/O设备

- I/O设备一般包括两个部分
  - 设备控制器
    - 控制器是插在电路板上的一块或一组芯片，这块电路板物理地控制设备
  - 设备本身
    - IDE，Integrated Drive Electronics，表示集成驱动器电子设备，是许多计算机的磁盘标准
    - 设备驱动程序，device driver，专门与控制器对话，发出命令并接受响应的软件
    - 将设备驱动程序装入操作系统，有三个途径
      - UNIX：将内核与设备驱动程序重新链接，然后重启动程序
      - Windows：在一个操作系统文件中设置一个入口，并通知该文件需要一个设备驱动程序，然后重启动系统
      - 操作系统能够在运行时接受新的设备驱动程序并且立即将其安装好
    - 所有设备寄存器的集合构成了I/O端口空间
    - 实现输入和输出的方式有三种
      - busy waiting，忙等待：缺点是占据CPU，CPU一直轮询设备到对应的I/O操作完成
      - 设备驱动程序启动设备并且让该设备在操作完成时发出一个中断
      - 为I/O使用一种特殊的直接存储器访问（Direct Memory Access，DMA）芯片，它可以控制在内存和某些控制器之间的位流，而无须持续的CPU访问

1.3.6 总线

- 大型Pentium系统有8个总线（高速缓存、局部、内存、PCI、SCSI、USB、IDE和ISA），每个总线传输速度和功能都不同
- ISA（Industry Standard Architecture）总线
  - ISA总线就是原先的IBM PC/AT总线
  - 以8.33MHz频率运行，可并行传送2字节，最大速率为16.67MB/s
- PCI（Peripheral Component Interconnect）总线
  - 在66MHz频率运行，可并行传送8字节，数据速率为528MB/s
- IDE总线将诸如磁盘和CD-ROM一类的外部设备与系统相连
- USB，University Serial Bus，通用串行总线是用来将所有慢速I/O设备，诸如键盘和鼠标，与计算机连接
  - USB1.0可以处理总计为1.5MB/s的负载
  - USB2.0可以有60MB/s的速率
- SCSI（Small Computer System Interface）总线是一种高速总线，用在高速硬盘、扫描仪和其他需要较大带宽的设备上
  - 最高可达320MB/s
  - SCSI总线一直用在Macintosh系统上
- IEEE 1394，
  - 有时，它称为火线（FireWire）
  - 与USB一样，IEEE 1394是位串行总线
  - 适合于将数码相机和类似的多媒体设备连接到计算机上
- 即插即用，plug and play
  - 系统自动地收集有关I/O设备的信息，集中赋予中断级别和I/O地址，然后通知每块卡所使用的数值

1.3.7 启动计算器

- Pentium的简要启动过程
  - 在每一个Pentium上有一块双亲版，曾用名母版
  - 在双亲版上有一个称为基本输入输出系统（Basic Input Output System，BIOS）的程序
    - 在BIOS内有底层I/O软件，包括读键盘、写屏幕、进行磁盘I/O以及其他过程
    - BIOS存放在一块闪速RAM中，它是非可易失性的，但是发现BIOS中有错时可以通过操作系统对它进行跟新
  - 在计算机启动时，BIOS开始运行
    - 首先检查所安装的RAM数量，键盘和其他基本设备是否已安装并正常响应
    - 扫描ISA和PCI总线并找出连在上面所有设备
  - BIOS通过尝试存储CMOS存储器中的设备清单决定启动设备
  - 操作系统询问BIOS，以获得配置信息

1.4 操作系统大观园

操作系统已经存在了半个多世纪，出现了各种类型的操作系统

1.4.1 大型机操作系统

- 操作系统的高端是用于大型机的操作系统
- 用于大型机的操作系统主要用于面向多个作业的同时处理，多数这样的作业需要巨量的I/O能力
- 系统提供三类服务
  - 批处理
    - 处理不需要交互式用户干预的周期性作业
    - 保险公司的索赔处理或连锁商店的销售报告
  - 事务处理
    - 负责大量小的请求
    - 银行的支票处理或航班预定
  - 分时处理
    - 允许多个远程用户同时在计算机上运行作业
    - 大型数据库上的查询
- OS/390大型机操作系统，正在被Linux这类UNIX的变体所替代

1.4.2 服务器操作系统

- 下一层次是服务器操作系统
- 在服务器上运行，服务器可以是大型的个人计算机、工作站，甚至是大型机
- 典型的服务器操作系统有Solaris、FreeBSD、Linux和Windows Server 200x

1.4.3 多处理器操作系统

- 通常将多个CPU连接成单个的系统，获得大量联合计算能力的操作系统
- 依据连接和共享方式的不同，这些系统称为并行计算机、多计算机或多处理器
- 通常采用的操作系统是配有通信、连接和一致性等专门功能的服务器操作系统的变体
- 主流操作系统都可以运行在多核处理器上

1.4.4 个人计算机操作系统

- 现代个人计算机操作系统都支持多道程序处理
- 这类系统广泛用于字处理、电子表格、游戏和Internet访问
- 常见的例子是Linux、FreeBSD、Windows Vista和Macintosh

1.4.5 掌上计算机操作系统

- 掌上计算机或者个人数字助理（Personal Digital Assistant，PDA）是一种可以装进衬衫口袋的小型计算机
- 这些设备都是基于带有保护功能的32位CPU
- 在掌上设备上最主要的两个操作系统是Symbian OS和Plam OS

1.4.6 嵌入式操作系统

- 嵌入式操作系统在用来控制设备的计算机中运行
- 典型的例子有微波炉、电视机、汽车、DVD刻录机、移动电话以及MP3播放器一类的设备
- 不可信的软件肯定不能在嵌入式系统上运行
- 主要的嵌入式操作系统有QNX和VxWorks等

1.4.7 传感器节点操作系统

- 有许多用途需要配置微小传感器节点网络
- 这些节点是一种可以彼此通信并且使用无线通信基站的微型计算机
- 传感器是一种内建有无线电的电池驱动的小型计算机
- 每个传感器节点是一个配有CPU、RAM、ROM以及一个或多个环境传感器的实实在在的计算机
- 节点上运行一个小型但是真实的操作系统，通常这个操作系统是事件驱动的，可以响应外部事件，或者基于内部时钟进行周期性的测量
- 该操作系统必须小且简单
- TinyOS是一个用于传感器节点的知名操作系统

1.4.8 实时操作系统

- 实时操作系统的特征是将时间作为关键参数
- 例如，在工厂过程控制系统中，工厂中的实时计算机必须收集生产过程的数据并用有关数据控制机器
- 通常，系统还必须满足严格的最终时限
  - 硬实时系统：某个动作必须绝对地在规定的时刻（或规定的时间范围）发生
  - 软实时系统中：偶尔违反最终时限是不希望的，但是可以接受，并且不会引起任何永久性的损害
    - 数字音频或多媒体系统、数字电话
- 硬实时系统就是一个简单的与应用程序链接的库，各个部分必须紧密耦合并且彼此之间没有保护，例如e-Cos

1.4.9 智能卡操作系统

- 最小的操作系统运行在智能卡上
- 智能卡是一种包含有一块CPU芯片的信用卡
- 有些智能卡是面向Java的，其含义是在智能卡的ROM有一个Java虚拟机（Java Virtual Machine，JVM）解释器

1.5 操作系统概念

- 多数操作系统都使用某些基本概念和抽象，诸如进程、地址空间以及文件等

1.5.1 进程

- 进程（Process）本质上是正在执行的一个程序
- 与每个进程相关的是进程的地址空间（address space），这是从某个最小值的存储位置（通常是零）到某个最大值存储位置的列表
- 与每个进程相关的还有资源集，通常包括寄存器（含有程序计数器和堆栈指针）、打开文件的清单、突出的报警、有关进程清单、以及运行该程序所需要的所有其他信息
- 进程基本上是容纳运行一个程序所需要所有信息的容器
- 在许多操作系统中，与一个进程右端的所有信息，除了该进程自身地址空间的内容以外，均存放在操作系统的一张表中，称为进程表（process table），进程表是数组（或链表）结构
- 一个（挂起的）进程包括：
  - 进程的地址空间（磁芯映像，core image）
  - 对应的进程表项，包括寄存器以及稍后重启动该进程锁需要的许多其他信息
- 与进程管理有关的最关键的系统调用时那些进行进程创建和进程终止的系统调用
  - 若一个进程能够创建一个或多个进程（称为子进程），而且这些进程又可以创建子进程，则很容易得到进程树
  - 合作完成某些作业的相关进程经常需要彼此间通信以便同步它们的行为，这种通信称为进程间通信（interprocess communication）
- 其他可用的进程系统调用包括：
  - 申请更多的内存（或释放不再需要的内存）
  - 等待一个子进程结束
  - 用一个程序覆盖该程序
- 系统管理器授权每个进程使用一个给定的UID标识（User IDentification）。每个启动的进程都有一个启动该进程的用户UID。子进程拥有与父进程一样的UID。用户可以是某个组的成员，每个组也有一个GID标识（Group IDentification）
- 在UNIX中，有一个UID称为超级用户（superuser），具有特殊的权利，可以违背一些保护规则

1.5.2 地址空间

- 通常，每个进程有一些可以使用的地址集合，典型值从0开始直到某个最大值
- 在许多32位或64位地址的计算机中，分别有2^32或2^64的地址空间
- 对地址空间和物理空间的管理组成了操作系统功能的一个重要部分

1.5.3 文件

- 操作系统的一项主要功能是隐藏磁盘和其他I/O设备的细节特性，并提供给程序员一个良好、清晰的独立于设备的抽象文件模型
- 创建文件、删除文件、读文件和写文件等都需要系统调用
- 为了提供保存文件的地方，大多数操作系统支持目录（directory）的概念，从而把文件分类成组
  - 进程和文件层次都可以组织成树状结构，但这两种树状结构有不少不同之处
    - 一般进程的树状结构层次不深（很少超过三层），而文件树状结构的层次常常多达四层、五层或更多层
    - 进程树层次结构是暂时的，通常最多存在几分钟，而目录层次则可能存在数年之久
    - 进程和文件在所有权及保护方面也是有区别的
  - 目录层结构中的每一个文件都可以通过从目录的顶部，即根目录（root directory)开始的路径名（path name）来确定
  - 在实例中，每个进程有一个工作目录（working directory）,其中，路径名不以斜线开始
- 在读写文件之前，首先要打开文件，检查其访问权限
  - 若权限许可，系统返回一个小整数，称作文件描述符（file descriptor），供后续操作使用。
  - 若禁止访问，系统则返回一个错误码
- 在UNIX中的另一个重要概念是安装文件系统
- 在UNIX中，另一个重要的概念是特殊文件（special File）
  - 为了使I/O设备看起来像文件一样
  - 有两类特殊文件：
    - 块特殊文件（block special file）
      - 指那些由可随机存取的块组成的设备，如磁盘等
    - 字符特殊文件（character special File）
      - 字符特殊文件用于打印机、调制解调器和其他接收或输出字符流的设备
  - 特殊文件保存在/dev目录中
- 既与进程有关也与文件有关：管道
  - 管道（pipe）是一种虚文件，它可连接两个进程

1.5.4 输入/输出

- 所有的计算机都有用来获取输入和产生输出的物理设备
  - 计算机有各种类型的输入和输出设备，包括键盘、显示器、打印机等
- 每个操作系统都有管理其I/O设备的I/O子系统
  - 某些I/O软件是设备独立的，即这些I/O软件部分可以同样应用于许多或者全部的I/O设备上

1.5.5 保护

- 计算机中有大量的信息，用户进场对其进行保护，并保守秘密
- 管理系统的安全性完全依靠操作系统
- UNIX操作系统通过对每个文件赋予一个9位的二进制保护代码
  - 该代码有三个3位字段
    - 用于所有者
    - 用于所有者同组（用户被系统管理员划分成组）中的其他成员
    - 用于其他人
  - 每个字段中一位用于读访问，一位用于写访问，一位用于执行访问
  - 这些位就是知名的rwx位
- 其他安全的问题
  - 保护系统不被人类或非人类（如病毒）入侵

1.5.6 shell

- 操作系统是进行系统调用的代码
- 编辑器、编译器、汇编程序、链接程序以及命令解释器等，尽管非常重要，也非常有用，但是它们确实不是操作系统的组成部分
- UNIX的命令解释器，称为shell
  - 不是操作系统的一部分
  - 很好地说明了系统调用的具体用法
  - 也是终端用户与操作系统之间的界面，除非用户使用的是一个图形用户界面
  - 有许多种类的shell，如sh、csh、ksh、以及bash等
- 现在，许多个人计算机使用GUI
  - GUI只是一个运行在操作系统顶部的程序
  - Linux中可以在两个GUI中选择一个：Gnome和KDE，或者干脆不用（使用X11上的终端视窗）
  - Windows中也有可能用不同的程序代替标准的GUI桌面（Windows Explorer）

1.5.7 个体重复系统发育

- 德国动物学家Ernst Haeckel论述了”个体重复系统发育“（ontogeny recapitulates phylogeny）
  - 含义是，一个个体重复着物种的演化过程
  - 在计算机的历史中，类似情形依稀发生
- 计算机科学和许多领域一样，主要是由技术驱动的
- 大型内存
  - 硬件重复地影响着软件
    - 第一代大型机（IBM7090或7094）内存有限（128KB），多数用汇编语言编程
    - FORTRAN和COBOL一类语言的编译器
    - 第一个商用小型计算机（PDP-1）有4096个18位字的内存，采用汇编语言
    - 小型计算机获得更多内存，采用高级语言
    - 微型计算机出现（4KB），汇编语言复活
    - 个人计算机拥有大量的内存，使用C、C++、Java和其他高级语言编程
- 保护硬件
  - 早期的IBM 7090/7094一类大型机，单道程序处理
  - 小型计算机
    - 第一个小型计算没有保护硬件、多道程序处理
    - PDP-11型机器有了保护硬件
  - 微型计算机
    - 第一代微型计算机，使用Intel 8080 CPU芯片，但没有保护硬件
    - 直到Intel 80286才增加了保护硬件，于是才有了多道程序处理
- 硬盘
  - 大型机
    - 早期大型机主要是基于磁带的
    - 在IBM于1956年引入第一个磁盘RAMAC（RAndM ACess）
  - 小型计算机
    - 1970年在PDP-11上引入了标准硬盘，RK05磁盘，容量为2.5MB
  - 微型计算机
    - CP/M成为操作系统的主流
- 虚拟内存
  - 虚拟内存，通过在RAM和磁盘中反复移动信息块的方式，提供了运行比机器物理内存大的程序能力
  - 虚拟内存可以运行时动态地链接库，而不是必须在编译时链接
  - MULTICS是第一个可以做到这点的系统
  - 现在广泛用于多数的UNIX和Windows系统中
  - 在一种环境中出现的思想，随着环境的变化被抛弃（汇编编程语言，单道程序处理，单层目录等），通常在十年之后，该思想在另一种环境下又重现了

1.6 系统调用

- 操作系统具有两种功能：为用户程序提供抽象和管理计算机资源
- 用户程序和操作系统之间的交互处理的是前者
- 对用户而言，资源管理部分主要是透明和自动完成的
- 用户程序和操作系统之间的交互主要就是处理抽象
- 在如下的可能方式中进行选择：
  - 含混不清的一般性叙述（“操作系统提供读取文件的系统调用”
  - 某个特定的系统（“UNIX提供一个由三个参数的read系统调用：一个参数指定文件，一个说明数据应存放的位置，另一个说明应读出多少个字节”）
- 任何单CPU计算机一次只能执行一条指令
- 系统调用就行进行一个特殊的过程调用，但是只有系统调用可以进入内核
- read系统调用：
  - 第一个参数指定文件
  - 第二个指向缓冲区
  - 第三个说明要读出的字节数
  - 它的调用由C程序完成，方法是调用一个与该系统调用名称相同的库过程：read
  - 第一个和第三个参数是值调用
  - 第二个参数通过引用传递，即传递的是缓存区的地址
  - 对库过程的实际调用（第4步），这个指令是用来调用所有过程的正常过程调用指令
  - 把系统调用的编号放在操作系统所期望的地方，如寄存器中（第5步）
  - 执行一个TRAP指令，将用户态切换到内核态，并在内核中的一个固定地址开始执行（第6步）
    - TRAP指令与过程调用指令相当类似
    - TRAP指令与过程指令存在两个方面的差别
      - 切换到内核态
      - TRAP指令不能跳转到任意地址上
  - 跟随在TRAP指令后的内核代码开始检查系统调用编号，然后发出正确的系统调用处理命令，这通常是通过一张由系统调用编号所引用的、指向系统调用处理器的指针表来完成（第7步）
  - 系统调用使用句柄运行（第8步）
  - 控制跟随TRAP指令后面的指令中返回给用户空间库过程（第9步）
  - 一通常的过程调用返回的方式，返回到用户程序（第10步）
  - 用户必须清除堆栈（第11步）
- POSIX系统调用
  - POSIX大约有100个过程调用
  - 所有包含的服务有创建与终止进程，创建、删除、读入和写入文件，目录管理以及完成输入输出
  - POSIX标准定义了构造系统所必须提供的一套过程，但是并没有规定它们是系统调用，是库调用还是其他形式
  - 多数POSIX过程确实进行系统调用，通常是一个过程直接映射一个系统调用上

1.6.1 用于进程管理的系统调用

- 在UNIX中，fork是唯一可以在POSIX创建进程的途径，它创建一个原有进程的精确副本，包括所有的文件描述符，寄存器等全部内容
- fork之后，原有的进程及其副本（父与子）就分开了
- 在fork之后，子进程需要执行与父进程不同的代码。
- fork调用返回一个值，在子进程中该值为零，并且等于子进程的进程标识符，或等于父进程中的PID
- 在最一般情形下，execve有是三个参数：将要执行的文件名称，一个指向变量数组的指针，以及一个指向环境数组的指针。
- 该参数通过waitpid系统调用中的statloc返回给父进程
- 在UNIX中的进程将其存储空间划分为三段：
  - 正文段（如程序代码）
  - 数据段（如变量）
  - 堆栈段
- 数据段向上增长而堆栈段向下增长，夹在中间的是未使用的地址空间。堆栈在需要时自动地向中间增长

1.6.2 用于文件管理的系统调用

- 许多系统调用与文件系统有关
- 要读写一个文件，先要使用open打开该文件
- O_RDONLY、O_WRONLY或O_RDWR的含义分别是读、写或两者
- 创建一个新文件，使用O_CREAT参数
- 最常用的调用是read和write
- lseek调用可以改变该位置指针的值
  - lseek有三个参数：
    - 第一个是文件的描述符
    - 第二个是文件位置
    - 第三个说明该文件位置是相对于文件起始位置、当前位置，还是文件的结尾
- stat系统调用查看UNIX为每个文件保存了该文件的类型（普通文件、特殊文件、目录等），大小，最后修改时间以及其他信息
  - 第一个参数制定了要被检查的文件
  - 第二个参数是一个指针，该指针指向用来存放这些信息的结构
  - fstat调用完成同样的工作

1.6.3 用于目录管理的系统调用

- mkdir和rmdir分别用于创建和删除空目录
- link的作用是允许同一个文件以两个或多个名称出现，多数情形下是在不通过的目录中这样做
- link的工作：
  - 在UNIX中，每个文件都有唯一的编号，即i-编号，用以标识文件
  - 一个目录就是包含了（i-编号，ASCⅡ名称）对集合的一个文件
  - mount系统调用允许将两个文件系统合并成为一个
  - 通过执行mount系统调用，可以将一个CD-ROM文件系统添加到根文件系统中
    - 第一个参数是驱动器0的块特殊文件名称
    - 第二个参数是要被安装在树中的位置
    - 第三个参数说明将要安装的文件系统是可读写的还是只读的

1.6.4 各种系统调用

- chdir调用改变当前的工作日目录
- 在UNIX中，每个文件有一个保护模式
  - 该模式包括针对所有者、组合和其他用户的读-写-执行位
  - chmod系统调用可以改变文件的模式
  - kill系统调用供用户或用户进程发送信号用
- POSIX定义了若干处理时间的过程
  - time以秒为单位返回当前时间
  - 0对应着1970年1月1日午夜
  - 在一台32位字的计算机中，time的最大值是2^32-1秒

1.6.5 Windows Win32 API

- Windows和UNIX的主要差别在于编程方式
  - 一个UNIX程序包括做各种处理的代码以及从事完成特定服务的系统调用
  - 一个Windows程序通常是一个时间驱动程序
- 在UNIX中，
  - 每个系统调用，差不多就涉及一个被调用的库过程
  - POSIX有约100个过程调用
- 在Windows中，
  - 库调用和实际的系统调用是几乎不对应的
  - 应用编程接口（Application Program Interface,Win 32 API），程序员用这套过程获得操作系统的服务
  - Win32表示所有Windows版本都支持的接口
- Win32 API调用的数量是非常大的，数量有数千个
- Win32 API中有大量的调用，用来管理视窗、几何图形、文本、字型、滚动条、对话框、菜单以及GUI的其他功能
  - CreateProcess为创建一个新进程，它把UNIX中的fork和execve结合起来
    - 它有许多参数用来指定新创建进程的性质
  - WaitForSingleObject用于等待一个事件，等待的时间可以是多种可能的事件
  - ExitProcess用于等待锁指定的进程推出
  - SetFilePointer以及GetFielAttributesEx调用设置文件的位置并取得文件的一些属性
  - CreateDirectory以及RemoveDirectory API调用目录的创建和删去
  - GetLocalTime可获得当前时间
- Win32接口中没有文件的连接、文件系统的安装、安全属性或信号
- Win32并不是非常统一的或由一致的接口
  - 主要原因是由于Win32需要与早期的在Windows 3.x中使用的16位接口向后兼容

1.7 操作系统结构

- 六种不同的结构设计，单机系统、层次系统、微内核、客户机-服务器系统、虚拟机和exokernels等

1.7.1 单体系统

- 在目前为止，在多数常见的组织形式的处理方式中，全部操作系统在内核态中以单一程序的方式运行
- 整个操作系统以过程集合的方式编写，链接成一个大型可执行二进制程序
- 对于这类操作系统的基本结构
  - 需要一个主程序，用来处理服务过程请求
  - 需要一套服务过程，用来执行系统调用
  - 需要一套使用过程，用来辅助服务过程

1.7.2 层次性系统

- 它的上层软件都是在下一层软件的基础之上构建的
- THE系统（1968），是按此模型构建的第一个操作系统
  - 该系统共分为六层
  - 第0层提供了基本的CPU多道程序功能
  - 第1层进行内存管理，它分配进程的主存空间
  - 第2层处理进程与操作员控制台（即用户）之间的通信
  - 第3层管理I/O设备和相关的信息流缓冲区
  - 第4层是用户程序层，用户不用考虑进程、内存、控制台或I/O设备管理等细节
  - 第5层提供系统操作员进程
- MULTICS系统中采用了更进一步的通用层次化概念
  - MULTICS由许多的同心环构造而成，内层环比外层环有更高的级别
  - 当外环的过程欲调用内环的过程时，它必须执行一条等价于系统调用的TRAP指令
- THE分层系统的各个部分最终仍然被链接成了完整的单个目标程序
- MULTICS的环形机制在运行中是实际存在的，而且是由硬件实现的
  - 优点是很容易扩展，可用以构造用户子系统

1.7.3 微内核

- 微内核设计背后的思想是，为了实现高可靠性，将操作系统划分成小的、良好定义的模块，只有微内核模块运行在内核态，其余的模块，由于功能相对弱些，则作为普通用户进程运行
- 微内核在实时、工业、航空以及军事应用中特别流行，这些领域都是关键任务，需要有高度的可靠性
  - 知名的微内核有Integrity、K42、L4、PikeOS、QNX、Symbian、MINIX 3等
  - MINIX 3把模块化的思想推到了极致，它将大部分操作系统分解成许多独立的用户态进程
  - MINIX 3微内核只有3200行C语言代码和800行用于非常低层次功能的汇编语言代码，诸如捕捉中断、进程切换等
- 在内核的外部，系统的构造有三层进程，它们都在用户态中运行
  - 最底层中包含设备驱动器
  - 在驱动器上面是另一用户态层，包含有服务器
    - 再生服务器，检查其他服务器和驱动器的功能是否正确
- 系统对每个进程的权限有着许多限制
- 一个与小内核相关联的思想是在内核中的机制与策略分离的原则
  - 进程调度
    - 一个比较简单的调度算法是，对每个进程赋予一个优先级，并让内核执行在具有最高优先级进程中可以运行的某个进程
    - 机制就是寻找最高优先级的进程并运行之
    - 策略（赋予进程以优先级）可以由用户态中的进程完成

1.7.4 客户机-服务器模式

- 一个微内核思想的略微变体是将进程分为两类：
  - 服务器，每个服务器提供了某种服务
  - 客户端，使用这些服务，
- 微内核的本质是存在客户端进程和服务器进程
- 在客户端和服务器之间的通信是消息传递

1.7.5 虚拟机

- OS/360的最早版本是纯粹的批处理系统
- z/VM
  - 目前在IBM的大型机上广泛使用
  - zSerice则在大型公司的数据中心广泛使用
    - 作为电子商务服务器，它们每秒可以处理成百上千个事务，并使用规模达数万GB的数据库

1. VM/370

- 最初命名为CP/CMS，后来改名为VM/370
- 它是源于如下机敏的观察
  - 分时系统应该提供这些功能
    - 多道程序
    - 一个比裸机更方便的、有拓展界面的计算机

- virual machine monitor，虚拟机监控程序
  - 这个系统的核心，它在裸机上运行并且具备了多道程序功能
- 这些虚拟机不是那种具有文件等优良特征的扩展计算机
- 是裸机硬件的精确赋值品，包含内核态/用户态、I/O功能、中断及其他真实硬件所应该具备的全部内容
- 会话监控系统，Conversational Monitor System，CMS
  - 一些虚拟机运行单用户、交互式系统供分时用户们使用
- 当一个CMS程序执行系统调用是，该调用被陷入到其虚拟机的操作系统上，而不是VM/370上
  - 
- 虚拟机的现代化身，z/VM，通常用于运行多个完整的操作系统
- 虚拟机的再次发现
  - 需求：
    - 虚拟化可以使邮件服务器、Web服务器、FTP服务器等在同一台机器上运行所有的服务器
    - 虚拟化在Web托管世界里也很流行
    - 为希望同时运行两个或多个操作系统
      - “虚拟机监控程序”近年来已经变化成类型1虚拟机管理程序（type 1 hypervisor）
  - VMware工作站是类型2虚拟机管理程序
    - 类型2虚拟机管理程序作为一个应用程序运行在Windows、Linux或其他操作系统上，这些系统称为宿主机操作系统
    - 在客户端操作系统启动时，它完成在真实硬件上相同的工作
  - 处理控制指令的一种不同方式是，修改操作系统，删掉它们，即准虚拟化（paravirtualization）
- Java虚拟机

1.7.6 外核

- 与虚拟机克隆真实机器不同，另一种策略是对机器进行分区

- 在底层中，一种称为外核（exokernel）的程序在内核态中运行
  - 任务是为虚拟机分配资源，并检查试图使用这些资源的企图
- 外核机制的优点
  - 减少了映像层
  - 它将多道程序（在外核内）与用户操作系统代码（在用户空间内）加以分离

1.8 依靠C的世界

- 操作系统通常是由许多程序员写成的，包括很多部分的大型C程序

1.8.1 C语言

- Java是基于C的
  - 两者都是命令式的语言
    - 有数据类型、变量和控制语句
    - 在C中基本数据类型是整数（包括短整数和长整数）、字符和浮点数等，使用数组、结构体和联合，可以构造组合数据类型
    - C语言中的控制语句与Java类似，包括if、switch、for以及while
    - 函数和参数大致相同
  - 一项C语言中有的而Java中没有的特点是显式指针（explicit pointer）
    - 指针是一种指向（即包含对象的地址）一个变量或数据结构的变量
  - C语言没有的包括内建字符串、线程、包、类、对象、类型安全（type safety）以及垃圾回收（garbage collection）等

1.8.2 头文件

- 一个操作系统项目通常包括多个目录
  - 每个目录都含有许多.c文件，这些文件中存有系统某个部分的代码
  - 一些.h头文件则包含供一个或多个代码文件使用的声明以及定义
- 头文件还可以包括简单的宏
- 通过使用#include指令，一个.c文件体可以含有零个或多个头文件

1.8.3 大型编程项目

- 为了构建操作系统，每个.c被C编译器编译成一个目标文件
- 目标文件使用后缀.o，含有目标机器的二进制代码
- C编译器的第一道称为C预处理器
  - 在UNIX系统中，有个名为make的程序（其大量的变体如gmake、pmake等），它读入Makefile，该MakeFile说明哪个文件与哪个文件相关
  - make的作用，在构建操作系统二进制码时，检查刺客需要哪个目标文件
  - 在大型项目中，创建Makefile是一件容易出错的工作
- 一旦所有的.o文件都已经就绪，这些文件被传递给称为linker的程序，将其组合成一个单个可执行的二进制文件，在UNIX中传统上称为a.out文件

1.8.4 运行模型

- 在操作系统二进制代码链接完成后，计算机就可以重新启动，新的操作系统开始运行
- 在运行过程中，操作系统可能由若干段组成，有
  - 文本段（程序代码）
    - 文本段通常是不可改变的，在运行过程中不可修改
    - 放置在接近内存底层的位置
  - 数据段
    - 开始时有一定的大小，并用确定的值进行初始化，但是随后就被修改了，其大小随需要增长
    - 
  - 堆栈段
    - 被初始化为空，但是随着对函数的调用和从函数返回，堆栈段时时刻刻在增长和缩小
    - 在高位的虚拟地址，具有向下增长的能力
- 在所有情形下，操作系统代码都是直接在硬件上执行的，不用解释器，也不是即使编译

1.9 有关操作系统的研究

- 计算机科学是快速发展的领域，很难预测其下一步的发展方向
- 一种思想从出现到形成影响常常需要20~30年
  - 艾森豪威尔总统在1958年建立国防部高级研究项目署（ARPA）
  - 第一个实验包交换网的建立，即ARPANET，于1969年启用
  - 20世纪90年代早期，Tim Berners-Lee在日内瓦的CERN研究所发明了万维网（World Wide Web），Marc Andresen在伊利诺伊大学为万维网写了一个图形浏览器
- 对操作系统的研究导致了实际操作系统的戏剧性变化
- 发表在ACM刊物、IEEE计算机协会或者USENIX刊物上，并对这些组织的（学生）成员们在Internet上开放
- 实际上，所有的操作系统研究人员都认识到，目前的操作系统是一个大的、不灵活、不可靠、不安全和带有错误的系统，而且特定的某个操作系统较其他的系统有更多的错误
- 文献有：新操作系统，操作系统结构，操作系统正确性、操作系统可靠性、虚拟机、病毒和蠕虫、错误和排错，超线程与多线程，用户行为

1.10 本书其他部分概要

- 从程序员的官点来看，操作系统的基本目的是提供一些关键的抽象

1.11公制单位

- 前缀用首字缩写而成，凡是单位大于1的首字母均大写
- Kilo表示2^10
- KB、MB和GB分别表示2^10字节、2^20字节和2^30字节
- Kbps、MBPS、GBPS分别表示10^3bps、10^6bps和10^9bps

1.12 小结

- 考察操作系统有两个观点：
  - 资源管理观点
    - 操作系统的任务是有效地管理系统的各个部分
  - 扩展的机器观点
    - 操作系统的任务是为用户提供比实际机器更便于运用的抽象
    - 抽象包括进程、地址空间以及文件
- 计算机由处理器、存储器以及I/O设备组成，这些部件通过总线连接
- 所有操作系统构建所依赖的基本概念是进程、存储管理、I/O管理、文件管理和安全
- 任何操作系统的核心是它可处理的系统调用集
  - 对于UNIX，我们已经考察了四组系统调用
    - 第一组系统调用同进程的创建和终结有关
    - 第二组用于读写文件
    - 第三组用于目录管理
    - 第四组包括各种杂项调用
- 操作系统构建方式有多种，单体层次、层次化系统、微内核系统、客户机-服务器系统、虚拟机系统和外核系统

习题








