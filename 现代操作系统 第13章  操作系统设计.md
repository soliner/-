# 现代操作系统 第13章  操作系统设计

（原书第3版） (计算机科学丛书)

Andrews Tanenbaum

Citation (APA): Tanenbaum, A. (2019). *现代操作系统（原书第3版） (计算机科学丛书)* [Kindle Android version]. Retrieved from Amazon.com

------

# 第13章 操作系统设计

- 在本章中，我们将简述操作系统设计人员在设计与实现一个新系统时必须要考虑的某些问题和权衡。
  - 在系统设计方面，关于什么是好，什么是坏，存在着一定数量的民间传说在操作系统界流传，但是令人吃惊的是这些民间传说很少被记录下来。最重要的一本书可能是 


- 有关操作系统设计的三篇经典论文是
  - “ Hints for Computer System Design ”（计算机系统设计的忠告，Lampson, 1984）、
  - “On Building Systems that Will Fail”（论建造将要失败的系统，Corbató, 1991）
  - 和“End-to-End Arguments in System Design”（系统设计中端到端的论据， Saltzer 等人，1984）
- 由于操作系统设计人员在设计操作系统的最优方法上没有达成共识，因此与前面各
- 相比，本章更加主观，也无疑更具有争议。

##13.1 设计问题的本质

- 操作系统设计与其说是精确的科学，不如说是一个工程项目。设置清晰的目标并且满足这些目标非常困难

### 13.1.1 目标

- 为了设计一个成功的操作系统，设计人员对于需要什么必须
- 清晰的思路。
  - 缺乏目标将使随后的决策非常难于做出。
  - PL/ 1具有一些 FORTRAN 的特点、一些 COBOL 的特点和一些 Algol 的特点。但是该语言失败了，因为它缺乏统一的洞察力。它只是彼此互相竞争的功能特性的大杂烩，并且过于笨重而不能有效地编译。
  - 现在考察 C 语言。它是一个人（ Dennis Ritchie）为了一个目的（系统程序设计）而设计的。 C 语言在所有的方面都取得了巨大的成功，因为 Ritchie 知道他需要什么，不需要什么。 
- 很明显，不同的系统会有所不同，嵌入式系统就不同于服务器系统。然而，对于通用的操作系统而言，需要留心 4 个基本的要素： 
  - 1) 定义抽象概念。 
  - 2) 提供基本操作。 
  - 3) 确保隔离。
  - 4) 管理硬件。
- 一个操作系统最重要但可能最困难的任务是定义正确的抽象概念。
  - 每一个抽象概念可以采用具体数据结构的形式实例化。
    - 用户可以创建进程、文件、信号量等。
    - 基本操作则处理这些数据结构。
  - 由于多个用户可以同时登录到一台计算机，操作系统需要提供机制将他们隔离。
    - 与这一要点密切相关的是需要隔离故障
  - 系统设计应该确保系统的不同部分良好地相互隔离。
  - 最后，操作系统必须管理硬件。

###13.1.2 设计操作系统为什么困难

- 使设计一个操作系统比设计一个应用程序要更加困难的 8 个问题。
  - 第一，操作系统已经成为极其庞大的程序。
    - 当你拥有一件产品，如果没有一名设计师能够有望完全理解它时，结果经常远没有达到最优也就不难预料了。
    - 操作系统不是世界上最复杂的系统，例如，航空母舰就要复杂得多，但是航空母舰能够更好地分成相互隔离的部分。 
  - 第二，操作系统必须处理并发。
  - 第三，操作系统必须处理可能有敌意的用户——想要干扰系统的用户或者做不允许做的事情（例如偷窃另一个用户的文件）的用户
  - 第四，尽管事实上并非所有的用户都相信其他用户，但是许多用户确实希望与经过选择的其他用户共享他们的信息和资源
  - 第五，操作系统已经问世很长时间了。
  - 第六，操作系统设计人员对于他们的系统将怎样被人使用实际上并没有确切的概念，所以他们需要提供相当程度的通用性。UNIX
  - 第七，现代操作系统一般被设计成可移植的，这意味着它们必须运行在多个硬件平台上。
  - 第八，也是最后一个问题，是经常需要与某个从前的操作系统保持向后兼容
- 最好的起点是考虑操作系统提供的接口。操作系统提供了一组抽象，主要是数据类型（例如文件）以及其上的操作（例如read）。它们合起来形成了对用户的接口。

##13.2 接口设计

- 除了主要的系统调用接口，大多数操作系统还具有另外的接口。

###13.2.1 指导原则

- 简而言之，原则就是简单、完备和能够有效地实现。
  - 原则 1：简单一个简单的接口更加易于理解并且更加易于以无差错的方式实现。
  - 原则 2：完备当然，接口必须能够做用户需要做的一切事情，也就是说，它必须是完备的。
    - 换言之，操作系统应该不多不少准确地做它需要做的事情
    - Fernando Corbató 在他的图灵奖演说中，将简单和完备的概念结合起来并且指出：
    - 首先，重要的是强调简单和精练的价值，因为复杂容易导致增加困难并且产生错误，正如我们已经看到的那样。我对精练的定义是以机制的最少化和清晰度的最大化实现指定的功能。此处重要的思想是机制的最少化（ minimum of mechanism）。
    - 让读者简略地看一看我亲身经历的两个例子：MINIX（ Tanenbaum 和Woodhull， 2006）和Amoeba（ Tanenbaum 等人，1990）。实际上， MINIX 具有三个系统调用： send、 receive和 sendrec。
    - Amoeba 甚至更加简单。它仅有一个系统调用：执行远程过程
    - 该调用发送一条消息并且等待一个应答

  - 原则 3：效率第三个指导方针是实现的效率。
- 如果一个功能特性或者系统调用不能够有效地实现，或许就不值得包含它。
  - ​

### 13.2.2 范型

- 一旦确定了目标，就可以开始设计了。
  - 一个良好的起点是考虑客户将怎样审视该系统。
    - 最为重要的问题之一是如何将系统的所有功能特性良好地结合在一起，并且展现出经常所说的体系结构一致性
- 重要的是区分两种类型的操作系统“客户”。
  - 一方面，是用户，他们与应用程序打交道；
  - 另一方面，是程序员，他们编写应用程序。
  - 前者主要涉及GUI，后者主要涉及系统调用接口。
- 首先设计系统调用接口是自底向上的设计。
  - 此时的问题是程序员通常需要哪些种类的功能特性。
  - X 是在 UNIX 问世很久以后才开发的，但是并不要求对操作系统做很多修改就可以使它工作。
  - 这一经历验证了这样的事实： UNIX 是十分完备的。
    - 用户界面范型对于 GUI 级的接口和系统调用接口而言，最重要的方面是有一个良好的范型（有时称为隐喻），以提供观察接口的方法。台式

标注 (黄色) - 13.2 接口设计 >  位置 17618

型。重要的不是选择这么多的范型，而是存在一个单一的统领一切的范型统一整个用户界面。不管选择什么范型，重要的是所有应用程序都要使用它。因此，系统设计者需要提供库和工具包给应用程序开发人员，使他们能够访问产生一致的外观与感觉的过程。

标注 (黄色) - 13.2 接口设计 >  位置 17621

\2. 执行范型体系结构一致性不但在用户层面是重要的，在系统调用接口层面也同样重要

标注 (黄色) - 13.2 接口设计 >  位置 17623

两种执行范型被广泛接受：算法范型和事件驱动范型。

标注 (蓝色) - 13.2 接口设计 >  位置 17624

算法

标注 (蓝色) - 13.2 接口设计 >  位置 17624

型（ algorithmic paradigm）基于这样的思想：启动一个程序是为了执行某个功能，而该功能是事先知道的或者是从其参数获知的。

标注 (蓝色) - 13.2 接口设计 >  位置 17626

图 13-1a 中概括了这一方法。

标注 (黄色) - 13.2 接口设计 >  位置 17628

另一种执行范型是图 13-1b所示的事件驱动范型（event-driven paradigm）。在这里程序执行某种初始化（例如通过显示某个屏幕），然后等待操作系统告诉它第一个事件

标注 (黄色) - 13.2 接口设计 >  位置 17630

这些做事情的每一种方法造就了其特有的程序设计风格。在算法范型中，算法位居中心而操作系统被看作是服务提供者。在事件驱动范型中，操作系统同样提供服务，但是这一角色与作为用户行为的协调者和被进程处理的事件的生产者相比就没那么重要了。 3. 数据范型

标注 (黄色) - 13.2 接口设计 >  位置 17633

执行范型并不是操作系统导出的惟一范型，同等重要的范型是数据范型。这里关键的问题是系统结构和设备如何展现给程序员。

标注 (黄色) - 13.2 接口设计 >  位置 17637

使用作业控制卡片可以这样来实现映射： MOUNT( TAPE08, REEL781) RUN( INPUT, MYDATA, OUTPUT, PUNCH, TAPE08) 第一张卡片指示操作员去从磁带架上取得磁带卷 781，并且将其安装在磁带驱动器 8 上。第二张卡片指示操作系统运行刚刚编译的 FORTRAN 程序，映射 INPUT（意指卡片阅读机）到逻辑磁带 1，映射磁盘文件 MYDATA 到逻辑磁带 2，映射打印机（称为 OUTPUT）到逻辑磁带 3，映射卡片穿孔机（称为 PUNCH）到逻辑磁带 4，并且映射物理磁带驱动器 8 到逻辑磁带 5。 FORTRAN 具有读写逻辑磁带的语法。 

标注 (蓝色) - 13.2 接口设计 >  位置 17643

磁带概念只是集成卡片阅读机、打印机、穿孔机、磁盘文件以及磁带的一个范型。

标注 (蓝色) - 13.2 接口设计 >  位置 17645

后来， UNIX 问世了，它采用“所有一切都是文件”的模型进一步发展了这一思想

标注 (黄色) - 13.2 接口设计 >  位置 17647

C 语句fd1 = open(" file1", O_RDWR); fd2 = open("/ dev/ tty", O_RDWR); 打开一个真正的磁盘文件和用户终端。

标注 (黄色) - 13.2 接口设计 >  位置 17650

UNIX 不但统一了文件和 I/ O设备，它还允许像访问文件一样通过管道访问其他进程。

标注 (黄色) - 13.2 接口设计 >  位置 17651

在支持/ proc 文件系统的 UNIX 版本中， C 语句 fd3 = open("/ proc/ 501", O_RDWR); 允许进程（尝试）访问进程501的内存，

标注 (黄色) - 13.2 接口设计 >  位置 17654

Windows Vista 更进一步，它试图使所有一切看起来像是一个对象

标注 (黄色) - 13.2 接口设计 >  位置 17656

统一的范型还出现在其他上下文中，其中在这里值得一提的是 Web。 Web 背后的范型是充满了文档的超空间，每一个文档具有一个 URL。

标注 (黄色) - 13.2 接口设计 >  位置 17660

至此我们已经看到了 4 种事例，即所有一切都是磁带、文件、对象或者文档。

标注 (黄色) - 13.2 接口设计 >  位置 17665

13.2.3 系统调用接口

标注 (黄色) - 13.2 接口设计 >  位置 17666

简单）。统一的数据范型在此处可以扮演重要的角色

标注 (黄色) - 13.2 接口设计 >  位置 17669

在某些情况下，系统调用可能看起来需要若干变体，但是通常更好的实现是具有处理一般情况的一个系统调用，而由不同的库过程向程序员隐藏这一事实

标注 (黄色) - 13.2 接口设计 >  位置 17676

当然，试图拥有一个调用来处理每一种可能的情况很可能难以控制。

标注 (黄色) - 13.2 接口设计 >  位置 17684

在 Tanenbaum 软件第一定律中做出总结：

标注 (蓝色) - 13.2 接口设计 >  位置 17685

添加更多的代码就是添加更多的程序错误。

标注 (黄色) - 13.2 接口设计 >  位置 17688

一个重要的考虑因素是Lampson（1984）的口号：不要隐藏能力。

标注 (黄色) - 13.2 接口设计 >  位置 17694

另一个设计问题是面向连接的调用与无连接的调用。

标注 (蓝色) - 13.2 接口设计 >  位置 17696

某些远程文件访问协议也是面向连接的。

标注 (蓝色) - 13.2 接口设计 >  位置 17697

另一方面，某些远程文件访问协议是无连接的，例如 Web 协议（ HTTP）。

标注 (蓝色) - 13.2 接口设计 >  位置 17699

任何面向连接的机制与无连接的机制之间的权衡在于建立连接的机制（例如打开文件）要求的额外开销，以及在后续调用（可能很多）中避免进行连接所带来的好处

标注 (黄色) - 13.2 接口设计 >  位置 17702

与系统调用接口有关的另一个问题是接口的可见性。

标注 (黄色) - 13.3 实现 >  位置 17711

在下面 8 个小节，我们将分析涉及实现策略的某些一般的概念性问题

标注 (黄色) - 13.3 实现 >  位置 17713

13.3.1 系统结构

标注 (黄色) - 13.3 实现 >  位置 17713

实现必须要做出的第一个决策可能是系统结构应该是什么

标注 (黄色) - 13.3 实现 >  位置 17716

\1. 分层系统多年以来很好地建立起来的一个合理的方案是分层系统

标注 (黄色) - 13.3 实现 >  位置 17718

对于一个新系统，选择走这一路线的设计人员应该首先非常仔细地选择各个层次，并且定义每个层次的功能

标注 (黄色) - 13.3 实现 >  位置 17721

一种可能性是让第 3 层管理线程，包括调度和线程间同步，如图 13 -2 所示。此处的思想是从第 4 层开始，我们拥有适当的线程，这些线程可以被正常地调度，并且使用标准的机制（例如互斥量）进行同步。

标注 (黄色) - 13.3 实现 >  位置 17725

在第 4 层，我们可能会找到设备驱动程序，每个设备驱动程序作为一个单独的线程而运行，具有自己的状态、程序计数器、寄存器等，可能（但是不必要）处于内核地址空间内部。

标注 (黄色) - 13.3 实现 >  位置 17730

在第 4 层之上，我们预计会找到虚拟内存、一个或多个文件系统以及系统调用接口。

标注 (黄色) - 13.3 实现 >  位置 17733

Windows Vista 就是这样工作的。 2. 外内核

标注 (黄色) - 13.3 实现 >  位置 17735

如果某件事情必须由用户程序本身去完成，在一个较低的层次做同样的事情就是浪费。

标注 (黄色) - 13.3 实现 >  位置 17740

端到端的论据宣称使用一个可靠的网络协议是不必要的，因为端点（接收进程）拥有足够的信息以验证文件本身的正确性。 

标注 (黄色) - 13.3 实现 >  位置 17742

端到端的论据可以扩展到几乎所有操作系统。它主张不要让操作系统做用户程序本身可以做的任何事情

标注 (黄色) - 13.3 实现 >  位置 17747

Exokernel 是一个根据端到端的论据建立的操作系统（ Engler 等人， 1995）。 3. 基于微内核的客户-服务器系统

标注 (黄色) - 13.3 实现 >  位置 17749

微内核的出现，它让操作系统的大部分作为用户级的服务器进程而运行，如图 13-3 所示。

标注 (黄色) - 13.3 实现 >  位置 17753

当设备驱动程序运行在内核态时，可以直接访问硬件设备寄存器，否则需要某种机制以提供这样的访问

标注 (黄色) - 13.3 实现 >  位置 17756

即使没有硬件帮助可用，仍然可以设法使这一思想可行。此时需要的是一个新的系统调用，该系统调用仅对设备驱动程序进程可用，它提供一个（端口，取值）对列表

标注 (黄色) - 13.3 实现 >  位置 17759

这一方法使设备驱动程序避免了检查（并且破坏）内核数据结构，这（在很大程度上）是一件好事情。

标注 (黄色) - 13.3 实现 >  位置 17761

这一方法的主要问题，并且一般而言是针对微内核的主要问题，是额外的上下文切换导致性能受到影响

标注 (黄色) - 13.3 实现 >  位置 17767

\4. 可扩展的系统对于上面讨论的客户 -服务器系统，思想是让尽可能多的东西脱离内核。相反的方法是将更多的模块放到内核中，但是以一种“受保护的”方式。

标注 (黄色) - 13.3 实现 >  位置 17771

通过以一个只是包含保护机制的最小系统为开端，然后每次将受保护的模块添加到内核中，直到达到期望的功能，对于手边的应用而言一个最小的系统就建立起来了。

标注 (黄色) - 13.3 实现 >  位置 17774

\5. 内核线程

标注 (黄色) - 13.3 实现 >  位置 17777

实际上，内核本身可以完全由这样的线程构成，所以当一个用户发出系统调用时，用户的线程并不是在内核模式中运行，而是阻塞并且将控制传给一个内核线程，该内核线程接管控制以完成工作。除了在后台运行的内核线程以外，大多数操作系统还要启动许多守护进程。 

标注 (黄色) - 13.3 实现 >  位置 17783

13.3.2 机制与策略另一个有助于体系结构一致性的原理是机制与策略的分离，该原理同时还有助于使系统保持小型和良好的结构。

标注 (黄色) - 13.3 实现 >  位置 17787

为了使策略与机制之间的划分更加清晰，让我们考虑两个现实世界的例子。第一个例子，考虑一家大型公司，该公司拥有负责向员工发放薪水的工资部门

标注 (黄色) - 13.3 实现 >  位置 17791

第二个例子，考虑一家饭店。

标注 (黄色) - 13.3 实现 >  位置 17793

现在让我们考虑某些操作系统的例子。首先考虑线程调度。内核可能拥有一个优先级调度

标注 (黄色) - 13.3 实现 >  位置 17794

具有 k 个优先级。机制是一个数组，以优先级为索引，如图10-11或图 11-19 所示。

标注 (黄色) - 13.3 实现 >  位置 17796

程。策略是设定优先级。

标注 (黄色) - 13.3 实现 >  位置 17799

第二个例子是分页。机制涉及到 MMU 管理，维护占用页面与空闲页面的列表，以及用来将页面移入磁盘或者移出磁盘的代码。策略是当页面故障发生时决定做什么

标注 (黄色) - 13.3 实现 >  位置 17801

第三个例子是允许将模块装载到内核之中。机制关心的是它们如何被插入、如何被链接、它们可以发出什么调用，以及可以对它们发出什么调用。策略是确定允许谁将模块装载到内核之中以及装载哪些模块。

标注 (黄色) - 13.3 实现 >  位置 17807

13.3.3 正交性良好的系统设计在于单独的概念可以独立地组合

标注 (黄色) - 13.3 实现 >  位置 17811

独立地组合单独的概念的能力称为正交性（ orthogonality），它是简单性和完整性原理的直接结果。正交性概念还以各种各样的伪装出现在操作系统中， Linux的 clone 系统调用就是一个例子，它创建一个新线程。

标注 (黄色) - 13.3 实现 >  位置 17816

正交性的另一个应用是Windows Vista 中进程概念与线程概念的分离

标注 (黄色) - 13.3 实现 >  位置 17819

正交性的最后一个例子来自UNIX。在 UNIX 中，进程的创建分两步完成： fork 和 exec。创建新的地址空间与用新的内存映像装载该地址空间是分开的，这就为在两者之间做一些事情提供了可能（

标注 (黄色) - 13.3 实现 >  位置 17822

的。Linux的 clone 加 exec 序列是更加正交的，因为存在更细粒度的构造块可以利用

标注 (黄色) - 13.3 实现 >  位置 17826

13.3.4 命名操作系统使用的最长久的数据结构具有某种类型的名字或标识符，通过名字或标识符就可以引用这些数据结构。

标注 (黄色) - 13.3 实现 >  位置 17828

为人们的使用而设计的名字是 ASCII 或 Unicode 形式的字符串，并且通常是层次化的。 

标注 (黄色) - 13.3 实现 >  位置 17835

命名经常在外部和内部两个层次上实现。例如，

标注 (黄色) - 13.3 实现 >  位置 17838

目录的任务是在外部名字和内部名字之间提供映射，如图13-4所示。

标注 (黄色) - 13.3 实现 >  位置 17840

在许多情况下（例如上面给出的文件名的例子），内部名字是一个无符号整数，用作进入一个内部表格的索引。

标注 (黄色) - 13.3 实现 >  位置 17843

操作系统经常支持多个名字空间，既在内部又在外部。

标注 (黄色) - 13.3 实现 >  位置 17851

13.3.5 绑定的时机

标注 (黄色) - 13.3 实现 >  位置 17852

何时将名字与对象绑定可能是很重要的。一般而言，早期绑定（ early binding）是简单的，但是不灵活，而晚期绑定（ late binding）则比较复杂，但是通常更加灵活。

标注 (黄色) - 13.3 实现 >  位置 17854

为了阐明绑定时机的概念，让我们看一看某些现实世界的例子。早期绑定的一个例子是某些高等学校允许父母在婴儿出生时登记入学，并且预付当前的学费。

标注 (黄色) - 13.3 实现 >  位置 17856

在制造业中，预先定购零部件并且维持零部件的库存量是早期绑定。

标注 (黄色) - 13.3 实现 >  位置 17858

程序设计语言对于变量通常支持多种绑定时机。

标注 (黄色) - 13.3 实现 >  位置 17861

操作系统对大多数数据结构通常使用早期绑定，但是偶尔为

标注 (黄色) - 13.3 实现 >  位置 17861

灵活性也使用晚期绑定。

标注 (黄色) - 13.3 实现 >  位置 17865

晚期绑定的另一个例子是GUI中窗口的放置。

标注 (黄色) - 13.3 实现 >  位置 17870

13.3.6 静态与动态结构操作系统设计人员经常被迫在静态与动态数据结构之间进行选择。静态结构总是简单易懂，更加容易编程并且用起来更快；动态结构则更加灵活。一个显而易见的例子是进程表。

标注 (黄色) - 13.3 实现 >  位置 17875

一个替代的策略是将进程表建立为一个小型表的链表，最初只有一个表。如果该表被填满，可以从全局存储池中分配另一个表并且将其链接到前一个表。

标注 (黄色) - 13.3 实现 >  位置 17877

另一方面，搜索表格的代码

标注 (黄色) - 13.3 实现 >  位置 17877

变得更加复杂

标注 (黄色) - 13.3 实现 >  位置 17880

当存在大量的内存或者当表的利用可以猜测得相当准确时，静态表是最佳的。

标注 (黄色) - 13.3 实现 >  位置 17882

还有另一种选择是使用一个固定大小的表，但是如果该表填满了，就分配一个新的固定大小的表，比方说大小是原来的两倍。然后将当前的表项复制到新表中并且把旧表返回空闲存储池。

标注 (黄色) - 13.3 实现 >  位置 17885

对于内核栈也存在类似的问题。

标注 (黄色) - 13.3 实现 >  位置 17888

另一个静态 -动态权衡是进程调度

标注 (黄色) - 13.3 实现 >  位置 17891

还有一个静态-动态问题是内核结构。

标注 (黄色) - 13.3 实现 >  位置 17898

13.3.7 自顶向下与自底向上的实现虽然最好是自顶向下地设计系统，但是在理论上系统可以自顶向下或者自底向上地实现。

标注 (黄色) - 13.3 实现 >  位置 17901

许多开发人员发现实际上自底向上地构建系统更加可行。这一方法需要首先编写隐藏底层硬件的代码，特别是图 11-6 中的 HAL。中断

标注 (黄色) - 13.3 实现 >  位置 17903

然后，可以使用一个简单的调度器（例如轮转调度）来解决多道程序设计问题。

标注 (黄色) - 13.3 实现 >  位置 17908

语言。当较低的层次完成时，可以彻底地测试它们。这样，系统自底向上推进，很像是建筑商建造高层办公楼的方式。如果有一个大型团队可用，那么替代的方法是首先做出整个系统的详细设计，然后分配不同的小组编写不同的模块。

标注 (黄色) - 13.3 实现 >  位置 17916

13.3.8 实用技术

标注 (黄色) - 13.3 实现 >  位置 17917

，现在将针对系统实现考察一些有用的具体技术。这

标注 (黄色) - 13.3 实现 >  位置 17918

\1. 隐藏硬件

标注 (黄色) - 13.3 实现 >  位置 17920

某些非常低层的细节可以通过如图 13- 2 所示的 HAL类型的层次得到隐藏

标注 (黄色) - 13.3 实现 >  位置 17921

值得尽早关注的一件事情是如何处理中断。

标注 (蓝色) - 13.3 实现 >  位置 17922

一种方法是立刻将中断转变成别的东西

标注 (蓝色) - 13.3 实现 >  位置 17923

第二种方法是将每个中断转换成在一个互斥量上的 unlock操作，该互斥量对应正在等待的驱动程序。

标注 (蓝色) - 13.3 实现 >  位置 17925

第三种方法是将一个中断转换成发送给某个线程的消息。

标注 (黄色) - 13.3 实现 >  位置 17929

大多数操作系统被设计成运行在多个硬件平台上。这些平台可以按照 CPU 芯片、 MMU、字长、 RAM 大小以及不能容易地由HAL或等价物屏蔽的其他特性

标注 (黄色) - 13.3 实现 >  位置 17930

区分。

标注 (黄色) - 13.3 实现 >  位置 17932

某些硬件的差异，例如 RAM大小，可以通过让操作系统在引导的时候确定其取值并且保存在一个变量中来处理。

标注 (黄色) - 13.3 实现 >  位置 17935

然而，其他的差异，例如不同的 CPU 芯片，就不能让单一的二进制代码在运行的时候确定它正在哪一个 CPU 上运行。解决一个源代码多个目标机的问题的一种方法是使用条件编译。

标注 (黄色) - 13.3 实现 >  位置 17938

Pentium 和 UltraSPARC 芯片上，这就需要不同的初始化代码。可以像图 13-6a 中那样编写init过程的代码

标注 (黄色) - 13.3 实现 >  位置 17941

第二个例子，假设需要一个数据类型 Register，它在Pentium上是 32 位，在UltraSPARC上是 64 位。这可以由图 13-6b 中的条件代码来处理（假设编译器产生 32 位的 int 和64位的 long）

标注 (黄色) - 13.3 实现 >  位置 17944

当然，头文件 config.h 必须正确地定义。 

标注 (黄色) - 13.3 实现 >  位置 17953

那些依赖 CPU 的细节应该基于 CPU 宏而条件编译，而那些依赖字长的细节则应该使用 WORD_LENGTH 宏

标注 (黄色) - 13.3 实现 >  位置 17954

\2. 间接人们不时地说在计算机科学中没有什么问题不能通过另一个层次间接得到解决。 

标注 (黄色) - 13.3 实现 >  位置 17958

间接为操作系统使用键编号作为索引检索一张表格以获取 ASCII 字符提供了可能，这使得处理世界上不同国家使用的许多键盘十分容易。获得按下与释放两个信息使得将任何键作为换档键成为可能， 

标注 (黄色) - 13.3 实现 >  位置 17960

间接还被用在输出上。

标注 (黄色) - 13.3 实现 >  位置 17961

使得将字符与字体相分离成为可能。间接的另一个例子是 UNIX中主设备号的使用。

标注 (蓝色) - 13.3 实现 >  位置 17964

这一间接使得重新配置系统十分容易，因为程序涉及的是符号化的设备名，而不是实际的驱动程序名。

标注 (黄色) - 13.3 实现 >  位置 17965

还有另一个间接的例子出现

标注 (黄色) - 13.3 实现 >  位置 17966

消息传递的系统中，该系统命名一个邮箱而不是一个进程作为消息的目的地。

标注 (黄色) - 13.3 实现 >  位置 17968

在某种意义上，使用诸如 #define PROC_TABLE_SIZE 256 的宏也是间接的一种形式，因为程序员无须知道表格实际有多大就可以编写代码

标注 (黄色) - 13.3 实现 >  位置 17971

\3. 可重用性在略微不同的上下文中重用相同的代码通常是可行的。这样做是一个很好的想法，因为它减少了二进制代码的大小并且意味着代码只需要调试一次。

标注 (黄色) - 13.3 实现 >  位置 17974

相同的过程还可以用于管理内存块、文件系统块高速缓存中的块，以及i 节点。事实上，它们可以用来分配与回收能够线性编号的任意资源。4. 重入重入指的是代码同时被执行两次或多次的能力。在多处理器系统上，总是存在着这样的危险：当一个CPU 执行某个过程时，另一个CPU 在第一个完成之前也开始执行它。

标注 (黄色) - 13.3 实现 >  位置 17979

然而，在单处理器上，问题也是存在的。

标注 (黄色) - 13.3 实现 >  位置 17982

可能发生这种情况的一个显而易见的例子是 P 是调度器。

标注 (黄色) - 13.3 实现 >  位置 17984

即使在单处理器上，最好是操作系统的大部分为可重入的，关键的数据结构用互斥量来保护，并且在中断不被允许的时刻禁用中断。 5. 蛮力法使用蛮力法解决问题多年以来获得了较差的名声，但是依据简单性它经常是行之有效的方法

标注 (黄色) - 13.3 实现 >  位置 17990

当然，对处于关键路径上的功能，例如上下文切换，使它们加快速度的一切措施都应该尽力去做，即使可能要用汇编语言编写它们

标注 (黄色) - 13.3 实现 >  位置 17994

\6. 首先检查错误由于各种各样的原因，许多系统调用可能潜在地会失败

标注 (蓝色) - 13.3 实现 >  位置 17996

。操作系统在执行调用之前必须无微不至地检查每一个可能的错误。

标注 (黄色) - 13.3 实现 >  位置 17997

许多系统调用还需要获得资源，

标注 (蓝色) - 13.3 实现 >  位置 17997

一般性的建议是在获得资源之前，首先进行检查以了解系统调用能否实际执行，这样可以省去许多麻烦。

标注 (黄色) - 13.3 实现 >  位置 18000

如果调用通过了所有严格的测试，那么就可以肯定它将会取得成功。

标注 (黄色) - 13.3 实现 >  位置 18001

如果将获得资源的测试分散开，那么就意味着如果在这一过程中某个测试失败，到这一时刻已经获得的所有资源都必须归还。 

标注 (黄色) - 13.3 实现 >  位置 18005

许多系统以内存泄漏的形式遭受了这一问题的侵害。

标注 (黄色) - 13.3 实现 >  位置 18006

Engler 等人（2000）推荐了一种有趣的方法在编译时检查某些这样的错误

13.4.1　操作系统为什么运行缓慢
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18018-18018的标注 | 添加于 2019年5月7日星期二 下午4:56:46

许多操作系统运行缓慢在很大程度上是操作系统自身造成的。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18020-18022的标注 | 添加于 2019年5月7日星期二 下午4:57:18

插即用使得安装一个新的硬件设备相当容易，但是付出的代价是在每次启动时，操作系统都必须要检查所有的硬件以了解是否存在新的设备。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18022-18023的标注 | 添加于 2019年5月7日星期二 下午4:57:23

一种替代的（并且依作者看来是更好的）方法是完全抛弃即插即用
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18022-18023的标注 | 添加于 2019年5月7日星期二 下午4:57:28

一种替代的（并且依作者看来是更好的）方法是完全抛弃即插即用，并且在屏幕上包含一个图标标明“安装新硬件
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18027-18028的标注 | 添加于 2019年5月7日星期二 下午4:58:25

或许系统设计人员为改进性能可以做的最大的一件事情，是对于添加新的
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18027-18028的标注 | 添加于 2019年5月7日星期二 下午4:59:32

或许系统设计人员为改进性能可以做的最大的一件事情，是对于添加新的功能特性更加具有选择性。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18030-18030的标注 | 添加于 2019年5月7日星期二 下午5:00:10

经验表明这种观点
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18030-18030的标注 | 添加于 2019年5月7日星期二 下午5:00:15

经验表明这种观点有些过于乐观。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18031-18031的标注 | 添加于 2019年5月7日星期二 下午5:04:07

另一个重要因素是产品的市场销售。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18037-18037的标注 | 添加于 2019年5月7日星期二 下午5:04:11

13.4.2　什么应该优化
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18037-18037的标注 | 添加于 2019年5月7日星期二 下午5:04:19

作为一般的规则，系统的第一版应该尽可能简单明了
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18037-18038的标注 | 添加于 2019年5月7日星期二 下午5:04:28

作为一般的规则，系统的第一版应该尽可能简单明了。惟一的优化应该是那些显而易见要成为不可避免的问题的事情
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18037-18038的标注 | 添加于 2019年5月7日星期二 下午5:04:37

作为一般的规则，系统的第一版应该尽可能简单明了。惟一的优化应该是那些显而易见要成为不可避免的问题的事情。为文件系统提供块高速缓存就是这样的一个例子。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18040-18040的标注 | 添加于 2019年5月7日星期二 下午5:05:31

这里有一个关于优化不但不好反而更坏的真实故事。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18045-18046的标注 | 添加于 2019年5月7日星期二 下午5:06:53

对于性能优化，一条相当适用的口号是： 足够好就够好了。 通过这条口号我们要表达的意思是：性能一旦达到一个合理的水平，榨
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18045-18047的标注 | 添加于 2019年5月7日星期二 下午5:07:29

对于性能优化，一条相当适用的口号是： 足够好就够好了。 通过这条口号我们要表达的意思是：性能一旦达到一个合理的水平，榨出最后一点百分比的努力和复杂性或许并不值得。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18040-18041的标注 | 添加于 2019年5月7日星期二 下午5:08:23

这里有一个关于优化不但不好反而更坏的真实故事。作者的一名学生编写了MINIX的mkfs程序。该程序在一个新格式化的磁盘上布下一个新的文件系统。这名学生花了大约6个月
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18040-18042的标注 | 添加于 2019年5月7日星期二 下午5:08:28

这里有一个关于优化不但不好反而更坏的真实故事。作者的一名学生编写了MINIX的mkfs程序。该程序在一个新格式化的磁盘上布下一个新的文件系统。这名学生花了大约6个月的时间对其进行优化，包括放入磁盘高速缓存。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18052-18052的标注 | 添加于 2019年5月7日星期二 下午5:09:09

13.4.3　空间-时间的权衡
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18053-18053的标注 | 添加于 2019年5月7日星期二 下午5:09:13

改进性能的一种一般性的方法是权衡时间与空间。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18056-18056的标注 | 添加于 2019年5月7日星期二 下午5:09:33

一种常用而有益的技术是用宏来代替小的过程。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18056-18057的标注 | 添加于 2019年5月7日星期二 下午5:09:57

一种常用而有益的技术是用宏来代替小的过程。使用宏消除了通常与过程调用相关联的开销。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18058-18059的标注 | 添加于 2019年5月7日星期二 下午5:10:17

数。图13-7a中给出了简单明了的过程。它对一个字节中的各个位循环，每次计数它们一次。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18056-18057的标注 | 添加于 2019年5月7日星期二 下午5:12:09

一种常用而有益的技术是用宏来代替小的过程。使用宏消除了通常与过程调用相关联的开销。如果调用出现在一个循环的内部，这种获益尤其显著。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18058-18059的标注 | 添加于 2019年5月7日星期二 下午5:12:14

数。图13-7a中给出了简单明了的过程
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18061-18062的标注 | 添加于 2019年5月7日星期二 下午5:12:30

该过程有两个低效的根源。首先，它必须被调用
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18062-18062的标注 | 添加于 2019年5月7日星期二 下午5:12:35

第二，它包含一个循环，
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18063-18063的标注 | 添加于 2019年5月7日星期二 下午5:12:40

一种完全不同的方法是使用图13-7b中的宏。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18063-18064的标注 | 添加于 2019年5月7日星期二 下午5:13:18

表达式，它通过对参数连续地移位，屏蔽除低位以外的其他位，并且将8个项相加，这样来计算位的和。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18063-18064的标注 | 添加于 2019年5月7日星期二 下午5:13:22

一种完全不同的方法是使用图13-7b中的宏。这个宏是一个内联表达式，它通过对参数连续地移位，屏蔽除低位以外的其他位，并且将8个项相加，这样来计算位的和。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18069-18070的标注 | 添加于 2019年5月7日星期二 下午5:14:01

。我们可以声明一个256项的表bits，每一项（在编译时）初始化成对应于该字节值的位计数。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18070-18071的标注 | 添加于 2019年5月7日星期二 下午5:14:08

图13-7c中给出了做这一工作的宏。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18073-18073的标注 | 添加于 2019年5月7日星期二 下午5:14:35

在表中查找答案可以用在其他方面。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18069-18070的标注 | 添加于 2019年5月7日星期二 下午5:14:39

。我们可以声明一个256项的表bits，每一项（在编译时）初始化成对应于该字节值的位计数。采用这一方法在运行时根本就不需要计算
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18069-18071的标注 | 添加于 2019年5月7日星期二 下午5:14:45

。我们可以声明一个256项的表bits，每一项（在编译时）初始化成对应于该字节值的位计数。采用这一方法在运行时根本就不需要计算，只要一个变址操作就可以了。图13-7c中给出了做这一工作的宏。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18074-18075的标注 | 添加于 2019年5月7日星期二 下午5:18:21

压缩技术GIF使用表查找来编码24位RGB图像
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18077-18077的标注 | 添加于 2019年5月7日星期二 下午5:18:48

13-8中针对一幅图像的一个4×4区域说明了这一思想。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18075-18076的标注 | 添加于 2019年5月7日星期二 下午5:18:58

对于每幅要压缩的图像，构造一个256项的调色板，每一项包含一个24位的RGB值。压缩过的图像于是包含
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18075-18077的标注 | 添加于 2019年5月7日星期二 下午5:19:01

对于每幅要压缩的图像，构造一个256项的调色板，每一项包含一个24位的RGB值。压缩过的图像于是包含每个像素的8位索引，而不是24位颜色值，增益因子为3。图13-8中针对一幅图像的一个4×4区域说明了这一思想。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18078-18079的标注 | 添加于 2019年5月7日星期二 下午5:19:43

索引。调色板作为图像文件的一部分存放，如图13-8c所示。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18075-18079的标注 | 添加于 2019年5月7日星期二 下午5:19:48

对于每幅要压缩的图像，构造一个256项的调色板，每一项包含一个24位的RGB值。压缩过的图像于是包含每个像素的8位索引，而不是24位颜色值，增益因子为3。图13-8中针对一幅图像的一个4×4区域说明了这一思想。原始未压缩的图像如图13-8a所示，该图中每个取值是一个24位的值，每8位给出红、绿和蓝的强度。GIF图像如图13-8b所示，该图中每个取值是一个进入调色板的8位索引。调色板作为图像文件的一部分存放，如图13-8c所示。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18081-18082的标注 | 添加于 2019年5月7日星期二 下午5:20:08

存在减少图像大小的另一种方法，并且这种方法说明了一种不同的权衡。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18081-18083的标注 | 添加于 2019年5月7日星期二 下午5:20:22

存在减少图像大小的另一种方法，并且这种方法说明了一种不同的权衡。PostScript是一种程序设计语言，可以用来描述图像。（
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18084-18086的标注 | 添加于 2019年5月7日星期二 下午5:21:07

例如，如果在一幅图像中存在一个像素矩形块具有相同的颜色，用于该图像的PostScript程序将携带指令，用来将一个矩形放置在一定的位置并且用一定的颜色填充该矩形。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18088-18088的标注 | 添加于 2019年5月7日星期二 下午5:21:22

其他的权衡经常牵涉数据结构。双向
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18088-18089的标注 | 添加于 2019年5月7日星期二 下午5:21:33

其他的权衡经常牵涉数据结构。双向链表比单向链表占据更多的内存，但是经常使得访问表项速度更快。散列表甚至更浪费空间，但是要更快。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18093-18093的标注 | 添加于 2019年5月7日星期二 下午5:21:42

13.4.4　高速缓存
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18093-18094的标注 | 添加于 2019年5月7日星期二 下午5:21:44

用于改进性能的一种众所周知的技术是高速缓存。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18093-18094的标注 | 添加于 2019年5月7日星期二 下午5:22:00

用于改进性能的一种众所周知的技术是高速缓存。在任何相同的结果可能需要多次的情况下，高速缓存都是适用的。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18093-18094的标注 | 添加于 2019年5月7日星期二 下午5:22:03

用于改进性能的一种众所周知的技术是高速缓存。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18094-18095的标注 | 添加于 2019年5月7日星期二 下午5:22:09

一般的方法是首先做完整的工作，然后将结果保存在高速缓存中。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18096-18097的标注 | 添加于 2019年5月7日星期二 下午5:22:20

我们已经看到高速缓存在文件系统内部的运用，在高速缓存中保存一定数目最近用过的磁盘块，这样在每次命中时就可以省略磁盘读操作。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18103-18104的标注 | 添加于 2019年5月7日星期二 下午5:23:20

某些系统通过对（路径，i节点）的组合进行高速缓存来优化路径名的解析。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18096-18098的标注 | 添加于 2019年5月7日星期二 下午5:23:32

我们已经看到高速缓存在文件系统内部的运用，在高速缓存中保存一定数目最近用过的磁盘块，这样在每次命中时就可以省略磁盘读操作。然而，高速缓存还可以用于许多其他目的。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18103-18105的标注 | 添加于 2019年5月7日星期二 下午5:23:50

某些系统通过对（路径，i节点）的组合进行高速缓存来优化路径名的解析。对于图4-35的例子，在解析/usr/ast/mbox之后，高速缓存中肯定会保存图13-9的前三项
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18107-18107的标注 | 添加于 2019年5月7日星期二 下午5:24:00

当必须查找一个路径时，名字解析器首先查阅高速缓存并搜索它以找到
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18107-18107的标注 | 添加于 2019年5月7日星期二 下午5:24:05

当必须查找一个路径时，名字解析器首先查阅高速缓存并搜索它以找到高速缓存中存在的最长的子字符串。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18109-18109的标注 | 添加于 2019年5月7日星期二 下午5:24:10

对路径进行高速缓存存在的一个问题是，文件名与i节点号之间的映射
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18110-18110的标注 | 添加于 2019年5月7日星期二 下午5:24:18

的。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18110-18110的标注 | 添加于 2019年5月7日星期二 下午5:24:20

的。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18110-18111的标注 | 添加于 2019年5月7日星期二 下午5:24:23

的。假设文件/usr/ast/mbox从系统中被删除，并且其i节点重用于不同用户所拥有的不同的文件。随后，文件/usr/ast/mbox再次被创建，并且这一次它得到i节点106。如果
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18109-18110的标注 | 添加于 2019年5月7日星期二 下午5:24:34

对路径进行高速缓存存在的一个问题是，文件名与i节点号之间的映射并不总是固定的。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18113-18114的标注 | 添加于 2019年5月7日星期二 下午5:25:43

磁盘块与路径名并不是能够高速缓存的惟一项目，i节点也可以被高速缓
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18119-18119的标注 | 添加于 2019年5月7日星期二 下午5:26:06

13.4.5　线索
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18116-18116的标注 | 添加于 2019年5月7日星期二 下午5:26:17

内存）。难于生产的任何事物几乎都能够被高速缓存。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18120-18121的标注 | 添加于 2019年5月7日星期二 下午5:26:35

某些系统中，包含线索（hint）的表是十分便利的。这些线索是关于答案的暗示，但是
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18120-18121的标注 | 添加于 2019年5月7日星期二 下午5:26:41

某些系统中，包含线索（hint）的表是十分便利的。这些线索是关于答案的暗示，但是它们并不保证是正确的。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18120-18121的标注 | 添加于 2019年5月7日星期二 下午5:26:46

某些系统中，包含线索（hint）的表是十分便利的。这些线索是关于答案的暗示，但是它们并不保证是正确的。调用者必须自行对结果进行验证。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18122-18122的标注 | 添加于 2019年5月7日星期二 下午5:27:01

众所周知的关于线索的例子是嵌在Web页上的
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18122-18122的标注 | 添加于 2019年5月7日星期二 下午5:27:06

众所周知的关于线索的例子是嵌在Web页上的URL。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18124-18124的标注 | 添加于 2019年5月7日星期二 下午5:27:11

线索还用于连接远程文件。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18128-18128的标注 | 添加于 2019年5月7日星期二 下午5:27:27

13.4.6　利用局部性
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18129-18130的标注 | 添加于 2019年5月7日星期二 下午5:27:36

进程和程序的行为并不是随机的，它们在时间上和空间上展现出相当程度的局部性，并且可以以各种方式利用该信息来改进性能。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18133-18133的标注 | 添加于 2019年5月7日星期二 下午5:28:42

局部化原理对于文件也是成立的
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18133-18133的标注 | 添加于 2019年5月7日星期二 下午5:28:50

局部化原理对于文件也是成立的。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18135-18136的标注 | 添加于 2019年5月7日星期二 下午5:30:18

局部性起作用的另一个领域是多处理器系统中的线程调度。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18134-18135的标注 | 添加于 2019年5月7日星期二 下午5:30:49

通过在磁盘上将每个目录的所有i节点和文件就近放在一起，可能会获得性能的改善。这一原理正是Berkeley快速文件系统的基础
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18136-18137的标注 | 添加于 2019年5月7日星期二 下午5:31:01

，在多处理器上一种调度线程的方法是试图在最后一次用过的CPU上运行每个线程，期望它的某些内存块依然还在内存的高速缓存中。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18140-18140的标注 | 添加于 2019年5月7日星期二 下午5:31:05

13.4.7　优化常见的情况
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18140-18141的标注 | 添加于 2019年5月7日星期二 下午5:31:11

区分最常见的情况和最坏可能的情况并且分别处理它们，这通常是一个好主意。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18142-18143的标注 | 添加于 2019年5月7日星期二 下午6:57:43

第一个例子，考虑进入一个临界区。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18141-18142的标注 | 添加于 2019年5月7日星期二 下午6:58:54

的。重要的是要使常见的情况速度快。对于最坏的情况，如果它很少发生，使其正确就足够
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18141-18142的标注 | 添加于 2019年5月7日星期二 下午6:59:06

重要的是要使常见的情况速度快。对于最坏的情况，如果它很少发生，使其正确就足够了。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18143-18145的标注 | 添加于 2019年5月7日星期二 下午6:59:28

Windows Vista提供的一个Win32 API调用EnterCriticalSection就利用了这一期望，它自动地在用户态测试一个标志（使用TSL或等价物）。如果测试成功
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18143-18145的标注 | 添加于 2019年5月7日星期二 下午6:59:32

Windows Vista提供的一个Win32 API调用EnterCriticalSection就利用了这一期望，它自动地在用户态测试一个标志（使用TSL或等价物）。如果测试成功，进程只是进入临界区并且不需要内核调
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18143-18145的标注 | 添加于 2019年5月7日星期二 下午6:59:36

Windows Vista提供的一个Win32 API调用EnterCriticalSection就利用了这一期望，它自动地在用户态测试一个标志（使用TSL或等价物）。如果测试成功，进程只是进入临界区并且不需要内核调用。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18146-18147的标注 | 添加于 2019年5月7日星期二 下午6:59:42

第二个例子，考虑设置一个警报（在UNIX中使用信号）。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18148-18149的标注 | 添加于 2019年5月7日星期二 下午7:00:50

。由于alarm调用并未指明是否已经设置了一个警报，所以系统必须假设最坏的情况，即有一个警报。然而，由于大多数时间不存在警报
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18150-18152的标注 | 添加于 2019年5月7日星期二 下午7:01:01

做这件事情的一种方法是在进程表中保留一个位，表明是否有一个警报待完成。如果这一位为0，就好办了（只是添加一个新的定时器队列项而无须检查）。如果该位为1，则必须检查定时器队列。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18148-18150的标注 | 添加于 2019年5月7日星期二 下午7:01:16

。由于alarm调用并未指明是否已经设置了一个警报，所以系统必须假设最坏的情况，即有一个警报。然而，由于大多数时间不存在警报待完成，并且由于删除一个现有的警报
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18148-18150的标注 | 添加于 2019年5月7日星期二 下午7:01:20

。由于alarm调用并未指明是否已经设置了一个警报，所以系统必须假设最坏的情况，即有一个警报。然而，由于大多数时间不存在警报待完成，并且由于删除一个现有的警报代价高昂，所以区分这两种情况是一个好主意。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18150-18152的标注 | 添加于 2019年5月7日星期二 下午7:01:32

做这件事情的一种方法是在进程表中保留一个位，表明是否有一个警报待完成。如果这一位为0，就好办了（只是添加一个新的定时器队列项而无须检查）。如果该位为1，则必须检查定时器队列。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18150-18151的标注 | 添加于 2019年5月7日星期二 下午7:01:36

做这件事情的一种方法是在进程表中保留一个位，表明是否有一个警报待完成
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18158-18158的标注 | 添加于 2019年5月7日星期二 下午7:02:08

13.5.1　人月神话
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18157-18157的标注 | 添加于 2019年5月7日星期二 下午7:02:14

在下面几节，关于管理大型软件项目
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18157-18157的标注 | 添加于 2019年5月7日星期二 下午7:02:18

在下面几节，关于管理大型软件项目，特别是大型操作系统项目，我们有一些看法要陈述。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18158-18159的标注 | 添加于 2019年5月7日星期二 下午7:03:11

经典著作《人月神话》的作者Fred Brooks是OS/360的设计者之一，他后来转向了学术界。在这部经典著作中，Fred Brooks讨论了建造大型
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18158-18160的标注 | 添加于 2019年5月7日星期二 下午7:03:21

经典著作《人月神话》的作者Fred Brooks是OS/360的设计者之一，他后来转向了学术界。在这部经典著作中，Fred Brooks讨论了建造大型操作系统为什么如此艰难的问题（Brooks,1975,1995）
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18163-18164的标注 | 添加于 2019年5月7日星期二 下午7:03:39

Brooks指出的是，具有几百名程序员的大型项目完全不同于小型项目，并且从小型项目获得的结果并不能放大到大型项目。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18167-18169的标注 | 添加于 2019年5月7日星期二 下午7:04:10

Brooks将工作量估计如下： ·1/3规划 ·1/6编码 ·1/4模块测试 ·1/4系统测试
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18169-18169的标注 | 添加于 2019年5月7日星期二 下午7:04:44

换言之，编写代码是容易的部分
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18169-18170的标注 | 添加于 2019年5月7日星期二 下午7:04:48

换言之，编写代码是容易的部分，困难的部分是断定应该有哪些模块并且使模块A与模块B正确地交互。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18171-18171的标注 | 添加于 2019年5月7日星期二 下午7:04:58

Brooks的书的标题来自他的断言，即人与时间是不可互换的。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18173-18173的标注 | 添加于 2019年5月7日星期二 下午7:05:21

产生这一效应有三个原因。第一，工作不可能完全并行化。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18175-18175的标注 | 添加于 2019年5月7日星期二 下午7:05:36

第二，为了完全利用数目众多的程序员，工作必须划分成数目众多的模块，这样每个人才能有事情
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18175-18175的标注 | 添加于 2019年5月7日星期二 下午7:05:39

第二，为了完全利用数目众多的程序员，工作必须划分成数目众多的模块，这样每个人才能有事情
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18175-18175的标注 | 添加于 2019年5月7日星期二 下午7:05:41

第二，为了完全利用数目众多的程序员，工作必须划分成数目众多的模块，这样每个人才能有事情
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18175-18175的标注 | 添加于 2019年5月7日星期二 下午7:05:46

第二，为了完全利用数目众多的程序员，工作必须划分成数目众多的模块，这样每个人才能有事情做。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18178-18179的标注 | 添加于 2019年5月7日星期二 下午7:06:14

第三，调试工作是高度序列化的。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18180-18182的标注 | 添加于 2019年5月7日星期二 下午7:06:29

对于人员与时间的权衡，Brooks将他的经验总结在Brooks定律中： 对于一个延期的软件项目，增加人力将使它更加延期。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18182-18183的标注 | 添加于 2019年5月7日星期二 下午7:06:56

增加人员的问题在于他们必须在项目中获得培训，模块必须重新划分以便与现在可用的更多数目的程序员相匹配，需要开许多会议来协调各方面的努力等。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18187-18187的标注 | 添加于 2019年5月7日星期二 下午7:07:24

13.5.2　团队结构
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18188-18188的标注 | 添加于 2019年5月7日星期二 下午7:08:13

商业操作系统是大型的软件项目，总是需要大型的人员团队。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18188-18188的标注 | 添加于 2019年5月7日星期二 下午7:08:22

商业操作系统是大型的软件项目，总是需要大型的人员团队。人员的质量极为重要。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18191-18192的标注 | 添加于 2019年5月7日星期二 下午7:08:35

在任何大型的设计项目（软件或其他）中，同样重要的是需要体系结构的一致性。应该有一名才智超群的人对设计进行控制。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18194-18195的标注 | 添加于 2019年5月7日星期二 下午7:09:05

在20世纪70年代，Harlan Mills把“一些程序员比其他程序员要好很多”的观察结果与对体系结构一致性的
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18194-18196的标注 | 添加于 2019年5月7日星期二 下午7:09:11

在20世纪70年代，Harlan Mills把“一些程序员比其他程序员要好很多”的观察结果与对体系结构一致性的需要相结合，提出了首席程序员团队（chief programmer team）的范式（Baker,1972）
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18200-18200的标注 | 添加于 2019年5月7日星期二 下午7:10:10

自从提出这一建议并付诸实施，30
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18200-18201的标注 | 添加于 2019年5月7日星期二 下午7:10:41

自从提出这一建议并付诸实施，30年过去了。一些事情已经变化（例如需要一个语言层——C比PL/I更为简单），但是只需要一名才智超群的人员对设计进行控制仍然是正确的。并且
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18203-18204的标注 | 添加于 2019年5月7日星期二 下午7:11:40

任何大型项目都需要组织成层次结构。底层是许多小的团队，每个团队由首席程序员领导。在下一层，必须由一名经理人对一组团队进行协调。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18206-18207的标注 | 添加于 2019年5月7日星期二 下午7:12:15

Brooks观察到，坏消息不能很好地沿着树向上传播。麻省理工学院的Jerry Saltzer将这一效应称为坏消息二极管（bad-news diode
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18210-18210的标注 | 添加于 2019年5月7日星期二 下午7:12:23

实际上，大型公司拥有生产软件的
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18210-18211的标注 | 添加于 2019年5月7日星期二 下午7:12:46

实际上，大型公司拥有生产软件的丰富经验并且知道如果它随意地生产会发生什么，这样的公司趋向于至少是试图正确地做事情。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18212-18213的标注 | 添加于 2019年5月7日星期二 下午7:13:35

开放源码运动的成长。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18212-18213的标注 | 添加于 2019年5月7日星期二 下午7:13:39

Brooks和Mills都没有预见到开放源码运动的成长。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18215-18215的标注 | 添加于 2019年5月7日星期二 下午7:13:47

得注意的是，最为成功的开放源码软件项
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18215-18215的标注 | 添加于 2019年5月7日星期二 下午7:13:52

得注意的是，最为成功的开放源码软件项目显然使用了首席程序员模型，
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18220-18220的标注 | 添加于 2019年5月7日星期二 下午7:13:58

13.5.3　经验的作用
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18221-18221的标注 | 添加于 2019年5月7日星期二 下午7:14:01

拥有丰富经验的设计人员对于一个操作系统项目来说至关重要。Brooks
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18221-18222的标注 | 添加于 2019年5月7日星期二 下午7:14:07

拥有丰富经验的设计人员对于一个操作系统项目来说至关重要。Brooks指出，大多数错误不是在代码中，而是在设计中。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18223-18224的标注 | 添加于 2019年5月7日星期二 下午7:14:18

Brooks的解决方案是放弃图13-11a的经典开发模型而采用图13-11b的模型。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18223-18224的标注 | 添加于 2019年5月7日星期二 下午7:15:02

Brooks的解决方案是放弃图13-11a的经典开发模型而采用图13-11b的模型。此处的想法是首先编写一个主程序，它仅仅调用顶层过程，而顶层过程最初是哑过程
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18229-18229的标注 | 添加于 2019年5月7日星期二 下午7:15:29

缺乏知识是一件危险的事情。Brooks
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18229-18230的标注 | 添加于 2019年5月7日星期二 下午7:15:34

缺乏知识是一件危险的事情。Brooks注意到被他称为第二系统效应（second system effect）的现象。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18234-18234的标注 | 添加于 2019年5月7日星期二 下午7:16:37

就这一点而言，CTSS和MULTICS这一对系统是一个明显的例子
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18234-18234的标注 | 添加于 2019年5月7日星期二 下午7:16:41

就这一点而言，CTSS和MULTICS这一对系统是一个明显的例子。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18240-18240的标注 | 添加于 2019年5月7日星期二 下午7:16:47

13.5.4　没有银弹
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18240-18241的标注 | 添加于 2019年5月7日星期二 下午7:16:55

除了《人月神话》，Brooks还写了一篇有影响的学术论文，称为“No Silver Bullet”（没有银弹）（Brooks,1987）。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18242-18244的标注 | 添加于 2019年5月7日星期二 下午7:17:20

在建议的银弹中，包括更好的高级语言、面向对象的程序设计、人工智能、专家系统、自动程序设计、图形化程序设计、程序验证以及程序设计环境。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18252-18252的标注 | 添加于 2019年5月7日星期二 下午7:17:56

13.6.1　虚拟化
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18252-18252的标注 | 添加于 2019年5月7日星期二 下午7:17:58

虚拟化重回时代。它
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18253-18253的标注 | 添加于 2019年5月7日星期二 下午7:18:16

最近许多计算机在裸机上运行管理程序，如图13-12所示。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18260-18260的标注 | 添加于 2019年5月7日星期二 下午7:18:40

13.6.2　多核芯片
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18260-18261的标注 | 添加于 2019年5月7日星期二 下午7:18:45

多核芯片已经出现，但即使是双核，针对它们的操作系统还没有很好地利用其能力，更不用提64核
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18263-18264的标注 | 添加于 2019年5月7日星期二 下午7:19:03

虚拟化和多核芯片的结合创造了一个全新的环境，这里CPU的数目是可编程的。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18269-18269的标注 | 添加于 2019年5月7日星期二 下午7:19:20

13.6.3　大型地址空间操作系统
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18269-18270的标注 | 添加于 2019年5月7日星期二 下午7:19:28

随着计算机从32位地址空间转向64位地址空间，操作系统设计中的重大转变成为可能。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18275-18275的标注 | 添加于 2019年5月7日星期二 下午7:21:38

另一个可能的用途是永久对象存储。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18273-18274的标注 | 添加于 2019年5月7日星期二 下午10:51:21

对于2×1019 字节的地址空间我们能做什么呢？首先，可以淘汰文件系统概念。作为替代，所有文件在概念
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18279-18280的标注 | 添加于 2019年5月8日星期三 上午12:01:44

由于大量数目的对象在地址空间中，允许多个进程同时在相同的地址空间中运行，以便以一般的方式共享对象就变得十分有趣
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18282-18282的标注 | 添加于 2019年5月8日星期三 上午12:01:55

64位地址而言，另一个必须重新思考的操作系统问题是虚拟内存。对于
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18287-18288的标注 | 添加于 2019年5月8日星期三 上午12:02:10

13.6.4　联网
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18288-18288的标注 | 添加于 2019年5月8日星期三 上午12:02:14

当前的操作系统是为独立的计算机而设计的。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18289-18289的标注 | 添加于 2019年5月8日星期三 上午12:02:27

在将来，联网或许将会是所有操作系统的基础。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18291-18291的标注 | 添加于 2019年5月8日星期三 上午12:02:32

操作系统将不得不改变以适应这一范型的转变。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18291-18292的标注 | 添加于 2019年5月8日星期三 上午12:02:39

操作系统将不得不改变以适应这一范型的转变。本地数据与远程数据的区别可能会模糊到这样的程度：实际上没有人知道或者关心数据存放在什么地方。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18293-18294的标注 | 添加于 2019年5月8日星期三 上午12:02:49

对于Web的访问现在需要特殊的程序（浏览器），将来可能会以一种无缝的方式完全集成到操作系统
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18299-18299的标注 | 添加于 2019年5月8日星期三 上午12:02:57

13.6.5　并行系统与分布式系统
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18299-18300的标注 | 添加于 2019年5月8日星期三 上午12:03:01

另一个活跃的领域是并行系统与分布式系统
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18301-18302的标注 | 添加于 2019年5月8日星期三 上午12:03:12

在将来，我们可能会看到这样的操作系统，其中并行性比现在更加处于中心地位。如果
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18301-18301的标注 | 添加于 2019年5月8日星期三 上午12:03:18

在将来，我们可能会看到这样的操作系统，其中并行性比现在更加处于中心地位
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18303-18304的标注 | 添加于 2019年5月8日星期三 上午12:03:33

在未来几年，多计算机很可能在大规模科学与工程超级计算机中占据支配地位，但是它们的操作系统还相当原始。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18305-18306的标注 | 添加于 2019年5月8日星期三 上午12:03:48

目前分布式系统经常作为中间件来构建，因为现有的操作系统没有为分布式应用程序提供正确的设施。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18310-18310的标注 | 添加于 2019年5月8日星期三 上午12:04:07

13.6.6　多媒体 多媒体系统在计算机世界里显然是一颗正在升起的明星。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18318-18318的标注 | 添加于 2019年5月8日星期三 上午12:04:31

13.6.7　电池供电的计算机
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18320-18322的标注 | 添加于 2019年5月8日星期三 上午12:05:51

，市场上增长甚至更快的部分是电池供电的计算机，包括笔记本、掌上机、Webpad、100美元的膝上机以及智能手机。它们中的某些机种拥有与外部世界的无线连接，其他的机种当它们不在家中与坞站对接时将运行在非连接的模式下。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18324-18325的标注 | 添加于 2019年5月8日星期三 上午12:06:02

这些操作系统必须处理完全连接（也就是有线连接）、弱连接（也就是无线连接）和非连接操作，包括离线前的数据储藏和返回在线时的一致性分析
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18326-18327的标注 | 添加于 2019年5月8日星期三 上午12:06:14

更好。它们还必须能比当前的系统更好地处理移动问题（例如找到一个激光打印机，登录到其上，并且通过无线电波把文件发送给它）。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18324-18327的标注 | 添加于 2019年5月8日星期三 上午12:06:18

这些操作系统必须处理完全连接（也就是有线连接）、弱连接（也就是无线连接）和非连接操作，包括离线前的数据储藏和返回在线时的一致性分析，这些都要比当前的系统更好。它们还必须能比当前的系统更好地处理移动问题（例如找到一个激光打印机，登录到其上，并且通过无线电波把文件发送给它）。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18324-18328的标注 | 添加于 2019年5月8日星期三 上午12:06:29

这些操作系统必须处理完全连接（也就是有线连接）、弱连接（也就是无线连接）和非连接操作，包括离线前的数据储藏和返回在线时的一致性分析，这些都要比当前的系统更好。它们还必须能比当前的系统更好地处理移动问题（例如找到一个激光打印机，登录到其上，并且通过无线电波把文件发送给它）。电源管理是必需的，这包括在操作系统与应用程序之间关于剩余多少电池电量以及电池如何最好利用的大量对话框。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18334-18334的标注 | 添加于 2019年5月8日星期三 上午12:06:54

13.6.8　嵌入式系统
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18334-18335的标注 | 添加于 2019年5月8日星期三 上午12:06:59

新型操作系统将高速增长的最后一个领域是嵌入式系统。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18339-18340的标注 | 添加于 2019年5月8日星期三 上午12:07:51

对于嵌入式系统而言，一种有希望的思路是可扩展的操作系统（例如Paramecium和Exokernel）。这些
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18339-18340的标注 | 添加于 2019年5月8日星期三 上午12:08:01

对于嵌入式系统而言，一种有希望的思路是可扩展的操作系统（例如Paramecium和Exokernel）。这些操作系统可以随着应用程序的需要而被构建成轻量级的或重量级的，但是以一种应用程序间一致的方式
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18344-18345的标注 | 添加于 2019年5月8日星期三 上午12:08:30

13.6.9　传感节点 虽然传感网络的市场并不大，但它们正被部署在很多环境中，从楼宇/边境监控到森林火险监测等。
==========
现代操作系统（原书第3版） (计算机科学丛书) (Andrews Tanenbaum)
- 您在位置 #18347-18348的标注 | 添加于 2019年5月8日星期三 上午12:09:14

。一般来说，其电池寿命以月衡量，而无线传输是主要的电源消耗者，因此这些系统应该以节能为首要目标。
==========

​    