# 现代操作系统 第11章 实例研究2：Windows Vista

- Windows是一个现代的操作系统，可以运行在消费型或商业型桌面计算机和企业服务器上
- 最新的桌面版本是Windows Vista
  - Windows Vista的服务器版本称为Windows Server 2008

## 11.1 Windows Vista的历史

- 微软公司为桌面计算机和服务器开发的Windows操作系统可以划分为三个时代：
  - MS-DOS
  - 基于MS-DOS的Windows
  - 基于NT的Windows
  - 现代Windows


![11-1](F:\现代操作系统\resource\11-1.jpg)

### 11.1.1 20世纪80年代：MS-DOS

- 微软从一家本地公司西雅图计算机产品（Seatle Computer Products）买到了一份CP/M的拷贝，移植到IBM PC中，并且授权IBM使用
  - 这个产品被命名为MS-DOS 1.0（Microsoft Disk Operation System）并且在1981年与第一款IBM PC一同发售
- MS-DOS是一款16位、实时模式、单一用户、命令行式的操作系统

### 11.1.2 20世纪90年代：基于MS-DOS的Windows

- 由于受到了斯坦福研究学院和Xerox PARC研究的图形用户界面的启发，以及他们取得的商业产品——苹果的Lisa和Macintosh，微软决定增加MS-DOS的图形用户界面，并命名为Windows
- 在1990年微软为Intel 386发布了Windows 3.0版本
  - Windows 3.0不是一款真正的操作系统，而是在MS-DOS上应用了图形用户界面，它仍然受到机器和文件系统的控制
- 在1995年8月，Windows 95发布了
  - 它在一个成熟的系统内包括了许多特性，包括虚拟内存、进程管理、多程序设计、32位的程序界面

### 11.1.3 21世纪：基于NT的Windows

- 微软从DEC公司招聘了一些由Dave Cutler带领的工程师，它是DEC的VMS操作系统的主要架构设计者
  - Cutler被指派开发一种全新的32位操作系统用于实现OS/2，微软当时联合IBM在合作开发OS/2操作系统的API接口
  - 最初的设计文档中，Cutler的团队称这种操作系统为NT OS/2
- Cutler的系统由于包含很多新技术被称作NT（New Technology）

![11-2](F:\现代操作系统\resource\11-2.jpg)

- 在NT系统中，线程是并行单元，动态连接库是组成的单元，并且fork/exec是被通过单一操作命令来实现创建一个全新的进程，然后运行另外一个程序而不需要首先复制一个拷贝
- 第一个基于NT的Windows版本（Windows 3.1）在1993年发布
  - Windows API的32位扩展称为Win32
- 就像基于MS-DOS的Windows的最初版本一样，基于NT的Windows的最初版本也不是完全成功的
  - 与设备驱动和应用程序的不兼容使得许多消费者重新回到微软仍在改进的基于MS-DOS的Windows——发布于1995年的Windows 95
- NT确实达到了可移植的目标，在后续的1994和1995发布的版本中增加了对（小指令字节）MIPS和Power PC架构的支持
- 图11-3显示了Win32 API和Windows之间的关系
  - Win32 API接口允许程序在几乎所有版本的Windows上运行

![11-3](F:\现代操作系统\resource\11-3.jpg)

- 这种兼容性使得用户可以方便地从Windows 95移植到NT，操作系统也在高端的计算机市场上比如说服务器领域中扮演了很重要的角色
- Windows 2000代表了NT的重大进化
  - 它技术上的成功，领导着微软继续朝着通过提高应用程序和设备的兼容性来引导下一个Windows XP
- Windows XP代表着微软的一种新的发展路径，为桌面用户和企业用户发布不同的版本

![11-4](F:\现代操作系统\resource\11-4.jpg)

- 微软紧跟着Windows XP后面的是一个野心勃勃的发布，令PC消费者兴奋的全新体验
  - Windows Vista在2006年下半年完成
  - Vista的服务器版本（Windows Server 2008）在用户版本的一年之后发布

### 11.1.4 Windows Vista

- Windows Vista达到了微软目前为止最为全面的操作系统的巅峰
- 整个系统的规模是相当惊人的
  - 最早NT系统发行时只有300万条C/C++语句，到NT4时增长到了1600万，2000是3000万，XP是5000万，而到了Vista已经超过了7000万
  - 规模增大的大部分原因是每次微软公司在发行新版本时都增加一些新功能
- 图11-5比较懒Windows和Linux的核心在CPU调度、I/O设备和虚拟内存三个主要功能方面的区别

![11-5](F:\现代操作系统\resource\11-5.jpg)

## 11.2 Windows Vista编程

- 为编写的代码不是Win32就是.NET，其中.NET本身也是运行在Win32之上的
- 图11-6介绍的是Windows操作系统的各个层次

![11-6](F:\现代操作系统\resource\11-6.jpg)

- NT操作系统的核心是NTOS内核态程序（ntoskrnl.exe），它提供了操作系统的其他部分的实现所依赖的传统的系统调用接口
- 最早的NT支持三个个性化子系统：OS/2、POSIX、Win32
- 不同于Win32，.NET并不是原来NT的内核接口上的正式的子系统
  - .NET是建立在Win32编程模型之上的
- 如图11-7所示，NT子系统建立了四个部分：子系统进程、程序库、创建进程（CreateProcess）钩子、内核支持

![11-7](F:\现代操作系统\resource\11-7.jpg)

- 程序库同时实现了高层的操作系统功能和特定的子系统进程
  - 这些高层的操作系统功能是特定于子系统以及子系统所包含的桩程序（srub routine）的
  - 桩程序是进行不同的使用子系统的进程间通信的
- 在Win32 CreateProcess中的钩子函数（hook）通过查看二进制图像来检测子系统中每个程序请求
- NT内核有很多一般用途的设备，可以用来编写操作系统特定的子系统
- 子系统进程是本地端NT程序，其使用NT内核和核心服务提供的使用本地系统调用，例如smss.exe和lsass.exe（本地安全管理）
  - 本地系统调用包括管理虚拟地址的跨进程功能（facility）、线程、句柄和为了运行用来使用特定子系统的程序而创建的进程中的异常

### 11.2.1 内部NT应用编程接口

- Windows Vista拥有一套系统调用
  - 它们在Windows Vista的NTOS层实施，在内核态运行
  - 微软没有公布内部系统调用的细节
- 大多数内部的NT系统调用都是对内核态对象进行操作的，包括文件、线程、管道、信号量等
  - 内核态对象类型的普通类型

![11-8](F:\现代操作系统\resource\11-8.jpg)

- 有时使用“对象”来指代操作系统所控制的数据结构
- 在本地NT API调用中存在创建新的内核态对象或操作已经存在的对象的调用
  - 每次创建和打开对象的调用都返回一个结果叫句柄（handle）给调用者（caller）
- 每一个对象都有一个和它相关的安全描述信息，详细指出对于特定的访问请求，什么对象能够活着不能够针对一个特定的目标进行何种操作
- 并不是所有系统创建的数据结构都是对象，并不是所有的对象都是内核对象
  - 那些真正的内核态对象是那些需要命名、保护或以某种方式共享的对象
- 图11-9为一些本地API的示例，通过特定的句柄操作内核对象

![11-9](F:\现代操作系统\resource\11-9.jpg)

- UNIX系统也同样支持内核态对象
- Windows中的内核对象使用一个的基于NT名字空间中关于对象的句柄和命名统一设备指代内核对象，而且使用一个统一的集中式对象管理器
- 对象管理器在NT名字空间中使用统一的字符编码标准（宽位字符）命名
  - 不区分大小写
  - NT名字空间是一个二分层树形结构的目录，象征联系和对象
  - 对象管理器提供统一的管理同步、安全和对象生命期的设备
  - 这不仅是应用程序使用对象管理器中的对象
    - 操作系统本身也创建和使用对象——而且非常多
- 不像UNIX把名字空间的根放在了文件系统中，NT的名字空间则是在保留在了内核的虚拟内存中
- 一个命名的目标文件可以标记为永久性的，这意味着这个文件会一直存在，即使在没有进程的句柄指向该对象条件下，除非他被删除或者系统重新启动
  - 永久性名字也用来描述同步的对象或者共享内存，因此它们可以被进程共享，避免了当进程频繁启动和停止时来不断重建

### 11.2.2 Win32应用编程接口

- Win32函数调用统称为Win32 API接口
  - 这些接口在调用的时候采用库文件链接流程：通过封装来完成原始NT系统调用，有些时候也会在用户态下工作
- 图11-10表示出各种级别的Win32 API调用以及它们封装的原始API调用

![11-10](F:\现代操作系统\resource\11-10.jpg)

- 一些Win32调用使用路径名，然而相关的NT内核调用使用句柄
  - 封装流程同时包括把Win32 API从ANSI编码变成Unicode编码
- 因为已经存在的Win32位接口很少随着操作系统的改变和改变，所以理论上说能在前一个版本系统上运行的程序也能正常在新版本的系统上运行
  - Windows太复杂了以至于有些表面上不合逻辑的改动会导致应用程序运行失败
- Windows支持两种特殊环境
  - 一种叫WOW
- Windows API体系不同于UNIX体系
  - 对于后者来说，操作系统很简单，只有很少的参数以及很少的方法来执行同样的操作
  - Win32提供了一组非常多的接口
    - Win32有创建和管理进程和线程的调用，Win32也有许多进程内部通信的调用
- 虽然大量的内存管理系统对程序员来说是看不见的，但是一个重要的特征是可见的：即一个进程把文件映射到虚拟内存的一块区域上
  - Windows处理内存映射文件使用三中完全不同的手段
    - 它提供允许进程管理它们自己虚拟空间的接口，包括预留地址范围为以后用
    - Win32支持一种称作文件映射的抽象，这用来代替可定位的实体，如文件（文件的映射在NT的层次中称作section）
    - 把文件映射的视图映射到一个进程的地址空间
  - 在Windows中，文件映射的内核态实体被句柄所取代
- 对许多程序来说，一个重要的领域是文件I/O操作
  - 在Win32基本视图中，一个文件仅仅是一组有顺序的字节流
  - 还有更高级的处理文件数据的方法
    - 除了主要的文件流，存在NTFS文件系统上的文件可以拥有额外的文件流
  - 对于NTFS的卷来说，挂载点（Windows称作再分解点）和符号链接用来帮助组织卷
- 低级别的Windows I/O模式基本上是异步的
  - 执行体会在返回到用户态前和I/O操作结束时进行同步
- Win32提供的另一些调用是安全性相关的
  - 每个线程将和一个内核对象进行捆绑，称作令牌（token），这个令牌提供关于该线程的身份和权限相关的信息
  - 这种安全模式使可以扩展的，允许应用程序添加新的安全规则
- Win32的名字空间不同于前面描述的NT内核名字空间，
  - NT内核空间仅仅只有一部分对Win32 API函数可见
- 对于底层系统调用，Win32 API也支持许多GUI操作，包括系统所有图形接口的调用
  - GUI操作直接使用win32k.sys驱动，这个驱动使用特殊的函数从用户态去访问内核态的接口

### 11.2.3 Windows注册表

- 名字空间的根在内核中维护
  - 存储设备，如系统的卷，附属于名字空间中
  - 名字空间会因为系统的每次启动重新构建
  - Windows会挂载一种特殊的文件系统（为小文件做了优化）到名字空间，这个文件系统称作注册表（registry）
  - 注册表被组织成了不同的卷，称作储巢（hive）
- Windows在系统储巢里面保存了大量的重要信息，包括驱动程序去驱使什么设备工作，什么软件进行初始化，以及什么变量来控制操作系统的操作等
- 其他配置储巢用在系统启动后，描述系统安装的软件的信息，特别是用户和用户态下安装在系统上的COM（Component Object-Model）
- Windows Vista中的注册表储巢。HKLM是HKEY_LOCAL_MACHINE的缩写

![11-11](F:\现代操作系统\resource\11-11.jpg)

- 在引入注册表之前，Windows的配置信息保存在大量的.ini文件里，分散在硬盘的各个地方
- 注册表是位于数据库和文件系统之间的一个交叉点，但是和每一个都不像
  - regedit能够以图形窗口的方式来浏览注册表，这个工具允许查看其中的文件夹（称作键）和数据项（称作值）
  - Procmon监视系统中所有对注册表的访问
  - 注册表编辑器允许用户对注册表进行编辑，但是一旦你这么做就必须非常小心
- 微软Windows Vista已经引入了一个基于事务管理的内核，用来支持对跨越文件系统和注册表操作的事务进行协调
- Win32程序员通过函数调用可很方便地访问注册表

![11-12](F:\现代操作系统\resource\11-12.jpg)

- 当系统关闭时，大部分的注册表信息被存储在硬盘储巢中
  - 注册表损坏需要重新安装系统山过的所有软件

## 11.3 系统结构

- 现在观察系统是如何组织的，不同的部件承担什么工作以及它们是如何组织的，不同的部件承担什么工作以及它们彼此间或者和用户程序间是如何配合的

### 11.3.1 操作系统结构

- Windows Vista操作系统包括很多层，如图11-6所示

![11-6](F:\现代操作系统\resource\11-6.jpg)

- 操作系统中内核态最低层的中心就是NTOS内核层自身，当Windows启动时由ntoskrnl.exe加载
  - NTOS包括两层
    - executive（执行体）提供大部分的服务
    - 另一个较小的层称为内核（kernel）
- 将NTOS分为内核和执行体体现了NT的VAX/VMS根源
  - VMS操作系统也是由Cutler团队设计，可分为4个由硬件实施的层次：用户、管理程序、执行体和内核，与VAX处理机结构提供的4中保护模式一致
- NT的内核态层如图11-13所示
  - 最顶层是系统库ntdll.dll，它实际工作于用户态
  - NTdll.dll也包括了特殊码输入指针以支持内核初始化线程、分发异常和用户态的异步过程调用（Asynchronous Procedure Calls，APC）

![11-13](F:\现代操作系统\resource\11-13.jpg)

- 在NTOS内核和执行体层之下是称为硬件抽象层（Hardware Abstraction Layer，HAL）
  - 该软件对类似于设备寄存器存取和DMA操作之类的底层硬件信息进行抽象，同时还就BIOS固件是如何表述配置信息和处理CPU芯片的不同（如各种中断控制器）进行抽象
- 内核态下另一个主要部件就是设备驱动器
  - I/O和虚拟内存部件协作加载设备驱动程序至内核存储器并将它们连接到NTOS和HAL层
    - I/O管理器提供发现、组织和操作设备的接口

#### 1. 硬件抽象层

- 操作系统各层有大量部件具有很好的可移植性（因为它们主要处理支持编程模式的内核数据结构和抽象，从而支持特定的编成模式），其他层就必须处理设备寄存器、中断、DMA以及机器与机器间显著不同的其他硬件特征
- 大多数NTOS内核源代码由C语言编写和非汇编语言
  - 大量的特定硬件的优化即使不用汇编语言编写，也将不得不手工处理
  - 大型服务器的内存如何组织或者何种硬件同步基元是可获得的，与此相关的硬件细节对系统较高层都有比较大的影响
- 微软尝试通过最下端的HAL层隐藏对这些设备类型的依赖
  - HAL的工作就是对这些硬件进行抽象，隐藏处理器版本、支持芯片集和其他配置变更等具体细节
  - 使用HAL服务而不直接写硬件地址，驱动器和内核在与新处理器通信时只需要较小改变
  - HAL对诸如键盘、鼠标、硬盘等特殊的I/O设备或内存管理单元不提供抽象或服务
- 通过内存映射I/O与I/O端口的对比可以更好地了解硬件抽象层是如何工作的
  - 硬件抽象层为驱动程序编写者分别提供了三种读、写设备寄存器的程序

```c
uc=READ_PORT_UCHAR(port);WRITE_PORT_UCHAR(port,uc)；
us=READ_PORT_USHORT(port);WRITE_PORT_USHORT(port,cs);
ul=READ_PORT_ULONG(port);WRITE_PORT_ULONG(long);
```

- 驱动程序会因为不同目的而频繁存取特定的I/O设备
  - HAL把与总线相关的设备地址映射为系统逻辑地址来区分设备
  - 中断也存在相似的问题——总线依赖性
    - HAL同样提供服务在系统范围内命名中断
  - HAL提供的另一个服务是在设备无关方式下建立和管理DMA转换，对系统范围和专用I/O卡的DMA引擎进行控制
  - HAL也是用一种可移植的方式来管理时钟和定时器的
- 有时需要在底层实现内核部件的同步，尤其是为了防止多处理机系统中的竞争环境
  - HALT提供基元管理同步
- 最终，系统引导后，HAL和BIOS通信，检查系统配置信息以查明系统所包含的总线、I/O设备及其配置情况，同时该信息被添加进注册表

![11-14](F:\现代操作系统\resource\11-14.jpg)

#### 2.内核层

- 在硬件抽象层之上是NTOS，包括两层：内核和执行体
- Windows操作系统的内核层（如图11-13所示，执行体之上）提供了一套管理CPU的抽象
  - 最核心的抽象是线程，但是内核也实现了异常处理、陷阱以及各种中断

![11-13](F:\现代操作系统\resource\11-13.jpg)

- 内核线程调度程序负责决定那些线程执行在系统的每一个CPU上
  - 如果下个运行的线程是在一个不同的地址空间（例如进程），调度程序也必须改变地址空间
- 除了提供更高级别的硬件抽象和线程转换机制，核心层还有另外一项关键功能：提供对下面两种同步机制低级别的支持：
  - control对象
    - 核心层项执行体提供抽象的CPU管理的一种数据结构
  - dispatcher对象
    - Dispatcher对象是一种普通执行对象

#### 3. 延迟过程调用

- Control对象包括线程、中断、定时器、同步、调试等一些原语对象，和两个用来实现DPC和APC的特殊对象
  - DPC（延迟过程调用）对象是用来减少执行ISR（中断服务例程）所需要的时间
- 系统硬件为中断指定了硬件优先级
- 如果ISR执行得太长，提供给低优先级中断的服务将被推迟，可能造成数据丢失或减缓系统的I/O吞吐量
  - 为了减少处理ISR所花费的时间，只有关键的操作才执行，如I/O操作结构的捕捉和设备重置
  - 利用软中断延迟中断处理时一种行之有效的减少ISR延迟时间的方法
    - 在所有高级别的中断处理完成以后，软中断将执行一个低优先级的ISR做字符处理
    - 在当前的Windows操作系统下，类似的例子是键盘设备
    - DPC另一个通常的用处是运行程序以响应定时器中断

#### 4. 异步过程调用

- 另一个特殊的内核控制对象是APC（异步过程调用）对象
  - APC与DPC的相同之处是它们都是延迟处理系统例行程序
  - 不同之处在于DPC时是在特定的CPU上下文中执行
- 当原始中断发生时，DPC例程运行在任何线程的上下文中
  - 在下一个合适的时间，内核层会将APC移交给线程而且调度线程运行
- 用户态下的APC也可以用来把用户态的I/O操作已经完成的信息，通知给初始化I/O操作的线程
  - Win32 API中的QueueUserAPC允许将APC用于任意目的
  - 执行体也使用除了I/O完成之外的一些APC操作

#### 5. 调度对象

- 另一种同步对象是调度对象
  - 这是常用的内核态对象（一种用户可以通过句柄处理的类型），它包含一个称为dispatcher_header的数据结构，如图11-15所示

![11-15](F:\现代操作系统\resource\11-15.jpg)

- 它们包括信号器、互斥体、事件、可等待定时器和其他一些可以等待其他线程同步执行的对象
  - 同步原语，如信号器，是标准的调度对象
    - 另外定时器、文件、端口线程和进程使用调度对象机制去通知
  - 由于Windows使用了一个单一的标准机制去同步内核态对象，一些专门的API就无需再等待事件
- 内核使用两个不同的程序使得线程等待调度对象运行
  - 发出一个通知对象信号
  - 同步对象
- 在Windows代码中互斥体称为“变体”（mutant）

#### 6. 执行体

- 如图11-13所示，在NTOS的内核层以下是执行体
  - 执行体是用C语言编写的，在结构上最为独立（内存管理是一个明显的例外），并且经过少量的修改已经移植到新的处理器上

![11-13](F:\现代操作系统\resource\11-13.jpg)

- 执行体包括很多不同的组件
  - 每个组件分为内部和外部的数据结构和接口
    - 每个组件的内部方法是隐藏的，只有组件自己可以调用
    - 外部方法可以由执行体的所有其他组件调用
  - 微软称许多执行体组件为“管理器”
- 对于大多数操作系统而言，许多功能在Windows上执行就像库的编码
- 当任何执行控制操作阻塞等待与其他线程同步时，用户态线程也会阻塞
  - 对于可预见的低频率任务，会有一个线程一秒运行一次而且由一个长的项目单来处理。
  - 对于不可预见的工作，有一个之前曾经提到的高优先级的辅助线程池
- 对象管理器管理在执行体使用的大部分内核态对象，包括进程、线程、文件、信号、I/O设备及驱动、定时器等
  - 在Windows中，内核数据结构有许多共同特点，即它们在管理标准功能中特别有用
  - 这些功能由对象管理器提供
- 对象管理器的每一个对象都有一个类型用来指定这种类型的对象的生命周期怎样被管理
  - 为了产生一个新的类型，一个操作元件只需要调用一个对象管理器API即可
- I/O管理器为实现I/O设备驱动提供了一个框架，同时还为设备上的配置、访问和完成操作提供一些特定的运行服务
  - 在Windows中，设备驱动器不仅仅管理硬件设备，它们还为操作系统提供可扩展性
  - 最新的Windows版本对在用户态上运行设备驱动程序有更多的支持，这对新的设备驱动程序是首选的模式
  - 错误的内核态设备驱动是导致Windows可怕的BSOD（蓝屏死机）的主要来源，它是Windows侦测到致命的内核态错误并关机或重新启动系统
  - 在内核中有更多的代码，那么内核中就有更多缺陷
  - 从内核到用户态进程的代码移动趋势将在未来几年加速发展
  - I/O管理器还包括即插即用和电源管理设施
    - 当新设备在系统中被检测到，即插即用就开始工作
    - 电源管理能降低能源消耗，延长笔记本电脑电池寿命，保存台式电脑和服务器能量
- 进程管理管理着进程和线程的创建和终止
  - 包括建立规则和参数指导它们
- 执行内存管理器实现了虚拟内存架构的需求分页
  - 它负责管理虚拟页映射到物理页帧，管理现有的物理帧，和使用备份管理磁盘上页面文件
  - 该内存管理器还为大型服务器应用程序提供了特殊功能
  - 内存管理器优化I/O的性能，文件系统内核虚拟地址空间保持一个内存的文件系统页
  - 内存的管理是使用内存映射文件来实现的
- 安全引用监视器（security reference monitor）执行Windows详细的安全机制，以支持计算机安全要求的国际标准的通用标准（Common Critieria）
  - 在Windows中此模块就是内核中的安全监视器
- 执行体中包括其他一些组件，我们将简要介绍
  - 配置管理实现注册表的执行组件
    - 注册表中包含系统配置数据的文件的系统文件称为储巢（hive）
    - 最关键的储巢是系统启动时加载到内存的系统储巢
  - LPC的组成部分提供了运行在同一系统的进程之间的高效内部通信
    - 在Windows Vista（现在成为ALPC、高级LPC）中LPC大大加强了对RPC新功能的支持，包括来自内核态组件的RPC，如驱动
  - Windows NT 4.0中的许多代码与Win32进入内核的图形界面相关，因为当时的硬件无法提供所需的性能
    - 以内核为基础的图形用户界面代码位于一个专门的内核驱动win32k.sys中

#### 7. 设备驱动程序

- 最后一部分图11-13是设备驱动程序的组成
  - 在Windows中的设备驱动程序的动态链接库是由NTOS装载

![11-13](F:\现代操作系统\resource\11-13.jpg)=

- I/O管理器组织的数据按照一定的路线流经过每个设备实例，如图11-16
  - 这个路线称为设备栈，由分配到这条路线上的内核设备对象的私有实例组成
  - 简单描绘两个NTFS文件卷的设备栈。I/O请求包由上往下通过栈。每一级堆栈中的相关驱动中的适当程序被调用。该设备栈由分配给每个堆栈的设备对象组成

![11-16](F:\现代操作系统\resource\11-16.jpg)

- 文件系统作为驱动程序被加载
  - 特别过滤驱动程序，称为文件系统过滤驱动程序
- 网络协议也作为使用I/O模型的驱动被装载起来，例如Windows Vista整合的IPv4/IPv6 TCP/IP实现

### 11.3.2 启动Windows Vista

- 使用操作系统需要运行几个步骤
  - 当电脑打开时，CPU初始化硬件
  - 然后开始执行内存中的一个程序
    - 在大多数PC机中，最初的初始化程序是BIOS（基本输入/输出系统）
    - BIOS提供了Windows Vista在磁盘驱动器分区开始时首先装载的小引导程序
  - 引导程序知道如何在根目录的文件系统卷之外阅读足够的信息去发现独立的Windows BootMgr程序
    - BootMgr确定系统是否已经处于休眠或待机模式
    - 如果是，BootMgr加载和执行WinResume.exe
    - 否则加载和执行WinLoad.exe执行新的启动
  - WinLoad加载系统启动组件到内存中：内核/执行体（通常是Ntoskrnl.exe）、HAL（hal.dll）
- 一旦Windows启动组件加载到内存中，控制就转移给NTOS中的低级代码，来完成初始化HAL、内核和执行体、连接驱动像、访问/更新系统配置中的数据等操作
  - Windows启动程序遇到系统启动失败时，有专门处理常用问题的逻辑
- 另一种常见的问题，用户认为，一些Windows系统偶尔看起来很不可思议，经常有系统和应用程序（看似随机）崩溃
  - 由于物理内存损坏导致

### 11.3.3 对象管理器的实现

- 对象管理器也许是Windows可执行过程中一个最重要的组件
  - 它提供了一个统一的和一致的接口，用于管理系统资源和数据结构
- 由对象管理器提供的统一性有不同的方面
  - 所有这些对象使用相同的机制
  - 它们都可以被用户态进程通过使用句柄访问
  - 在内核对象上有一个统一的协议管理指针的引用
  - 对象可以从NT的名字空间（有对象管理器管理）中得到名字
  - 调度对象可以使用共同的同步和通知接口
  - 有一个共同的安全系统
- 理解对象的关键，是要意识到一个（执行）对象仅仅是内核态下在虚拟内存可以访问的一个数据结构
  - 一种事实上的结果是，对象只是内核数据结构，当系统重新启动时（或崩溃时）所有的对象都将丢失
  - 对象结构，如图11-17所示

![11-17](F:\现代操作系统\resource\11-17.jpg)

- 对象的内存分配来自由执行体保持的两个堆（或池）的内存之一
  - 大部分来自内核堆管理器的分配，是通过使用每个处理器后备名单来获得的，这个后备名单中包含分配大小一致的LIFO列表
- 每个对象标头包含一个配额字段，这是用于对进程访问一个对象的配额征收
  - 配额是用来保持用户使用较多的系统资源
- 物理内存和内核虚拟地址都是宝贵的资源，当一个对象不再需要，应该取消并回收它的内存和地址
  - 为了避免由于竞争条件而过早地释放对象，对象管理器实现了一个引用计数机制，以及引用指针的概念

#### 1. 句柄

- Windows使用句柄来引用内核态对象
  - 句柄是不透明值（opaque value），该不透明值是被对象管理器转换到具体的应用，以表示一个对象的内核态数据结构
  - 图11-18表示了用来把句柄转换成对象的指针的句柄表的数据结构

![11-18](F:\现代操作系统\resource\11-18.jpg)

- 图11-19显示，句柄表最大支持两个额外的间接层
  - 最多达到1600万个句柄的句柄表数据结构

![11-19](F:\现代操作系统\resource\11-19.jpg)

- 用户可以通过Win32调用的CreateSemaphore或OpenSemaphore来创建新的对象或打开一个已经存在的对象
  - 储存在内核内存的进程私有句柄表的一个64位句柄表入口
  - 内核的64位句柄表入口包含两个32位字节

#### 2. 对象名字空间

- 进程可以通过由一个进程把到对象的句柄复制给其他进程来共享对象
  - 但是这需要复制的进程有道其他进程的句柄，而这样在多数情况中并不适用
- 为了抵制的全面分享和持久化需求，对象管理允许随意的对象在被创建的时候就给定其NT名字空间中的名字
  - NT名字空间是分级的，借由对象管理器实现目录和特征连接
  - 名字空间也是可拓展的，通过提供一个叫做Parse的进程允许任何对象类型指定名字空间拓展
  - 用于指定一个新对象类型的对象语句

![11-20](F:\现代操作系统\resource\11-20.jpg)

- Open语句很少使用，因为默认对象管理器的行为时必需的
  - Close和Delete语句描述对象完成的不同阶段
    - 当兑现过的最后一个句柄关闭，可能会有必要的动作清空状态，这些有Close语句来执行
    - 当最后的指针参考从对象移除，使用Delete语句，从而对象可以准备被删除并使其内存可以重用
  - Parse语句用来打开或创建对象，如文件和登录密码，以及拓展NT名字空间
  - QueryName语句是用来查找与对象关联的名字
  - Security语句用于得到、设置或删除该安全描述符的对象
- 在图11-20里的语句并不是执行每种对象类型最感兴趣的操作
  - 对象感兴趣的操作都是在本地NT API系统调用，如NtCreateProcess、NtCreateFile或NtClose，如图11-9所示

![11-9](F:\现代操作系统\resource\11-9.jpg)

- 虽然对象名字空间对整个运作的系统是至关重要的，但却很少有人知道它的存在，因为没有特殊的浏览工具的话它对用户是不可见的
  - winobj就是这样的浏览工具
  - 在运行时，此工具描绘的对象的名字空间通常包含对象目录，如图11-21列出来的及其他一些

![11-21](F:\现代操作系统\resource\11-21.jpg)

- 一个被奇怪地命名为\??的目录包含用户的所有MS-DOS类型的设备名称
- 如上所述，对象管理器保持一个单独的句柄为每个对象计数
  - 这个计数是从来不会大于指针引用计数，因为每个有效的句柄对象在它的句柄表入口有一个引用指针
- 虽然对象管理器在内核具有全面的管理内核中的对象生命周期，不论是NT API或Win32API的都没有提供一个引用机制来处理再用户态的并行多线程之间的句柄使用
  - 也许Windows的API应该被设计为每个类型对象带有一个关闭API，而不是单一的通用NTClose操作
  - 另一个解决办法可能是在句柄表中的指针之外再添加一个序列域
- 为了帮助程序开发人员在他们的程序中寻找这些类似的问题，Windows有一个应用程序验证，软件开发商能够从Microsoft下载
  - 该设备对象是执行体重一个最重要的和贯穿内核态的对象
  - 设备对象代表硬件设备、接口和总线，以及逻辑磁盘分区、磁盘卷甚至文件系统、扩展内核，例如防病毒过滤器
  - I/O和对象管理器创建/打开文件并返回句柄的步骤

![11-22](F:\现代操作系统\resource\11-22.jpg)

- 步骤
  - 当一个执行组件，如实现了本地系统调用NTCreateFile的I/O管理器，在对象管理器中称之为ObOpenObjectByName，它发送一个NT名字空间的Unicode路径名
  - 对象管理器通过目录和符号链接表搜索并最终认定\??\C:指的是设备对象（I/O管理器定义的一个类型）
    - 该设备对象在由对象管理器管理的NT名字空间中一个叶节点
  - 然后对象管理器为该对象类型调用Parse程序，这恰好是由I/O管理器实现的IopParseDevice
    - 它不仅传递一个指针给它发现的设备对象（C：），而且还把剩下的字符串\foo\bar也发送过去
  - I/O管理器将创建一个IRP（I/O请求包），分配一个文件对象，发送请求到由对象管理器确定的设备对象发现的I/O设备堆栈
  - IRP是在I/O堆栈中逐级传递，直到它到达一个代表文件系统C：实例的设备对象。在每一个阶段，控制是通过一个与这一等级设备对象相连的切入点传递到驱动对象内部
  - 该设备对象中遇到指向文件系统的IRP可以表示为文件系统筛选驱动程序，这可能在该操作到达对应的文件系统设备对象之前修改I/O操作
  - 文件系统设备对象有一个链接到文件系统驱动程序对象，叫NTFS
  - NTFS将填补该文件中的对象并将它返回到I/O管理器，I/O管理器备份堆栈中的所有设备，直到IopParseDevice返回对象管理器
  - 在对象管理器以其名字空间中的查找结束。它从Parse程序收到一个初始化对象（这正好是一个文件对象，而不是原来对象发现的设备对象）。因此，对象管理器为文件对象在目前进程的句柄表里创建了一个句柄，并对需求者返回句柄
  - 最后一步是返回用户态的调用者
- 图11-23列出了Windows Vista中非常通用的一些对象类型

![11-23](F:\现代操作系统\resource\11-23.jpg)

- 每个进程（process）和每个线程（thread）都有一个对象来表示，这个对象包含了管理进程或线程所需的主要属性
  - 接下来的三个对象：信号量、互斥体和事件，都可以处理进程间的同步
  - 端口、定时器和队列对象也与通信和同步相关
  - 当一个对象被打开时，Open file对象将会被创建
  - 访问令牌是安全的对象
  - 配置文件是线程的用于存储程序计数器的正在运行的周期样本的数据结构
  - 段用来表示内存对象
  - 键表示的是像管理名字空间的注册表名字空间的加载点
  - 对象目录和符号链接完全是本地对对象管理器的NT名字空间的一部分
  - 每个已知的操作系统的设备有一个或多个设备对象包含有关它的信息，并且由系统引用该设备
  - 最后，每个已加载设备驱动程序在对象空间中有一个驱动程序对象

### 11.3.4 子系统、DLL和用户态服务

- 回到图11-6，我们可以看到Windows Vista操作系统是由内核态中的组件和用户态的组件组成的

![11-6](F:\现代操作系统\resource\11-6.jpg)

- 用户态组件中对于Windows有三种组件尤为重要：
  - 环境子系统
  - DLL
  - 服务进程
- 子系统被视为一种利用内核态运行相同底层软件来支持多个操作系统个性化的方法
- Windows用户态设计的第二个重要方面是在动态链接库（DLL），即代码是在程序运行的时候完成的链接，而非编译时
  - DLL通过允许在进程之间共享通用代码来提高系统效率，保持常用代码在内存中，处理减少从程序磁盘到内存中的加载时间
  - DLL黑洞
    - 因为实现的改变而破坏了一些其他的应用
- DLL的实现在概念上是简单的
  - 一定程度的间接性引用被编译器引入：IAT（导入地址表）
  - 现实是更复杂的
    - 另一个问题是代表DLL之间的关系图可以包含环，或具有不确定性行为，因此计算要加载的DLL列表可以导致不能运行的结果
- DLL用于不仅仅共享常见的代码
  - 它们还可以启用一种宿主的扩展应用程序模型
  - 所有这类动态加载的代码，为操作系统造成了更大的复杂性，因为程序库的版本管理不是只为可执行体匹配对应版本的DLL，而是有时把多个版本的同一个DLL加载到进程中——Microsoft称之为肩并肩（side-by-side）
  - 较好的解决方案是把代码放到独立的进程里
    - 而在进程外承载的代码结果具有较低的性能，并在很多情况下带来了一个更复杂的编程模型
  - 该内核态具有较少的复杂性，是因为它相对于用户态提供了更少的对外部设备驱动模型的支持
- 但是，可能会与服务的用户态处理内核中服务有重大的性能差异
  - 内核态代码（非常仔细地）可以把用户态处理的数据作为参数传递给其系统调用的方式来访问数据
  - 将来跨地址空间的切换代价很可能越来越小，保护模式将会减少，或甚至成为不相关
  - Windows Vista利用用户态的服务进程极大地提升了系统的性能
    - 其中一些服务时同内核的组件紧密相关的
- 在Windows Vista中taskmgr.exe有一个选项卡，标识在系统上运行的服务
  - 在每个共享的服务进程内，个体服务是以DLL的形式加载的
  - 服务是系统中常见的安全漏洞的来源，因为它们是可以远程访问的

## 11.4 Windows Vista中的进程和线程

- Windows具有大量大管理CPU和资源分组的概念

### 11.4.1 基本概念

- 在Windows Vista中的进程是程序的容器
  - 它们持有的虚拟地址空间，以及指向内核态的对象的线程句柄
  - 作为线程的容器，它们提供线程执行所需要的公共资源
  - 每个进程都有用户态系统数据，称为PEB（进程环境块）
- 线程是在Windows中调度CPU的内核抽象
  - 优先级是基于进程中包含优先级值来为每个线程分配的
  - 线程也可以通过亲和处理只在某些处理器上运行
  - 每个线程都有两个单独调用堆栈，一个在用户态执行，另一个内核态执行
  - 也有TEB（线程环境块）使用户态数据指定到线程，包括每个线程存储区（线程本地存储区）和Win32字段、语言和文化本地化以及其他专门的字段
- 除了PEB和TEB外，还有另一个数据结构，内核态与每个进程共享，即用户共享数据
  - 它包含一系列的由内核维护的值
  - 系统调用是比一个内存访问代价大很多，所以对于大量由系统维护的字段，例如时间，这样的处理就很有意义

#### 1. 进程

- 进程创建是从段对象创建的，每个段对象描述了磁盘上某个文件的一个内存对象
  - 在创建一个进程时创建的进程将接受一个句柄
  - 这非常不同于UNIX中创建进程的
    - UNIX是为16位单处理器系统设计的，而这样的单处理器系统而这样的单处理器系统，进程作为并发的单元，并且使用像fork这样的操作来创建进程时一个天才般的设计主意
  - Cutler小组开发NT的时代，当时的硬件环境是32位多处理器系统与虚拟内存硬件共享1~16兆字节的物理内存
    - 因此NT使用进程作为共享内存和数据组资源的容器，并使用线程作为并发调度单元
  - 随后几年里的胸膛呢该救完全不同于这些环境了

#### 2. 作业和纤程

- Windows可以将进程分组为作业，但作业抽象并不足够通用
  - 作业最重要的特性是一旦一个进程在作业中，该进程创建的进程、线程也在该作业中，没有特例
- 一个进程最多属于一个作业
  - 在Windows中很少使用作业
- 图11-24显示了作业、进程、线程和纤程之间的关系
  - 作业包含进程，进程包含线程，但是线程不包含纤程
  - 线程与纤程通常是多对多的关系
  - 作业和纤程是可选的
  - 并不是所有的进程都在作业中或者包含纤程

![11-24](F:\现代操作系统\resource\11-24.jpg)

- 纤程通过分配栈与用来存储纤程相关寄存器和数据的用户态纤程数据结构来创建
  - 纤程的主要优点在于纤程之间切换开销要远远小于线程之间的切换
- 尽管纤程是协同调度的，如果有多个线程调度纤程，则需要非常小心地通过同步机制以确保纤程之间不会相互干扰
  - 每个线程可以运行一个独立的纤程子集，从而建立起线程和纤程之间一对多的关系来简化同步
- 图11-25总结了上面提到的这些抽象

![11-25](F:\现代操作系统\resource\11-25.jpg)

#### 3. 线程

- 通常每一个进程是由一个线程开始的，但一个新的进程也可以动态创建
  - 线程是CPU调度的基本单位
  - 每一个线程有一个调度状态（就绪态、运行态、阻塞态等）
- 每一个线程均有一个线程ID，其和进程ID取自同一空间，因此单一的ID不可能同时被一个线程和一个进程使用
  - 该系统复用了如图11-18和图11-19所示的可扩展句柄管理功能

![11-18](F:\现代操作系统\resource\11-18.jpg)

![11-19](F:\现代操作系统\resource\11-19.jpg)

- 线程通常在用户态运行，但是当它进行一个系统调用时，就切换到内核态，并以其在用户态下相同的属性以及限制继续运行
  - 用户态寄存器的值以上下文（context）数据结构的形式保存在该内核态堆栈底部
  - 线程同时使用其所属的进程的访问令牌运行，但在某些设计客户机/服务器计算的情况下，一个服务器线程可能需要模拟器客户端，此时需要使用基于客户端令牌的临时令牌标识来执行客户的操作
- I/O处理也经常需要关注线程
  - 当执行同步I/O是会阻塞线程，并且异步I/O相关的未完成的I/O请求也关联到线程
- 需要注意的是线程是一个调度的概念，而不是一个资源所有权的概念
- 除了用户态运行的正常线程，Windows有许多只能运行在内核态的系统线程，而其余任何用户态进程都没有联系
  - 所有这一类型的系统线程运行在一个特殊的称为系统进程的进程中
  - 这些线程有的执行管理任务
  - 而其他形成了工作线程池，来分配并执行部件或驱动程序需要系统进程执行的工作

### 11.4.2 作业、进程、线程和纤程管理API调用

- 新的进程由Win32 API函数CreateProcess创建的
  - 这个函数有许多参数和大量的选项
- 大量的参数揭示了Windows和UNIX在进程创建的开发设计上的诸多的不同之处
  - 寻找执行程序的实际搜索路径隐藏在Win32的库代码里，但UNIX中则显式地管理该信息
  - 当前工作目录在UNIX操作系统里是一个内核态的概念，但是在Windows里是用户态字符串
  - UNIX解析命令行，并传递参数数组；而Win32需要每个程序自己解析参数
  - 在UNIX中，文件描述符是否可以被继承是句柄的一个属性。不过在Windows中，其同时是句柄和进程创建参数的属性
  - Win32是面向图形用户界面的，因此新进程能直接获得其窗口信息，而在UNIX中，这些信息时通过参数传递给图形用户界面
  - Windows中的可执行代码没有SETUID位属性，不过一个进程也可以为另一个该用户创建进程，只要能获得该用户的信用标识
  - Windows返回的进程、线程句柄可以用在很多独立的方法中修改新进程/线程。
    - UNIX则只在fork和exec调用的时候修改新进程
- 这些不同有些是来自历史原因和哲学原因
  - 这种比较也有点偏颇，因为Win32是一个用户态下的对NT本地进程执行的包装器，就像UNIX下的系统库函数fork/exec的封装
- 为了支持POSIX子系统，本地进程创建又一个选项可以指定，通过拷贝另一个进程的虚拟地址空间来创建一个新进程，而不是通过映射一个新程序的段对象来新建进程
- 线程创建时传给新线程的参数包括：CPU的上下文信息（包括栈指针和起始指令地址）、TEB模板、一个表示线程创建后马上运行或以挂起状态创建的标志
- 在Windows Vista的发行版中，包含了一个新的关于进程操作方面的本地API
  - 这个接口将原来许多用户态下的步骤转移到了内核态下执行，同时将进程创建与起始线程创建绑定在一起进行

#### 1. 进程间通信

- 线程间可以通过多种方式进行通信，包括管道、命名管道、邮件槽、套接字、远程过程调用（RPC）、共享文件等
  - 管道有两种模式：
    - 字节管道
      - 字节模式的管道的工作方式与UNIX下的工作方式一样
    - 消息管道
      - 消息模式的管道与字节模式的管道大致相同，但会维护消息边界
  - 命名管道在Vista中也是有的，跟普通的管道一样都有两种模式，但命名管道可以在网络中使用
  - 邮件槽是OS/2操作系统的特性，在Windows中实现只是为了兼容性
    - 邮件槽和命名管道在Windows中都是以文件系统的形式实现，而非可执行的功能函数
  - 套接字也与管道类似，只不过它们通常连接的是不同机器上的两个进程
  - 远程过程调用（RPC）是一种进程A命令进程B调用进程B地址空间中的一个函数，然后将执行结果返回给进程A的方式
    - 对于Windows来说，可以通过TCP/IP套接字、命名管道、ALPC来进行传输
      - ALPC的全称是高级本地过程调用（Advanced Local ProcedureCall），它是内核态下的一种消息传递机制，为同一台机器中的进程间通信做了优化，但不支持网络间通信
- 进程间可以共享对象，如段对象

#### 2. 同步

- 进程间也可以使用多种形式的同步对象
  - 就像Windows Vista中提供了多种形式的进程间通信机制一样，Vista也提供了多种形式的同步机制，包括信号量、互斥量、临界区和事件
- 使用Win32的API函数CreateSemaphore可以创建一个信号量，可以将它初始化为一个给定的值，同时也可以指定最大值
  - 对up和down的调用也是有的，只不过他们的函数名看起来比较奇怪：ReleaseSemaphore（up）和WaitForSingleObject（down）
- 互斥量也是用于同步的内核态对象，但是比信号量简单，因为互斥量不需要计数器
  - 它们其实是锁，上锁的函数是WaitForSingleObject，解锁的函数是ReleaseMutex
- 第三种同步机制是临界区，实现的是临界区的概念
  - 临界区在Windows中与互斥量类似，但是临界区相对于主创建线程的地址空间来说是本地的
  - 上锁和解锁的函数分别是EnterCriticalSection和LeaveCriticalSection
- 我们讨论的最后一种同步机制叫事件，它使用内核态对象
  - 有两类事件——通知事件和同步事件
  - 一个事件的状态有两种：收到信号和没收到信号
- Win32 的API中关于进程、线程的个数将进100个，其中的是改革中形式的处理IPC的函数
  - 一些管理进程、线程以及纤程的一些Win32调用

![11-26](F:\现代操作系统\resource\11-26.jpg)

- 可以注意到不是所有的这些都是系统调用
  - 其中有一些是包装器，有一些包含了重要的库代码
  - 以外一些，例如纤程的API，全部都是用户态下的函数

### 11.4.3 进程和线程的实现

- 本节将用更多细节来讲述Windows如何创建一个进程
  - 因为Win32是最具文档化的接口，因此我们将从跟这里开始讲述
- 我们主要集中在创建进程时执行的主代码路径
  - 当用一个进程调用Win32CreateProcess系统调用的时候，则创建一个新的进程
    - 把可执行的文件名从一个Win32路径名转化为一个NT路径名
    - 绑定这个创建过程的参数，并且把它们和可执行程序的完全路径名传递给本地API NtCreateUserProces
    - 在内核态里运行，NtCreateUserProcess执行参数，然后打开这个进程的映像，创建一个内存区对象（section object），它能够用来把程序映射到新进程的虚拟地址空间
    - 进程管理器分配和初始化进程对象
    - 内存管理器通过分配和创建页目录及虚拟地址描述符来为新进程创建地址空间
      - 虚拟地址描述符描述内核态部分，包括特定进程的区域
    - 一个句柄表为新的进程所创建
    - 共享的用户页被映射，并且内存管理器初始化一个工作集的数据结构，这个数据结构是在物理内存缺少的时候用来决定哪些页面可以从一个进程里面移出
    - 执行体创建和初始化用户态的进程环境块（PEB），这个PEB为用户态和内核态用来维护进程范围的状态信息
    - 虚拟内存是分配在（ID表）新进程里面，并且用于传递参数，包括环境变量和命令行
    - 一个进程ID从特殊的句柄表（ID表）分配，这个句柄表是为了有效地定位进程和线程局部唯一的ID
    - 一个线程对象被分配和初始化
    - 进程对象被放入进程全局列表中
    - NtCreateUserProcess项用户态返回新建的进程，其中包括处于就绪并被挂起的单一线程
    - 如果NT API失败，Win32代码会查看进程是否属于另一子系统
    - 如果NtCreateUserProcess成功，还有一些操作要完成
      - Win32进程必须向Win32子系统进程csrss.exe注册
        - Kernel32.dll向csrss.exe发送消息——新的的进程及其句柄和线程句柄，从而进程可以自我复制了
    - 如果进程受限，令牌会被改变，显示新进程访问对象
    - 如果应用程序被设置需要与当前Windows版本加垫层（shim）地兼容运行，则特定的垫层地兼容运行，则特定的垫层将运行
    - 最后，调用NtResumeThread挂起线程，并把这个结构返回给包含所创建的进程和线程的ID、句柄的调用者

#### 调度

- Windows内核没有任何中央调度线程
  - 当一个线程不能够在执行时，线程间进入内核态，调度线程再决定转向的下一个线程
  - 在下面这些情况下，当前正在执行的线程会执行调度程序
    - 当前执行的线程发生了信号量、互斥、事件、I/O等类型的阻塞
      - 线程已经在内核态运行并开始对调度器或输入输出对象执行操作了。它将不能继续执行，所以线程会请求调度程序代码寻找装载下一个线程的CONTEXT记录去恢复其执行
    - 线程向一个对象发信号（如发一个信号或者唤醒一个事件）时
      - 线程也是在内核中运行。但是，在向一些对象发出信号之后，它肯定还能够继续执行，因为发信号对象从来没有受到阻塞
    - 配额过期
      - 内核态发生中断，这时线程执行调度程序代码找到下一个运行的线程
- 在另外两种情况下，调度程序也会被调度
  - 一个输入输出操作完成时
    - 线程可能处于等待输入输出时被释放然后执行
  - 等待时间结束时
    - 线程一斤对一个信号量进行了down操作或者因一些其他对象而被阻塞，但是定时器已经过期
    - 如果一个线程在这个时刻已到就绪，则调度程序将会被唤醒并且如果新的可运行线程有较高的优先级，那么和情形1的情况类似，当前的线程会被抢占
- 具体的调度算法
  - Win32 API提供两个API来影响线程调度
  - 首先，有一个叫SetPriorityClass的用来设定被调用进程中所有线程的优先级
    - 其等级可以是：
      - 实时
      - 高
      - 高于标准
      - 标准
      - 低于标准
      - 空闲
  - 第二个就是SetThreadPriority
    - 它根据进程的优先级来设定进程中每个线程的相对优先级
    - 可换分如下等级
      - 紧要的
      - 最高的
      - 高于标准的
      - 标准的
      - 低于标准的
      - 最低的
      - 休眠的
  - 进程优先级等级和相对线程优先级的使用能够更容易地确定应用程序的优先级
- 调度程序按照下列方式进行调度
  - 依照图11-27的表格，进程优先级和相对线程优先级的组合形成了32个绝对线程优先级
  - 在表格的数字决定了线程的基本优先级（base priority）
  - 除此之外，每条线程都有当前优先级（current priority）
  - Win32优先级到Windows优先级的映射

![11-27](F:\现代操作系统\resource\11-27.jpg)

- 为了使用这些优先级进行调度，系统维护一个包含32个线程列表的队列，分别对应图11-27的0~31的不同等级
  - 每个列表包含了就绪线程对应的优先级
  - 基本的调度算法是从优先级队列中从31到0的从高优先级到低优先级的顺序查找
  - 调度取决于线程而不是取决于线程所属的进程
- 为了改进在具有大量处理器的多处理器情况下的调度算法的可伸缩性，调度管理器尽力不给全局的优先级表的数组加上一个全局的锁实现同步访问控制
  - 对于每一个进程，调度管理器都维护一个理想处理器（ideal processor）记录，它会尽可能的时候让线程在这个理想处理器上运行
- 队首的队列在图11-28中表示
  - 这个图表明了实际上有四类：实时级、用户级、零页和空闲级，即当它为-1时有效
  - 优先级16~31属于实时级的一类，用来为构建满足实时性约束的系统

![11-28](F:\现代操作系统\resource\11-28.jpg)

- 用户态下不能运行实时级的线程
  - 把优先级设置为实时级的权限，需要启用进程令牌中相应的特权
  - 通常用户没有这个特权
- 应用程序的线程通常在优先级1~15上运行
  - ZeroPage系统线程运行在优先级0并且把所有要释放的页转化为全部包含0的页
  - 每一个实时的处理器都有一个独立的ZeroPage线程
- 用于决定一个线程在32个列表中的那一个列表进行排队的优先级取决于当前优先级，通常是得到和当前线程的基本优先级一样的优先级，但并不总是这样
- 一个线程在什么样的时机会得到提升
  - 首先，当输入输出操作完成并且唤醒一个等待线程的时候，优先级一下子被提高，给她一个快速运行的机会，这样可以使更多的I/O可以得到处理
  - 其次，如果一个线程在等待信号量，互斥量同步或其他的事件，当这些条件满足线程被唤醒的时候，如果它是前台的进程的话，这个线程就会得到两个优先级的提升，其他情况则只提升一个优先级
  - 提升不是永远的
    - 如果一个线程用完它的时间分配量，它就会降低一个优先级而且排在新优先级队列的队尾
  - 还有一种情况就是系统变动（fiddle）优先级
    - 在特定的时刻，生产者已经把共享的缓冲区填满，信号量发生阻塞，如图11-29a所示
    - 如图11-29b所示，在消费者得到调度再次运行之前，一个无关的线程在优先级8已就绪得到调度运行
    - Windows通过一个称为大hack来解决此类问题的
      - 系统记录一个已就绪的线程自从上次得到运行后距离当前的时间有多久
    - 这一问题广为人知地称作优先级倒转（priority inversion）

![11-29](F:\现代操作系统\resource\11-29.jpg)

- 在优先级为16条线程获得互斥量却长时间调度的时候会发生一个类似的问题，致使更重要的系统该线程由于等待互斥量而不能运行发生饥饿
  - 这一问题在操作系统里通过在那些只需要短时间拥有互斥量的线程在很忙时禁用调度来解决
- 时间配额值
  - 在Windows客户端系统上，默认值是20毫秒
  - 在Windows服务器系统上，它是180毫秒
- 最后对调度算法来说，当新窗口变成前台窗口的时候，它的全部在窗口中注册的线程都会得到一个较长的时间配额

## 11.5 内存管理

- Windows Vista有一个极端复杂的虚拟内存系统。这一系统包括了大量Win32函数，这些函数通过内存管理器（NTOS执行层最大的组件）来实现

### 11.5.1 基本概念

- 在Windows Vista系统中，每个用户进程都有它自己的虚拟地址空间。
  - 对于x86机器，虚拟地址是32位的
    - 因此，每个进程拥有4GB大小的虚拟地址空间
  - 对于x64位上的x64机器而言，地址可以是32位的也可以是64位的
- 图11-30表示了三个x86进程的虚拟地址
  - 每个进程的底部和顶端64KB的虚拟地址空间通常保留不用
  - 从64KB开始为用户私有的代码和数据
    - 最顶端的2GB包含了操作系统
    - ​


![11-29](F:\现代操作系统\resource\11-30.jpg)

- 当运行在内核态的时候，Windows允许线程访问其余的地址空间

#### 1. 虚拟地址分配

- 虚拟地址的每页处于三种状态之一：
  - 无效
    - 无效页面（invalid page）是指一个页面没有被映射到一个内存区对象（section object），对它的访问会引发一个对象的页面失效
  - 保留
    - 保留（reserved）的虚拟页时无效的，但是这些页面不能被内存管理器用于其他目的而分配
  - 提交
    - 一旦代码或数据被映射到虚拟页面，就说一个页面处于提交（committed）状态
- soft fault，软异常
  - 页面失效的发生也可能是页表正在更新造成的，即物理仍在内存的高速缓存中，这种情况下不需要进行I/O
- 除了无效、保留、提交状态，页面还有其他的属性：
  - 可读
  - 可写
  - 可运行（在AMD64兼容的处理器下）

#### 2. 页面文件

- pagefile，页面文件
  - 已提交页面没有被映射于特定文件
- 问题是该如何以及何时把虚拟页映射到页面文件的特定位置
  - 当一个页被提交时，为虚拟页分配一个硬盘上页面文件中的页
  - Windows使用一个适时（just-in-time）策略
    - 直到需要被换出内存之前，在页面文件中的具体空间不会分配给已提交的页面
- 同过实时分配的策略，总的虚拟内存大小是物理内存和页面文件大小的总和
- 有关请求调页，需要马上进行初始化从硬盘读取页的请求
  - 因为在页入（page-in）操作完成之前，遇到玉面失效的线程无法继续运行下去
  - 对于失效页面的一个可能的优化是
    - 在进行一次I/O操作时预调入一些额外的页面
  - 分配页面文件空间的适时策略
    - 修改过的页面被集中在一起，统一进行写入操作
- standby list，后备链表
  - 如果一个页面从没被修改过，它将会进入到一个空闲物理页面的列表中去
  - 这个表中的页面可以不用写回硬盘而在此被使用
- Windows支持多达16个页面文件，通常覆盖 到不同过的磁盘来达到较高的I/O带宽
  - 操作系统通过为进程的私有页写入映射信息到页表入口，或与原页表入口相对应的共享页的内存区对象，来跟踪虚拟页与页面文件的映射关系
  - 程序文件中的可执行代码和只读数据（例如EXE或DLL）可以映射到任何进程正在使用的地址空间
  - 有时候页面开始时为只读但是最终被修改
  - Windows支持写时复制（copy-on-write）类型的页面
  - 除了从EXE和DLL文件映射程序代码和数据，一般的文件都可以映射到内存中，使得程序不需要进行显式的读写操作就可以从文件引用数据
- 内存区对象并不一定和文件有关
  - 它们可以和匿名内存区域有关

#### 3. 物理内存寻址

- 人们努力想出各种技术使得程序可以使用更多的物理内存，而不是去适应有限的地址空间
  - 这些技术通常基于存储器转换（bank switching）
- 一些像SQL数据库这样的大型应用软件恰恰被设计成运行在一个单一进程的寻址空间中，因此存储器组转换已经过时了，取代它的是地址窗口扩展（Address Winding Extensions，AWE）
  - 这种机制允许程序（以正确的特权级运行）去请求物理内存的分配

### 11.5.2 内存管理系统调用

- Win32 API包含了大量的函数来支持一个进程显式地管理它自己的虚拟内存
  - 其中最重要的函数如图11-31所示

![11-31](F:\现代操作系统\resource\11-31.jpg)

- 前四个API函数是用来分配、释放、保护和查询虚拟地址空间中的区域的
  - 操作系统柜强加了一个限制来防止一个进程过于“贪婪”：
    - 这些页面能够移出内存，但是仅仅在整个进程被替换出内存的时候才能这么做
- 列出的最后四个API函数是用来管理内存映射文件的
  - 为了映射一个文件，首先必须创建一个文件映射对象（见图11-23）

![11-23](F:\现代操作系统\resource\11-23.jpg)

- 接下来的两个函数从一个进程的虚拟地址空间中映射或取消映射内存区对象之上的视图
- 最后一个API能被一个进程用来映射其他进程通过调用CreateFileMapping创建并共享出来的映射，这样的映射通常是为了映射匿名内存而存在的

### 11.5.3 存储管理的实现

- 运行在x86处理器上的Windows Vista操作系统更为每个进程都单独提供了一个4GB大小的按需分页（demand-paged）的线性地址空间，不支持任何形式的分段
  - 操作系统可以使用4MB的页来改进处理器存储管理单元中的快表（Transaction Lookaside Buffer，TLB）的效率
- 调度器选择单个线程来运行而不太关心进程
  - 存储管理器则不同，它完全是在处理进程而不太关心线程


- 当虚拟地址空间中的一片区域被分配之后，就像图11-32中进程A被分配了4片区域那样，存储管理器会为它创建一个虚拟地址描述符（Virtual Address Descriptor，VAD）
  - VAD列出了被映射地址的范围，用来表示作为后备存储的文件以及文件被映射区域起始位置的节区以及权限
  - 图11-32 被映射的区域以及它们在磁盘上的”影子“页面。lib.dll文件被同时映射到两个地址空间中

![11-32](F:\现代操作系统\resource\11-32.jpg)

#### 1. 页面失效处理

- SuperFetch，超级预读取
  - 超级预读取技术尝试预先读入很多需要的页面到内存中，尽管进程尚未在这些页面上发生页面失效
    - 这一技术通过重叠从磁盘上读入页面和执行映像中的初始化代码，减小了启动应用程序所需的延时
  - 进程预约式页面调度（prepaging）技术也用到了系统启动、把后台应用程序移到前台以及休眠之后重启系统当中
- 存储给管理器支持预约式页面调度，但是它被实现成系统中一个单独的组件
  - 未被映射的页面没有被通过读取文件来初始化
  - 存储管理器中的按需分页时通过页面失效来驱动的
- 不同处理器体系结构下的页表项的格式可能会不同
  - 对于x86和x64，一个被映射页面的页表项如图11-33所示
  - 页表项中有两个重要的位是直接由硬件更新的，它们是访问位（access bit）和脏位（dirty bit）
    - 存储管理器可以使用访问位来实现（Least-Recently Used，最近最少使用）类型的页面替换策略

![11-33](F:\现代操作系统\resource\11-33.jpg)

- 正如表11-33所示，x86体系结构通常使用32位大小的页表项，而x64体系结构使用64位大小的页表项

  - x86体系结构也支持一种特殊的物理地址扩展（Physical Address Extension，PAE）

- 每个页面失效都可以归入以下五类中的一类

  - 所引用的页面没有提交
  - 尝试违反权限的页面访问
  - 修改一个共享的写时复制页面
  - 需要扩大栈
  - 所引用的页已经提交但是当前没有映射


  - 第一种情况和第二种情况是由于编程错误引起
    - access violation，访问违例
  - 第三种情况与第二种情况有相同的症状（试图写一个只读的页面），但是处理方式是不一样的
  - 第四种情况在线程向栈中压入一个值，而这个值会被写到一个还没有被分配的页面的情况下发生
  - 第五种情况就是常见的页面失效
    - 如果该页是由文件映射的，内存管理器必须查找该页与内存区对象结合在一起的原型页表等类似的数据结构，从而保证在内存中不存在该页的副本
    - 如果内存管理器能够从内存中找到需要的页而不是去磁盘查找从而响应页面失效，则称为软异常（soft fault）
      - 如果需要从磁盘进行复制，则称为硬异常（hard fault）

- 当一个物理页面不在映射到任何进程的页表中，将进入一下三种状态之一：空闲、修改或后备

  - 内存管理器可以根据需要从空闲链表或者后备链表中分配页面
    - Windows Vista中预约式调页机制通过读入那些未来可能会用到的页面并把它们插入后备链表的方式将硬异常转化为软异常

- 图11-33中的页表项指的是物理页号，而不是虚拟页号

  - 为了更新页表项，内核需要使用虚拟地址
    - Windows使用如图11-34所示的页目录表项中的自映射表项将当前进程的页表和页目录映射到内尺虚拟地址空间
    - 通过映射页目录项到页目录（自映射），就具有了能用来指向页目录项（图11-34a）和页表项（图11-34b）的虚拟地址

![11-34](F:\现代操作系统\resource\11-34.jpg)

#### 2. 页面置换算法

- 当空闲物理页面数量降到较低时，内存管理器开始从内核态的系统进程以及用户态进程移走页面
  - Windows通过大量使用工作集来解决这一问题
  - 每个进程的工作集由两个参数描述：最小值和最大值
  - 只有当系统中的可用物理内存降得很低的时候才会器作用
- 工作集管理器具有三级基于定时器的周期活动
  - 大量的可用内存：扫描页面，复位页面的访问位，并使用访问位的值来表示每个页面的新旧程度。在每个工作集内保留使用一个估算数量的未使用页面
  - 内存开始紧缩：对每个具有一定比例未用页面的进程，停止为工作集增加页面，同时在需要增加一个新的页面的时候换出最旧的页面。换出的页面进入后备或者已修改链表
  - 内存紧缩：消减（也即减小）工作集，通过移除最旧的页面从而降低工作集的最大值
- 平衡管理器（balance set manager）线程调用工作集管理器，使得其每秒都在运行

#### 3. 物理内存管理

- 上面提到了物理页面的三种不同链表，空闲链表、后备链表和已修改链表。
  - 除此之外还有第四种链表，即全部被填零的空闲页面
  - 另外还有第五种链表存放硬件错误的页面（即通过硬件错误检测）
- 系统中的所有页面要么是由一个有效的页表项索引，要么属于以上五种链表中的一种，它们的全体称为页框号数据库（PFN数据库）
  - 图11-35表明PFN数据库的结构

![11-35](F:\现代操作系统\resource\11-35.jpg)

- 该表格有物理页框号索引
  - 工作集中的页面指出哪个表项索引它们
  - 此外还有一个指向链表中下一个页面的指针（如果有的话），以及其他的若干诸如正在进行读和写的域以及标志位等
- 工作集管理器和其他的系统线程控制页面在工作集和不同链表间移动
  - 这一转变在图11-36的（1）中进行了说明

![11-36](F:\现代操作系统\resource\11-36.jpg)

- 这两个链表中的页面仍然是有效的页面，但页面失效发生的时候需要它们中的一个页，则将该页移回工作集而不需要进行I/O操作（2）
- 当一个进程退出，该进程的非共享页面不能通过异常机制回到以前的工作集，因此该进程表中的有效页面以及挂起和已修改链表中的页面都移入空闲链表（3）
  - 其他的系统调用会引起别的转变
- 两个系统线程——映射页面写入器（mapped page writer）和已修改页面写入器（modified page writer），周期性地被唤醒来检查是否系统中有足够的干净页面
  - 如果没有，这两个线程从已修改链表的顶部取出页面，写回到磁盘，然后将这些页面插入后备链表（4）
  - 之所以使用两个线程是因为映射文件可能会因为写的结果增长，而增长的结果就需要对磁盘上的数据结构具有相应的权限来分配空闲磁盘块
- 下面说明图11-36中另一个转换
  - 如果进程解除页映射，该页不再和进程相关从而进入空闲链表（5）
  - 当页面失效会请求一个页框给将要读入的页，此时该页框会尽可能从空闲表中取下（6）
- 栈的增长则是另一种情况
  - 称为零页面线程（ZeroPage thread）的低优先级内核线程（参见图11-28）将空闲链表中的页面写全零并将页面放入全零页链表（7）

![11-28](F:\现代操作系统\resource\11-28.jpg)

- 所有这些链表的存在导致了一些微妙的策略抉择
  - Windows通过算法、启发、猜测、历史、经验以及管理员可控参数的配置来做权衡
  - 总而言之，内存管理需要一个拥有多种数据结构、算法和启发性的十分复杂、重要的构件
    - 在真实的系统里，内存管理不仅仅是一个简单的时钟或老化的页面算法

## 11.6 Windows Vista的高速缓存

- Windows高速缓存（Cache）通过把最近和经常使用的文件片段存在内存中的方式来提升文件系统的性能
  - 高速缓存管理器管理的是虚拟寻址的数据块，也就是文件片段
  - 高速缓存的文件片段称为视图（view）
    - 这是因为它们代表了被映射到文件系统的文件上的内核虚拟地址片段
- Windows的高端缓存管理工具在文件系统中被广泛地共享
  - 这是因为高速缓存是根据独立的文件来虚拟寻址的
- 除了对内核虚拟地址和用来缓存的物理内存资源的管理外，考虑到视图的一致性，大批量磁盘写回，以及文件结束标志的正确维护（特别是当文件拓展的时候），高速缓存管理器还必须与文件系统协作
- 高速缓存管理器是如何工作的
  - 当一个文件被引用时，高速缓存管理器映射一块大小为256KB的内核虚拟地址空间给文件
  - 文件一旦被映射，高速缓存管理器通过把内核虚拟地址空间复制到用户缓冲区的方式来满足对该数据库的请求
  - 除了在内核和用户缓冲区之间复制的页面，高速缓存管理器也为映射到虚拟内存的页面和依靠指针访问的页面服务
- 高速缓存不一定适合所有的应用程序
  - 大型企业应用程序，如SQL，希望自己来管理高速缓存和I/O
  - 从历史上来看，这类应用程序使用一个可增长的用户态虚拟地址空间来替代操作系统提供的高速缓存
  - 因此，系统支持一种配置，使得重新启动后能给应用程序提供所需的3GB的用户态地址空间，而只使用1GB的地址空间用于内核态来代替2-GB/2-GB的传统分割
- Windows在系统中引入了一种全新的、有别于高速缓存管理器的缓存技术，称为ReadyBoost
  - 用户可以在USB接口或其他端口插入闪存，并命令操作系统使用闪存作为一个通写缓存
  - ReadyBoost压缩数据（通常为2倍），并加密
  - 通写方式对闪存被拔除时减少数据丢失很重要，但未来的PC硬件可能在主板上直接集成闪存

## 11.7 Windows Vista的输入/输出

- Windows I/O管理器提供了灵活的、可拓展的基础框架，以便有效地管理非常广泛的I/O设备和服务，支持自动的设备识别和驱动程序安装（即插即用）及用于设备和CPU的电源管理
  - 以上均基于异步结构使得计算可以与I/O传输重叠

### 11.7.1 基本概念

- I/O管理器与即插即用管理器紧密联系
  - 即插即用背后的基本思想是一条可枚举总线
  - 需要即插即用管理器，总线驱动程序（确实在枚举的总线），和I/O管理器之间的密切协作
- 在Windows中，所有与硬件无关的程序，如文件系统、反病毒过滤器、卷管理器、网络协议栈，甚至内核服务，都是用I/O驱动程序来实现的
- Windows的一个有趣的特点是支持动态磁盘（dynamic disk）
  - 这些磁盘可以跨越多个分区，或多个磁盘，甚至无需重新启动在使用中就可以重新配置
  - 从I/O到卷可被一个特殊的Windows驱动程序过滤产生卷阴影副本（Volume Shadow Copies）
    - 过滤驱动程序创建一个可单独挂载的，并代表某一特定时间点的卷快照
    - 阴影副本对精确备份服务器系统也很有价值
    - 应用程序参与快照过程，因此一旦发生故障，备份反映的是一个非常易于恢复的状态
- 另一方面，Windows支持异步I/O
  - 有各种不同的方法使线程可以发现该I/O操作是否已经完成
    - 一是启动I/O操作的同时指定一个事件对象，然后等待它结束
    - 另一种方法是指定一个队列，当I/O操作完成时，系统将一个完成事件插入到队列中
    - 三是提供一个回调函数，I/O操作完成时供系统调用
    - 四是在内存中开辟一块区域，当I/O操作完成时由I/O管理器更新该区域
  - 我们要讨论的最后一种方法，是由Windows Vista提出的I/O优先级
    - I/O优先级是由发起I/O操作的线程来确定的，或者也可以明确指出
    - 共有5个优先级
      - 关键
      - 高
      - 正常
      - 低
      - 非常低
    - 关键级别为内存管理器预留，以避免系统经历极端内存压力时出现死锁现象
    - 低和非常低的优先级为后台进程所使用
    - 大部分I/O操作的优先级是正常级别
    - 但是为了避免小故障，多媒体应用程序也可标记它们的I/O优先级为高

### 11.7.2 输入/输出API调用

- 由I/O管理器提供的API与大多数操作系统提供的API并没有很大的不同
  - 基本操作有open、read、write、ioctl和close，以及即插即用和电源管理、参数设置、刷新系统缓冲区等
  - 在Win32层，这些API被包装成接口，向特定的设备提供了更高一级的操作
  - 在底层，这些API打开设备，并执行这些基本类型的操作
- 保持了Windows一贯的通用哲学，原生NT I/O系统调用带有很多参数并包括很多变种
  - 图11-37列出了I/O管理器中主要的系统调用接口

![11-37](F:\现代操作系统\resource\11-37.jpg)

- NtCreateFile用于打开已经存在的或者新的文件
  - NtReadFile和NtWriteFIle需要文件句柄、缓冲区和长度等参数
  - NtQuerydirectoryFile是一个在执行过程中访问或修改指定类型对象信息的标准模式的一个例子
    - 在本例中，指定类型的对象是指与某些目录相关的一些文件对象
  - NtQueryVolumeInformationFile很像是目录查询操作，但是与目录查询操作不同的是，它有一个参数是打开的卷的文件句柄，不管这个卷是否有文件系统
  - NtSetVolumeInformationFile单独用于修改参数
  - NtNotifyChangeDirectoryFile提供了取消未处理I/O操作的功能，其中包括支持文件系统强行卸载有未处理I/O操作的卷的功能
  - NtQueryInformationFile是一个用于查询目录中指定文件的信息的系统调用
    - 还有一个与它对应的系统调用：NtSetInformationFile
      - 这些接口用于访问和修改文件的各种相关信息
- 这些系统调用本质上是特定于文件的ioctl的一种形式
  - 它们也可以被用来重新命名NTFS上的交换数据流（见11.8节）
- 存在独立的API（NtLockFIle和NtUnlockFIle）用来设置和删除文件中字节域的锁
  - NtFSControlFile和前面提到的查询和设置操作很像，但是他是一个旨在处理特定文件的操作，其他的API并不适合处理这种文件
- 最后，还有一些其他的系统调用，比如NtFlushBuffersFile
  - 像UNIX的sync系统调用一样，它强制把文件系统数据写回到磁盘
  - NtCancelIoFile用于取消对一个特定文件的外部I/O请求
  - NtDeviceIoControlFIle实现了对设备的ioctl操作
- 有一些系统调用用于按文件名删除文件，并查询特定文件的属性
  - 还有一些用于处理I/O完成端口的系统调用

### 11.7.3 I/O实现

- Windows I/O系统由即插即用服务、电源管理器、I/O管理器和设备驱动模型组成

#### 1. 设备驱动程序

- 为了确保设备驱动程序能和Windows Vista的其余部分协同工作，微软公司定义了设备驱动程序需要符合的WDM（Windows驱动程序模型）
  - 大部分Windows驱动程序的开发过程都是先复制一份合适的简单的驱动程序
- 微软公司也提供了一个驱动程序验证器，用以验证驱动程序的多个行为以确保驱动程序符合Windows驱动程序模型的结构要求和I/O请求的协议要求、内存管理等
- 微软建立了一个叫做WDF（Windows驱动程序基础）的包装系统，它运行在WDM项层，简化了很多更普通的需求，主要和驱动程序与电源管理和即插即用操作之间的正确交互有关
- 为了进一步简化编写驱动程序，也为了提高系统的健壮性，WDF包含UMDF（用户模式驱动程序架构），使用UMDF编写的驱动程序作为在进程中执行的服务
  - 还有KMDF（内核模式驱动程序架构），使用过KMDF编写的驱动程序作为在内核中执行的服务，但是也使得WDM中的很多细节变得不可预料
- 在Windows中，设备是由设备对象描述的
  - 这些设备对象都是由Windows中的设备栈来描述组织的，见前面的图11-16

![11-16](F:\现代操作系统\resource\11-16.jpg)

- I/O操作从I/O管理器调用可执行API IoCallDriver程序开始，IoCallDriver带有指向顶层设备对象和描述I/O请求的IRP的指针
- 图11-38表示的是一个设备栈在单独一层上的关系

![11-38](F:\现代操作系统\resource\11-38.jpg)

- 一旦驱动程序完成处理IRP描述的请求后，它将有三种选择
  - 第一，驱动程序可以再一次调用IoCallDriver，把IRP和设备栈中的下一个设备对象传递给响应的驱动程序
  - 第二，驱动程序也可以声明I/O请求已经完成并返回到调用者
  - 第三，驱动程序还可以在内部对IRP排队并返回到调用者，同时声明I/O请求仍未处理

#### 2. I/O请求包

- 图11-39表示的是IRP中主要的域
  - IRP的底部是一个动态大小的数组，包含哪些被设备栈管理请求的域，每个驱动程序都可以使用这些域

![11-39](F:\现代操作系统\resource\11-39.jpg)

- 当I/O管理器分配一个IRP时，为了分派一个足够大的IRP，它必须知道这个设备栈的深度
- IRP包含标志位、索引到驱动程序分派表的操作码、指向内核与用户缓冲区的指针和一个MDL（内存描述符列表）列表
  - MDL用于描述由缓冲区描述的物理内存框，也就是用于DMA操作
  - 还有一个连接域用于连接所有的外部IRP到初始化它们的线程

#### 3. 设备栈（Device Stack）

- Windows Vista中的驱动程序可以自己完成所有的任务，如图11-40所示的打印机驱动程序
  - 另一方面，驱动程序可以堆叠起来，即一个请求可以在一组驱动程序之间传递，每个驱动程序完成一部分工作

![11-40](F:\现代操作系统\resource\11-40.jpg)

- 堆叠驱动程序的一个常见用途是将总线管理与控制设备的功能性工作分离
  - Windows为其中的通用部分提供了公共的驱动程序
- 堆叠设备驱动程序的另一个用途是将过滤驱动程序（filter driver）插入到驱动栈中
- 内核态设备驱动程序是影响Windows的可靠性和稳定性的严重问题
  - 因为内核态设备驱动程序与内核及执行层使用相同的地址空间，驱动程序中的错误可能破坏内核数据结构，甚至更糟
- I/O模型是强大而且灵活的，但是几乎所有的I/O都是异步的，因此系统中会大量存在竞态条件（race condition）
- 电源管理器集中管理整个系统的电源使用
  - 早期的电源管理包括关闭显示器和停止磁盘旋转以降低电源消耗
  - 更新一些的电源管理设施可以在系统没有被使用的时候，通过切换设备到后备状态甚至通过使用软电源开关（soft power switch）将设备完全关闭来降低部件功耗
  - 在多处理器中，可以通过关闭不需要的CPU来减少功耗
  - Windows支持一种特殊的关机模式——休眠，该模式将物理内存复制到磁盘，然后把电离消耗降低到很低的水平（笔记本电脑在休眠状态下可以运行几个星期），电池的消耗也变得十分缓慢
  - 另一种可选择的模式是待机模式，电源管理器将整个系统降到最低的功率状态，仅使用足够的RAM刷新的功率

## 11.8 Windows NT文件系统

- Windows Vista支持若干种文件，其中最重要的是FAT-16、FAT-32和NTFS（NT文件系统）
- 因为NTFS文件系统是一个带有很多有趣的特性和创新设计的现代文件系统，在本章中我们将针对NTFS文件系统进行讨论

### 11.8.1 基本概念

- NTFS限制每个独立的文件名最多由255个字符组成；全路径名最多有32767个字符
  - 文件名采用Unicode编码，允许非拉丁语系国家的用户用他们的母语为文件命名
  - NTFS完全支持区分大小写的文件名
    - 但是对一般用户而言，这是很不方便的，例如，现在的互联网在很大程度上是不区分大小写的
- 与FAT-32和UNIX文件不同，NTFS文件并不只是字节的一个线性序列，而是一个文件由很多属性组成，每个属性由一个字节流表示
  - 每个流有一个由文件名、一个冒号和一个流名组成的名字
  - 苹果的Macintosh的文件系统为每个文件使用两个流，一个数据分支（data fork）和一个资源分支（resource fork）
- 与UNIX文件系统类似，NTFS是一个层次化的文件系统
  - 名字的各部分之间用"\"分隔，而不是“/”，这是从MS-DOS时代与CP/M相兼容的需求中继承下来的
- 从Windows Vista开始，NTFS才开始支持符号连接
  - 在Vista中符号链接的实现用到了一个叫再解析点（reparse points）的NTFS特性

### 11.8.2 NTFS文件系统的实现

- NTFS文件系统是专门为NT系统开发的，用来替代OS/2中的HPFS文件系统的
  - 它是一个具有很高复杂性和精密性的文件系统
- 接下来，我们将从NTFS结构开始，探讨一系列NTFS特性，包括文件名查找、文件压缩、日志和加密

#### 1. 文件系统结构

- 每个NTFS（如磁盘分区）都包含文件、目录、位图和其他数据结构
  - 每个卷被组织成磁盘块的一个线性序列（在微软的术语中叫“簇”），每个卷中块的大小是固定的
- 每个卷中的主要数据结构叫MFT（主文件表，Master File Table），该表是以1KB为固定大小的记录的线性序列
  - 有时候会需要两个或更多的MFT记录来保存所有块的地址列表
    - 第一个MFT记录叫做基本记录（base record）
  - MFT本身就是一个文件，可以被放在卷中的任何位置，这样就避免了在第一磁道上出现错误扇区引起的问题
- 图11-41是一个MFT
  - 每个MFT记录由数据对（属性头，值）的一个序列组成
  - 如果属性值足够短能够放到MFT记录中，那么就把它放到记录里。这叫做直接文件（immediate file）


![11-41](F:\现代操作系统\resource\11-41.jpg)

- 最开始的16个MFT记录为NTFS元数据文件而预留，如图11-41所示

  - 第一个记录描述了 MFT 文件本身。 
  - 记录 1 是 MFT 文件早期部分的复制
  - 记录 2 是一个 Log 文件。 
  - 记录 3 包含了卷的信息，比如大小、卷标和版本。
  - 接下来是根目录，根目录本身是一个文件并且可以变为任意长度。 MFT 记录 5 用来描述根目录。
  - 卷里的空余空间通过一个位图来跟踪。这个位图本身是一个文件，它的磁盘地址和属性由 MFT 记录 6 给出。
  - 下一个 MFT 记录指向引导装载程序。记录 8 用来把所有的坏块链接在一起来确保不会有文件使用它们。
  - 记录 9 包含安全信息。
  - 记录 10 用于大小写映射。 
  - 记录 11 是一个目录包含杂项文件用于磁盘配额、对象标识符、再解析点，等等
  - 最后四个MFT记录被留作将来使用

- 每个 MFT 记录由一个记录头和后面跟着的（属性头，值）对组成。 

  - NTFS 定义了 13 个属性能够出现在 MFT 记录中。图 11-42 列出了这些属性。


  - 通常，属性值直接跟在它们的属性头后面，但是如果一个值对于一个 MFT 记录太长的话，它可能被放在不同的磁盘块中。
    - 这样的属性称作非常驻属性，数据属性很明显就是这样一个属性

![11-42](F:\现代操作系统\resource\11-42.jpg)

- 标准的信息域包含文件所有者、安全信息、 POSIX 需要的时间戳、硬连接计数、只读和存档位，等等
  - 在 NT4.0 中，安全信息被放在一个属性中，但在 Windows 2000 及以后的版本中，安全信息全部都放在一个单独的文件中使得多个文件可以共享相同的安全描述
  - 当属性不能全部放在 MFT 记录中时，就需要使用属性列表
  - 就像 UNIX 文件拥有一个 I 节点号一样， NTFS 文件也有一个ID
- 重解析点告诉分析文件名的过程来做特别的事
  - 这个机制用于显式加载文件系统和符号链接
- 最后，我们关注最重要的属性：数据流（在一些情况下叫流）
  - 对于每个流，流的名字（如果有）会在属性头中。
  - 存储了实际流数据的 MFT 记录称为立即文件
- 当然，大多数情况下，数据放不进一个 MFT 记录中，因此这个属性通常是非常驻属性

#### 2. 存储分配

- 保持对磁盘中在可能的情况下，连续分配的块进行跟踪的模型，这是出于效率的原因
- 一个流中的块是通过一串记录描述的，每个记录描述了一串逻辑上连续的块，对于一个没有孔的流来说，只有唯一的一个记录
  - 有孔的文件称为稀疏文件。
  - 每个记录始于一个头，这个头给出第一个块在流中偏移量
  - 每个记录的头后面跟着一个或多个对，每个对给出了磁盘地址和持续长度。
- 图11-43描述了用这种方式表示的三段、 9 块的流。
  - 在这个图中，有一个 9 个块（头， 0 ～ 8）的短流的MFT记录
  - 它由磁盘上三个行串的连续块组成
  - 每一个行串被记录在MFT记录中的一个（磁盘地址，块计数）对中

![11-43](F:\现代操作系统\resource\11-43.jpg)

- 有必要在这里做几点说明
  - 首先，用这种方法表达的流的大小没有上限限制
  - 其次，表示每一对的直接了当的方法会占用2×8个字节，有压缩方法可以把一对的大减小到低于16字节
    - 从图11-44可以看出，一个文件的首MFT记录是102，对于一个MFT记录而言它有太多的行串，因而它会计算需要多少个扩展的MFT记录

![11-44](F:\现代操作系统\resource\11-44.jpg)

- 注意，图11-44包含了一些多余的信息
  - 列出这些信息是为了更有效地搜索：
    - 找到在一个给定文件偏移量的块，只需要去检查记录头，而不是行串对
- 有可能会出现这样的问题：
  - 如果文件需要的MFT记录太多，以至于首个MFT记录中没有足够的空间去存放所有的索引
  - 解决这个问题的方法是：
    - 使扩展的MFT记录列表成为非驻留的（即：存放在其他的硬盘区域而不是在首个MFT记录中）
  - 图11-45表示了一个MFT表项如何描述一个小目录
    - 这个记录包含若干目录项，每个目录项可以描述一个文件或目录 

![11-45](F:\现代操作系统\resource\11-45.jpg)

- 大目录采用一种不同的格式，即用B+树而不是线性结构来列出文件
  - 通过B+树可以按照字母顺序查找文件
- 现在又足够的信息去描述使用文件名对\??\C:\foo\bar的查找是如何进行的
  - 从图11-22可以知道Win32、原生NT系统调用、对象和I/O管理器如何协作通过向C盘的NTFS设备栈（device stack）发送I/O请求打开一个文件

![11-22](F:\现代操作系统\resource\11-22.jpg)

- NTFS从C盘根目录开始分析\foo\bar路径，C盘的块可以在MFT中的第五个表项中找到（参考图11-41）
  - 找到文件bar后，NTFS在I/O管理器返回的文件对象上设置指针指向它自己的元数据
  - 一旦文件成功打开，NTFS调用IoCompleteRequest，它通过把IPR沿I/O栈向上传递给I/O和对象管理器
  - 最终，这个文件对象的句柄被放进当前进程的句柄表中，然后回到用户态
  - 之后调用ReadFile时，应用程序能够提供句柄，该句柄表明C：\foo\bar文件对象应该包含在传到到C:设备栈给NTFS的读请求中

![11-41](F:\现代操作系统\resource\11-41.jpg)

- 除了支持普通文件和目录外，NTFS支持像UNIX那样的硬连接，也通过一个叫做重解析点的机制支持符号连接
  - 重解析点也用来为文件系统过滤器驱动程序而标记个别文件
    - 在图11-22中显示了文件系统过滤器如何安装到I/O管理器和文件系统之间

![11-22](F:\现代操作系统\resource\11-22.jpg)

#### 3. 文件压缩

- NTFS 支持透明的文件压缩。 
- 压缩流程是这样的：
  - 当 NTFS 写一个有压缩标志的文件到磁盘时，它检查这个文件的前 16 个逻辑块，而不管它们占用多少个项，然后对它们运行压缩算法，如果压缩后的数据能够存放在 15 个甚至更少的块中，压缩数据将写到硬盘中；如果可能的话，这些块在一个行串里。如果压缩后的数据仍然占用 16 个块，这 16 个块以不压缩方式写到硬盘中。  
- 图 11-46a 显示一个文件。该文件的前 16 块被成功地压缩到了 8 个，对第二个 16 块的压缩没有成功，第三个 16 块也压缩了 50%。  
  - “丢失”的块用磁盘地址 0 存放在 MFT 表项中，如图 11-46b 所示。 
  - 当读文件时， NTFS 需要分辨某个行串是否被压缩过，它可以根据磁盘地址进行分辨，如果其磁盘地址是 0，表明它是 16 个被压缩的块的最后部分。  

![11-46](F:\现代操作系统\resource\11-46.jpg)

- 随机访问压缩文件也是可行的，但是需要技巧 
  - 选择16 个块作为压缩单元是一个折衷的结果，短了会影响压缩效率，长了则会使随机访问开销过大。

####4. 日志

- NTFS 支持两种让程序探测卷上文件和目录变化的机制。
  - 第一种机制是调用名为NtNotifyChange Directory File 的I/ O 操作，传递一个缓冲区给系统，当系统探测到目录或者子目录树变化时， 
  - 第二种机制是 NTFS 变化日志。 NTFS 将卷上的目录和文件的变化记录保存到一个特殊文件中，程序可以使用特殊文件系统控制操作来读取，即调用 API NtFsControlFile 并以 FSCTL_QUERY_USN_JOURNAL 为参数。  

####5. 文件加密 

- Windows 加密的通常方式是将重要目录标识为加密的，然后目录里的所有文件都会被加密，新创建或移动到这些目录来的文件也会被加密。
  - 加密和解密不是 NTFS 自己管理的，而是由EFS（ Encryption File System）驱动程序来管理，EFS作为回调向 NTFS 注册。 
- EFS 为特殊文件和目录提供加密。
  - 在 Windows Vista中还有另外一个叫做BitLocker的加密工具，它加密了卷上几乎所有的数据。 

## 11.9 Windows Vista中的安全 

- NT 的最初设计符合美国国防部 C2 级安全需求（ DoD 5200.28-STD），该橘皮书是安全的DoD系统必需满足的标准
- 很多安全特性，包括下面的几个：
  - 1) 具有反欺骗措施的安全登录。 
  - 2) 自主访问控制。 
  - 3) 特权化访问控制。 
  - 4) 对每个进程的地址空间保护
  - 5) 新页被映射前必需清空
  - 6) 安全审计。 
- 让我们来简要地回顾一下这些条目
  - 安全登录意味着系统管理员可以要求所有用户必需拥有密码才可以登录
  - 欺骗是指一个恶意用户编写了一个在屏幕上显示登录提示的程序然后走开以期望一个无辜的用户会坐下来并输入用户名和密码
- Windows Vista 通过指示用户按下 CTRL-ALT-DEL 登录来避免这样的攻击 
- 自主访问控制允许文件或者其他对象的所有者指定谁能以何种方式使用它。特权化访问控制允许系统管理员（超级用户）随需覆盖上述权限设定。 
- Windows Vista 提供了一些工具，当笔记本被盗或者丢失时，谨慎的用户可以利用它们最小化损失。 

### 11.9.1 基本概念

- 每个 Windows Vista 用户（和组）用一个 SID（ Security ID，安全 ID）来标识。 SID 是二进制数字，由一个短的头部后面接一个长的随机部分构成。  

- 每个进程拥有一个指定了SID和其他属性的访问令牌。 

- 图11-47展示了令牌的格式。 

  - 令牌的头部包含了一些管理性的信息。
  - 过期时间字段表示令牌何时不再有效，但当前并没有使用该字段。
  - 组字段指定了进程所隶属的组。 
    - POSIX 子系统需要该字段。默认的DACL（Discretionary Access Control List，自主访问控制列表）会赋给被进程创建的对象，如果没有指定其他ACL 的话。 

  - 受限 SID 使得不可信的进程以较少的权限参与到可信进程的工作中，以免造成破坏


  - 最后，权限字段，如果有的话，赋予进程除普通用户外特殊的权利，比如关机和访问本来无权访问的文件的权利。实际上，

![11-47](F:\现代操作系统\resource\11-47.jpg)

- 当用户登录时，winlogon赋予初始的进程一 访问令牌。后续的进程一般会将这个令牌继承下去。 
  - 一个客户端线程可以将访问权限传递给服务器线程，从而使得服务器可以访问客户端的受保护的文件和其他对象。这种机制叫做身份 (impersonation） 
- 另一个基本的概念是安全描述符（ security descriptor）。 
  - 安全描述由一个头部和其后带有一个或多个访问控制口（ Access Control Entry，ACE）的 DACL 组成。 
  - ACE 主要有两类：允许项和拒绝项。
    - 允许项含有一个 SID 和一个表示带有此 SID 的进程可以执行哪些操作的位图。
    - 拒绝项与允许项相同，不过其位图表示的是谁不可以执行那些操作。 
- 图 11 -48 描述了这个简单的例子 
  - 除 DACL 外，安全描述符还包含一个系统访问控制列表（System Access Control List， SACL）  
  - SACL 跟DACL很相似，不过它表示的并不是谁可以使用对象，而是哪些对象访问操作会被记录在系统范围内的安全事件日志中。 

![11-48](F:\现代操作系统\resource\11-48.jpg)

### 11.9.2 安全相关的API调用 

- Windows Vista 的访问控制机制大都基于安全描述符。 
- 大部分 Win32 API 安全调用跟安全描述符的管理相关，因此在这里主要关注它们。
  - 图 11-49 列出了那些最重要的调用
  - 为了创建安全描述符，首先要分配存储空间，然后调用 Initialize Security Descriptor 初始化它
  - 随后 SID 被插入到安全描述符中。 

![11-49](F:\现代操作系统\resource\11-49.jpg)

- 这时可调用 InitializeAcl初始化安全描述符的DACL（或者 SACL ）
  -  ACL入口项可通过 AddAccess AllowedAce 和AddAccessDeniedAce。 
  -  可调用DeleteAce来删除一个入口项，这用来修改已存在的 ACL而不是构建一个新的 ACL
  -  SetSecurity DescriptorDacl可以把一个准备就绪的 ACL 与安全描述符关联到一起

### 11.9.3 安全性的实现

- 在独立的 Windows Vista 系统中，安全由大量的组件来实现，我们已经看过了其中大部分组件（网络是完全不同的事情，超出了本书的讨论范围）。
  - 登录和认证分别由 winlogon 和 lsass 来处理。登录成功后会获得一个带有访问令牌的 GUI shell 程序（ explorer.exe）。  
- 一旦用户登录成功，每当打开对象进行访问就会触发安全操作。 
- 正如已经看到的那样，除允许项外， DACL 还包括拒绝项。 
- 对象被打开后，调用者会获得一个句柄。 
  - 另外，正如 SACL所要求的那样，在句柄上进行的调用可能会导致产生审计日志。 
- Windows Vista 增加了另外的安全设施来应对使用ACL保护系统的共同问题。 
  - 进程的令牌中含有新增加的必需的完整性级别（Integrity-Level）SID 字段并且对象在SACL 中指定了一个完整性级别ACE。 
- 近年来 Windows 增加了很多其他的安全特性。 
  - 在 AMD64体系结构中一种叫做 NX 的设施可限制执行栈上的代码。 
- Windows Vista 引入了更多的安全特性来阻止攻击者。 
  - 在微软公司称为用户账户控制（ User Account Control， UAC）的引入是另一个改变。 
  - 这用来解决大部分用户以管理员身份运行系统这个长期的问题。 
  - 如果有 UAC，当尝试执行需要管理员访问权限的操作 
  - 系统会显示一个重叠的特殊桌面并且接管控制权，使得只有用户的输入可以授权这次访问（与 C2 安全中 CTRL-ALT-DEL 的工作方式类似）。 
- Windows Vista 中最后的一个安全特性已经提到过了。这就是对具有安全边界的受保护进程（ protected process）的支持。 
  - 由于世界范围内越来越多的针对 Windows 系统的攻击，近年来微软公司加大了提高Windows 安全性的努力

## 11.10 小结

- Windows Vista中内核态由HAL、NTOS的内核和执行体层以及大量实现了从设备服务到文件系统、从网络到图形的设备驱动程序组成
  - HAL对其他组件隐藏了硬件上的某些差异
  - 内核层管理CPU以支持多线程和同步，执行体实现大多数的内核服务态服务
- 执行体基于内核态的对象，这些对象代表了关键的执行体数据结构，包括进程、线程、内存区、驱动程序、设备以及同步对象等