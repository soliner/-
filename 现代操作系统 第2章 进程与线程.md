第二章 进程与线程

- 进程是操作系统提供的最古老的也是最重要的抽象概念之一
- 它们将一个单独的CPU变换成多个虚拟的CPU

2.1 进程

- 所有现代的计算机经常会在同一时间做许多件事
- 伪并行：在任何多道程序设计系统中，CPU由一个进程快速切换至另一个进程，使每个进程各运行几十或几百个毫秒
- 多处理器系统的真正硬件并行

2.1.1 进程模型

- 在进程模型中，计算机上所有可运行的软件通常也包括操作系统，被组织成若干顺序进程（sequential process），简称进程（process）
- 一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值
- 每个进程拥有它自己的虚拟CPU
- CPU只能真正一次运行一个进程，即使有2个核，每一个核也只能一次运行一个进程
- 在对进程编程是绝不能对时序做任何确定的假设
- 一个进程是某种类型的一个活动，它有程序、输入、输出以及状态

2.1.2 创建进程

- 操作系统需要有一种方式创建进程
- 有4种主要事件导致进程的创建：
  - 系统初始化
  - 执行了正在运行的进程所调用的进程创建系统调用
  - 用户请求创建一个新进程
  - 一个批处理作业的初始化
- 启动操作系统时，通常会创建若干个进程
  - 停留在后台处理诸如电子邮件、Web页面、新闻、打印机之类活动的进程称为守护进程（daemon）
    - 在大型系统中通常有很多守护进程
    - 在UNIX中国，可以用ps程序列出正在运行的进程
    - 在Windows中，可使用任务管理器
- 新的进程也可以以后创建
  - 一个正在运行的进程经常发出系统调用，以便创建衣蛾或多个新进程协助其工作
  - 在所要从事的工作可以容易地划分成若干相关的但没有相互作用的进程时，创建新的进程就特别有效果
- 在交互式系统中，键入一个命令或者（双）击一个图标就可以启动一个程序
- 用户在大型机的批处理系统中提交批处理作业，在操作系统认为有资源可运行另一个作业时，它创建一个新的进程
- 从技术上看，在所有这些情形中，新进程都是由于一个已存在的进程执行了一个用于创建进程的系统调用而创建的
  - 在UNIX系统中，只有一个系统调用可以用来创建新进程：fork
    - 这个系统调用会创建一个与调用进程相同的副本
    - 通常，子进程接着执行execve或一个类似的系统调用，以修改其存储映像并运行一个新的程序
  - 在Windows中，一个Win32函数调用CreateProcess既处理进程的创建，也负责把正确的程序装进新的进程。
    - 该调用有10个参数，
      - 要执行的程序、
      - 输入给该程序的命令行参数、
      - 各种安全属性、
      - 有关打开的文件是否继承的控制位、
      - 优先级信息、
      - 为该进程所需要创建的窗口规格
      - 指向一个结构的指针
- 在UNIX和Windows中，进程创建之后，父进程和子进程有各自不同的地址空间
  - 在UNIX中，子进程的初始地址空间是父进程的一个副本
  - 在Windows中，从一开始父进程的地址空间和子进程的地址空间就不同的

2.1.3 进程的终止

- 进程终止通常由下列条件引起：
  - 正常退出（自愿的）
    - 多数进程是由于完成了它们的工作而终止。
      - 当编译器完成了所给定程序的编译之后，编译器执行一个系统调用 ，通知操作系统它的工作已经完成
      - UNIX中该调用exit
      - Windows中，相关的调用是ExitProcess
        - 字处理软件、Internet浏览器和类似的程序中总有一个供用户点击的图标或菜单项，用来通知进程删除它所打开的任何临时文件，然后终止。
  - 出错退出（自愿的）
    - 进程发现了严重错误
      - 编译器退出
      - 面向屏幕的交互式进程通常并不退出
  - 严重退出（非自愿）
    - 进程引起的错误，通常是由于程序中的错误所致
      - 有些系统中（如UNIX），进程可以通知操作系统，它希望自行处理这些类型的错误
  - 被其他进程杀死（非自愿）
    - 某个进程执行一个系统调用通知操作系统杀死某个其他进程
      - 在UNIX中，这个系统调用是kill
      - Win32中对应的函数是TerminateProcess

2.1.4 进程的层次结构

- 某些系统中，当进程创建了另一个进程后，父进程和子进程就以某种形式继续保持关联
- 子进程自身可以创建更多的进程，组成一个进程的层次结构
- 在UNIX中，进程和它的所有子女以及后裔共同组成一个进程组
- UNIX在启动时初始化，init的特殊进程出现在启动映像中，所有的进程都属于以init为根的一棵树
- Windows中没有进程层次的概念，所有的进程都是地位相同的
  - 在创建进程的时候，父进程得到句柄，可以用来控制子进程

2.1.5 进程的状态

- 进程之间需要相互作用
  - 一个进程的输出结果可能作为另一个进程的输入。
    - cat chapter1 chapter2 chapter3|grep tree
- 当一个进程在逻辑上不能继续运行时，它就会被阻塞
- 进程的三种状态
  - 运行态（该时刻进程实际占用CPU）
  - 就绪态（可运行，但因为其他进程正在运行而暂时停止）
  - 阻塞态（除非某种外部事件发生，否则进程不能运行）
- 进程的三种状态之间有四种可能的转换关系
  - 进程为等待输入而阻塞
    - 在操作系统发现进程不能继续运行下去时，发生转换1
  - 调度程序选择另一个进程
    - 由进程调度程序引起
    - 系统认为一个运行进程占用处理器的时间已经过长，决定让其他进程使用CPU时间
  - 调度程序选择这个进程
    - 进程调度程序引起
    - 在系统已经让所有其他进程享有了它们应有的公平待遇而重新轮到第一个进程再次占用CPU运行时
  - 出现有效输入
    - 当进程等待的一个外部事件发生时（如一些输入到达）
- 调度程序的主要工作就是决定应当运行哪个进程、何时运行及它应该运行多长时间
- 使用进程模型使得我们易于想象系统内部的操作状况
  - 一些进程正在运行执行用户键入命令所对应的程序
  - 另一些进程是系统的一部分，完成下列一些工作：
    - 执行文件服务请求
    - 管理磁盘驱动器
    - 磁带机的运行细节
- 操作系统的最底层是调度程序

2.1.6 进程的实现

- 为实现进程模型，操作系统维护着一张表格（一个结构数组），即进程表（process table）
- 每个进程占用一个进程表项，表项包含了
  - 进程状态的重要信息
    - 程序计数器
    - 堆栈指针
    - 内存分配状况
    - 所打开文件的状态
    - 账号和调度信息
  - - 其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息
    典型的进程表项中的一些字段

  进程管理有关的字段	存储管理有关的字段	文件管理有关的字段
    进程管理   	  存储管理   	  文件管理   
     寄存器   	  正文段指针  	   根目录   
    程序计数器  	  数据段指针  	  工作目录   
    堆栈指针   	  堆栈段指针  	  文件描述符  
    进程状态   	         	  用户ID   
     优先级   	         	   组ID   
    调度参数   	         	         
    进程ID   	         	         
     父进程   	         	         
     进程组   	         	         
     信号    	         	         
   进程开始时间  	         	         
  使用的CPU时间 	         	         
  子进程的CPU时间	         	         
   下次报警时间  	         	         

- 与每一I/O类关联的是一个称作中断向量（interrupt vector）的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地址。
- 所有的中断都从保存寄存器开始
- 当里程结束后，它调用一个C过程处理某个特定的中断类型剩下的工作
- 中断发生后操作系统最底层的工作步骤：
  - 硬件压入堆栈程序计数器等
  - 硬件从中断向量装入新的程序计数器
  - 汇编语言过程保存寄存器值
  - 汇编语言过程设置新的堆栈
  - C中断服务例程运行（典型地读和缓冲输入）
  - 调度程序决定下一个将运行的进程
  - C过程返回至汇编代码
  - 汇编语言过程开始运行新的当前进程
- 当该进程结束时，操作系统显示一个提示符并等待新的命令。一旦它接到新命令，就装入新的程序进行内存，覆盖前一个程序

2.1.7 多道程序设计模型

- 采用多道程序设计可以提高CPU的利用率
- 从概率的角度来看CPU的利用率。
  - 假设一个进程等待I/O操作的时间与其停留在内存中时间的比为p。
  - 当内存中同时有n个进程时，则所有n个进程都在等待I/O（此时CPU空转）的概率是p^n。
  - CPU的利用率由下面的公式给出：CPU利用率=·1-p^n
- 以n为变量的函数表示了CPU的利用率，n称为多道程序设计的道数（degree of multiprogramming）
- 从完全精确的角度考虑，应该指出此概率模型只是描述了一个大致的状况
  - 进程不是独立的
  - 更精确的模型应该用排队论构造，但我们的模型仍然是有效的

2.2 线程

- 在传统操作系统中，每个进程有一个地址空间和一个控制线程
- 经常存在在同一个地址空间中准并行运行多个控制线程的情形

2.2.1 线程的使用

- 迷你进程（称为线程）的必要性
  - 并行实体共享同一个地址空间和所有可用数据的能力。对于某些应用而言，这种能力是必需的
    - 在许多应用中同时发生着多种活动，其中某些活动随着时间的推移会被阻塞
    - 通过将这些应用程序分解成可以准并行运行的多个顺序线程
  - 由于线程比进程更轻量级，所以他们比进程更容易（即更快的）创建，也更容易撤销
    - 在有大量线程需要动态和快速修改时，具有这一特性是很有用的
  - 性能方面的考虑
    - 如果存在着大量的计算和大量的I/O处理，拥有多个线程允许这些活动彼此重叠进行
- 字处理软件
  - 使用三个线程
    - 第一个线程只是和用户交互
    - 第二个线程在得到通知时进行文档的重新格式化
    - 第三个线程周期性地将RAM中的内容写到磁盘上
- Web服务器可以把获得大量访问的页面集合保存在内存中，避免到磁盘去调入这些页面，额从而改善性能。这样的一种页面集合称为高速缓存（cache）
  - 一个称为分派程序（dispatcher）的线程从网络读入工作请求
  - 在检查请求之后，分派线程挑选一个空转的（即被阻塞的）工作线程（worker thread），提交该请求，通常是在每个线程所配有的专门字中写入一个消息指针
  - 接着分派线程唤醒睡眠的工作线程，将它从阻塞状态转为就绪状态
  - 在线程被唤醒之后，它检查有关的请求是否在Web页面高速缓存之中，这个高速缓存时所有线程都可以访问的
  - 如果没有，该线程开始一个从磁盘调入页面的read操作，并阻塞直到该磁盘操作完成
  - 这种模型允许把服务器编写为顺序线程的一个集合
- 没有多线程的情形下，即单线程
  - 使其像一个线程一样运行
  - 在请求到来是，这个唯一的线程对请求进行考察
- 每个计算都有一个被保存的状态，存在一个会发生且使得相关状态发生改变的事件集合，我们把这类设计称为有限状态机（finite-state machine）
  构造服务器的三种方法
     模型  	      特性      
     多线程 	  并行性、阻塞系统调用  
    单线程进程	 无并行性、阻塞系统调用  
    有限状态机	并行性、非阻塞系统调用、中断

2.2.2 经典的线程模型

- 进程模型基于两种独立的概念：资源分组处理与执行
  - 理解进程的一个角度是，用某种方法把相关的资源集中在一起。
    - 进程有存放程序正文和数据以及其他资源的地址空间
    - 资源中包括打开的文件、子进程、即将发生的报警、信号处理程序、账号信息等
  - 进程拥有一个执行的线程，通常简写为线程（thread）
    - 在线程中有一个程序计数器，用来记录接着要执行哪一条指令
    - 线程拥有寄存器，用来保存线程当前的工作变量
    - 线程还拥有一个堆栈，用来记录执行历史，其中每一帧保存了一个已调用的但是还没有从中返回的过程
    - 进程用于把资源集中在一起，而线程则是在CPU上被调度执行的实体
  - 线程给进程模型增加了一项内容，即在同一个进程环境中，允许彼此之间有较大独立性的多个线程
    - 由于线程具有进程的某些性质，所以有时被称为轻量级进程（lightweight process）
    - 多线程用来描述在同一个进程中允许多个线程的情形
    - 一些CPU有直接硬件支持多线程，并允许线程切换在纳秒级完成
  - 在多线程在单CPU系统中运行时，线程轮流运行。
  - 进程中的不同线程不像不同进程之间那样存在很大的独立性。
    - 所有的线程都有完全一样的地址空间，这意味着它们也共享同样的全局变量
    - 线程之间是没有保护的
      - 不可能
      - 也没有必要

  在一个进程中所有线程共享的内容	每个线程自己的内容
     每个进程中的内容    	每个线程中的内容 
       地址空间      	  程序计数器  
       全局变量      	   寄存器   
       打开文件      	   堆栈    
        子进程      	   状态    
      即将发生的报警    	         
     信号与信号处理程序   	         
       账户信息      	         

- 与传统进程一样（即只有一个线程的进程），线程可以处于若干中状态的任何一个：运行、阻塞、就绪或终止。
  - 正在运行的线程拥有CPU并且是最活跃的
  - 被阻塞的线程等待某个释放它的事件
  - 就绪线程可被调度运行，并且只要轮到它就很快可以运行
- 每个线程有其自己的堆栈，每个线程的堆栈有一帧，供各个被调用但是还没有从中返回的过程使用
  - 在该帧中存放了相应过程的局部变量以及过程调用完成之后使用的返回地址
- 在多线程的情况下，进程通常会从当前的单个线程开始
  - 这个线程有能力通过调用一个库函数（如thread_create）创建新的线程
  - thread_create的参数专门制定了新线程要运行的过程名
  - 当一个线程完成工作后，可以通过调用一个库过程（如thread_exit）退出
  - 在某些线程系统中，通过调用一个过程，例如thread_join，一个线程可以等待一个（特定）线程退出
  - 线程调用thread_yield，它允许线程自动放弃CPU从而让另一个线程运行
- 线程也在程序设计模式中引入了某种程度的复杂性
  - 父进程与子进程的多个线程
  - 线程共享许多数据结构的事实

2.2.3 POSIX线程

- 为实现可移植的线程程序，IEEE在IEEE标准1003.1c中定义了线程的标准
  - 它定义的线程包叫做Pthread
  - 大部分UNIX系统都支持该标准
  - 这个标准定义了超过60个函数调用
  -           线程调用        	      描述       
         Pthread_create   	    创建一个新线程    
          Pthread_exit    	    结束调用的线程    
          Pthread_join    	  等待一个特定的线程退出  
         Pthread_yield    	释放CPU来运行另外一个线程 
       Pthread_attr_init  	创建并初始化一个线程的属性结构
      Pthread_attr_destroy	  删除一个线程的属性结构  
  - 所有Pthread线程都有某些特性
    - 每一个含有一个标识符、一组寄存器（包括程序计数器）和一组存储在结构中的属性
    - 这些属性包括堆栈大小、调度参数以及使用线程需要的其他项目
  -     #include <pthread.h>
        #include <studio.h>
        #include <stdlib.h>
        
        #define NUMBER_OF_THREADS
        
        void *print_hello_world(void *tid)
        {
          /*本函数输出线程的标识符，然后退出*/
          printf("Hello World. Greetings from thread %d0, tid");
          pthread_exit(NULL)；
        }
        int main(int argc,char *argv[])
        {
          /* 本函数创建10个线程，然后退出*/
          pthread_t threads[NUMBER_OF_THREADS];
          int status, i;
          for(i=0;i<NUMBER_OF_THREADS;i++){
            printf("Main here. Creating thread %d0,i);
            status = pthread_create(&threads[i],NULL,print_hello_world,(void *)i);
             if(status != 0){
                     printf("Oops,pthread_create returnd error code %d0,status");
              exit(-1);
             }
          }
          exit(NULL);
        }
    - 主程序宣布它的意图之后，循环NUMBER_OF_THREADS次，每次创建一个新的线程
    - 如果线程创建失败，会打印出一条错误信息然后退出
    - 在创建完所有线程之后，主程序退出

2.2.4 在用户空间中实现线程

- 有两种主要的方法实现线程包：
  - 在用户空间中
    - 把整个线程包放在用户空间中，内核对线程包一无所有
    - 这种方法第一个，也是最明显的优点是，用户级线程可以在不支持线程的操作系统上实现
    - 线程在一个运行时系统的顶部运行，这个运行时系统是一个管理线程的过程的集合
    - 在用户管理线程时，每个进程需要其专用的线程表（thread table），用来跟踪该进程中的线程
      - 表和内核中的进程表类似，不过它仅仅记录各个线程的属性
        - 程序计数器、堆栈指针
        - 寄存器
        - 状态
    - 当某个线程做了一些会引起在本地阻塞的事情之后，它调用一个运行时系统的过程，这个过程检查该线程是否必须进入阻塞状态
    - 在线程完成时，pthread_yield代码可以把线程的信息保存到线程表中
      - 保存该线程状态的过程和调用程序都只是本地过程，所以启动它们比进行内核调用效率更高
    - 用户级线程还有另一个优点，它允许每个进程有自己定制的调度算法
    - 尽管用户级线程包有更好的性能，但也存在一些明显的问题
      - 如何实现阻塞系统调用
        - 系统调用可以全部改成非阻塞的
        - 如果某个调用会阻塞，就提前通知
      - 页面故障问题
        - 如果某个程序调用或者跳转到了一条不在内存的指令上，这就称为页面故障
      - 如果一个线程开始运行，那么在该进程中的其他线程就不能运行，除非第一个线程自动放弃CPU
        - 让运行时系统请求每秒一次的时钟信号（中断），但是这样对程序也是生硬和无序的
  - 在内核中

2.2.5 在内核中实现线程

- 在内核中有用来记录系统中所有线程的线程表
- 内核的线程表保存了每个线程的寄存器、状态和其他信息
- 所有能够阻塞线程的调用都以系统调用的形式实现
  - 由于在内核中创建或撤销线程的代价比较大，某些系统采取“环保”的处理方式，回收其线程
- 内核线程不需要任何新的、非阻塞系统调用
  - 系统调用的代价比较大，所以如果线程的操作（创建、终止等）比较多，就会带来很大的开销

2.2.6 混合实现

- 人们研究了各种试图将用户级线程的优点和内核级线程的优点结合起来的方法
  - 使用内核级线程，然后将用户级线程与某些或者全部内核线程多路复用起来
    - 内核只识别内核级线程，并对其进行调度，其中一些内核级线程会被多个用户级线程多路复用
    - 每个内核级线程有一个可以轮流使用的用户级线程集合

2.2.7 调度程序集合进程

- 调度程序激活（scheduler activation）
  - 工作的目标是模拟内核线程的功能，但是为线程包提供通常在用户空间中才能实现的更好的性能和更大的灵活性
  - 由于避免了在用户空间和内核空间之间的不必要转换，从而提高了效率
  - 当使用调度程序激活机制时，内核给每个进程安排一定数量的虚拟处理器，并且（用户空间）运行时系统将线程分配到处理器上
  - 该机制工作的基本思路是，当内核了解到一个线程被阻塞之后，内核通知该进程的运行时系统
    - 内核通过在一个已知的起始地址启动运行时系统，从而发出了通知，这是对UNIX中信号的一种粗略模拟。这种机制称为上行调用（upcall）
  - 运行时系统重新调度其线程，这个过程通常是这样的：把当前线程标记为阻塞并从就绪表中取出另一个线程，设置其寄存器，然后再启动之
  - 在某个用户线程运行的同时发生一个硬件中断时，被中断的CPU切换进核心态
  - 调度程序激活机制的一个目标是作为上行调用的信赖基础，这是一种违反层次系统内在结构的概念

2.2.8 混合实现

- 如何处理到来的消息
- 传统的方法是将进程或线程阻塞在一个receive系统调用上，等待消息到来
- 一个消息的到达导致系统创建一个处理该消息的线程，这种线程称为弹出式线程
  - 关键好处是，没有必须存储的寄存器、堆栈诸如此类的内容，每个线程从全新开始，每个线程彼此之间完全一样
  - 结果是，消息到达与处理开始之间时间非常短
- 在内核空间中运行弹出式线程通常比在用户空间中容易且快捷，而且内核空间中的弹出式线程很容易访问所有的表格和I/O设备，这些也许在中断处理时有用

2.2.9 使单线程代码多线程化

- 代码
  - 一个线程的代码就像进程一样，通常包含多个过程，会有局部变量、全局变量和过程参数
  - 线程使用全局变量所引起的错误
    - 全面禁止全局变量
    - 为每个线程赋予其私有的全局变量
    - 引入新的库过程，以便创建、设置和读取这些线程范围的全局变量
      - 该调用在堆上或在专门为调用线程所保留的特殊存储区上替一个名为bufptr的指针分配存储空间
      - 访问全局变量需要两个调用：
        - 写入全局变量
        - 读取全局变量
      - 这个调用返回一个存储在全局变量中的地址，这样就可以访问其中的数据
  - 有许多库过程并不是可重入的
    - 不是设计成这样的方式的：对于任何给定的过程，当前面的调用尚没有技术之前，可以进行第二次调用
    - 重写整个库
    - 为每个过程提供包装器
      - 但是会极大地降低系统潜在的并行性
    - 有些信号逻辑上是线程
- 信号
  - 有些信号逻辑上是线程专用的，但是另一些却不是
    - 有些信号，如键盘中断，则不是线程专用的

2.3 进程间通信

- 进程间通信（Inter Process Communication，IPC）
  - 一个进程如何把信息传递给另一个
  - 确保两个或更多的进程在关键活动中不会出现交叉
  - 与正确的顺序有关

2.3.1 竞争条件

- 在一些操作系统中，协作的进程可能共享一些都能读写的公用存储区
- 例子
  - 当一个进程需要打印一个文件时，它将文件名放在一个特殊的假脱机目录（spooler directory）
  - 设想假脱机目录中有许多槽位，编号依次为0,1,2，...，每个槽位存放一个文件名。
    - 同时假设有两个共享变量：out，指向下一个要打印的文件；in，指向目录中下一个空闲槽位
    - 可以把这两个变量保存在一个所有进程都能访问的文件中，该文件的长度为两个字
    - 在Murphy法则（任何可能出错的地方终将出错）生效时，可能发生以下的情况下
      - 两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，称为竞争条件（race condition）

2.3.2 临界区

- 避免竞争条件，我们需要的是互斥（mutual exclusion），即以某种手段确保当一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作
- 避免竞争条件的问题也可以用一种抽象的方式进行描述
  - 对共享内存进行访问的程序片段称作临界区域（critical region）或临界区（critical section）
  - 对于一个好的解决方案，需要满足以下4个条件：
    - 任何两个进程不能同时处于其临界区
    - 不应对CPU的速度和数量做任何假设
    - 临界区外运行的进程不得阻塞其他进程
    - 不得使进程无期限等待进入临界区

2.3.3 忙等待的互斥

- 本节将讨论几种集中实现互斥的方案
- 屏蔽中断
  - 在单处理器系统中，最简单的方法是使每个进程在刚刚进入临界区后立即屏蔽所有中断，并在就要离开之前再打开中断
  - 这个把屏蔽中断的权力交给用户进程是不明智的
    - 结果整个系统可能会因此终止
    - 如果系统是多处理器，则屏蔽中断仅仅对disable指令的那个CPU有效
    - 屏蔽系统对于操作系统本身而言是一项很有用的技术，但对于用户进程则不是一种合适的通用互斥机制
- 锁变量
  - 一种软件解决方案
  - 0表示临界区没有进程，1表示已经有某个进程进入临界区
- 严格轮换法
  - 对于编写操作系统而言，C语言是强大、有效、可预知和有特性的语言
  - 对于Java，它就是不可预知的，因为它在关键时刻会用完存储器，而在不合适的时候会调用垃圾收集程序回收内存
  - 连续测试一个变量直到某个值出现为止，称为忙等待（busy waiting）
    - 只有在有理由认为等待时间是非常短的情形下，才使用忙等待。
    - 用于忙等待的锁，称为自旋锁（spin lock）
  - 违反了条件3
- Peterson解法
  - 该算法由两个用ANSI C编写的过程组成
  - ANCI C要求为所定义和使用的所有函数提供函数原型
  -     #define FALSE 0
        #define TRUE 1
        #define N 2//进程数量
        
        int turn;//现在轮到谁？
        int interested[N];//所有值初始化为0（FALSE）
        
        void enter_region(int process)//进程是0或1
        {
          int other;//其他进程号
          
          other = 1-process;//另一方进程
          interested[process]=TRUE;//表明所感兴趣的
          turn=process;//设置标志
          while(turn == process&&interested[other]==TRUE);//空语句
        }
        
        void leave_region(int process)//进程：谁离开？
        {
          interested[process] = FALSE；//表示离开临界区
        }
  - 使用共享变量（即进入其临界区）之前，各个进程使用其进程号0或1作为参数来调用enter_region
    - 该调用在需要时将使进程等待，直到能安全地进入临界区
  - 在完成对共享变量的操作之后，进程将调用leave_region
    - 表示操作已完成，若其他的进程希望进入临界区，则现在就可以进入
- TSL指令
  - 现在来看需要支持的一种方案
  - TSL RX,LOCK，称为测试并加锁（Test and Set Lock）
    - 它将一个内存字lock读到寄存器RX中，然后再该内存地址上存一个非零值
    - 该指令结束之前其他处理器均不允许访问该内存字
  - 为了使用TSL指令，要使用一个共享变量lock来协调对共享内存的访问
    - 当lock为0时，任何进程都可以使用TSL指令将其设置为1，并读写共享内存
    - 当操作结束时，进程用一条普通的move指令将lock的值重新设置为0
  - 防止两个进程同时进入临界区
    -     enter_region;
          	TSL REGISTER,LOCK
          	TSL REGISTER,#0
          	JNE enter_region
          	RET
          	
          leave_region;
          	MOVE LOCK,#0
          	RET
          	
    - 一个可替换TSL的指令是XCHG，它原子性地交换了两个位置的内容
      - 所有的Intel x86 CPU在低层同步中使用XCHG指令

2.3.4 睡眠与唤醒

- Peterson解法和TSL或XCHG解法都是正确的，但它们都有忙等待的缺点
  - 本质上是：当一个进程想进入临界区时，先检查是否允许进入，若不允许，则该进程将原地等待，直到允许为止
- 优先级反转问题（priority inversion problem）
- 进程间通信原语
  - sleep是一个将引起调用进程阻塞的系统调用，即被挂起，直到另外一个进程将其唤醒
  - wakeup调用有一个参数，即要被唤醒的进程
  - 另一种方法是让sleep和wakeup各有一个参数，即有一个用于匹配sleep和wakeup的内存地址
- 生产者-消费者问题
  - 生产者-消费者（production consumer）问题，也称作有界缓存区（bounded-buffer）问题
  - 两个进程共享一个公共的固定大小的缓冲区
    - 其中一个是生产者，将信息放入缓冲区
    - 另一个是消费者，从缓冲区取出信息
  - 问题在于当缓冲区已满，而此时生产者还向其中放入一个新的数据项的情况
    - 让生产者睡眠，待消费者从缓冲区中取出一个或多个数据项时再唤醒它
  - 包含于前边假脱机目录问题一样的竞争条件
    -     #define N 100//缓冲区中的槽数目
          int count = 0;//缓冲区中的数据项数目
          
          void producer(void)
          {
            int item;
            
            while(TRUE){//无限循环
              item = produce_item();//产生下一新数据项
              if(count == N)sleep();//如果缓冲区满了，就进入休眠状态
              insert_item(item);//将（新）数据项放入缓冲区中
              count = count + 1;//将缓冲区的数据项计数器增1
              if(count == 1)wakeup(consumer);//缓冲区空吗？
            }
          }
          
          void consumer(void)
          {
            int item;
            
            while(TRUE){//无限循环	
              if(count == 0)sleep();//如果缓冲区空，则进入休眠状态
              item = remove_item();//从缓冲区中取出一个数据项
              count = count-1;//将缓冲区的数据项计数器减1
              if(count == N-1)wakeup(producer);//缓冲区满吗？
              consume_item();//打印数据项
            }
          }
          
      
    - 为了跟踪缓冲区中的数据项，我们需要一个变量count
      - 生产者
        - 如果缓冲区最多存放N个数据项，则生产者将首先检查count是否达到N，若是，则生产者睡眠；
        - 否则生产者向缓冲区中放入一个数据项并增量count的值
      - 消费者
        - 首先测试count是否为0，若是0，则睡眠
        - 否则从中取走一个数据项并递减count的值
  - 可能会出现竞争条件
    - 原因是对count的访问未加限制
    - 问题的实质在于发给一个（尚）未睡眠进程的wakeup信号丢失了
      - 一种快速的弥补方法是修改规则，加上一个唤醒等待位
      - 这并没有从根本上解决问题

2.3.5 信号量

- 信号量
  - 使用一个整型变量来累计唤醒次数，供以后使用
  - 新的变量类型，称作信号量（semaphore）
    - 一个信号量可以为0（表示没有保存下来的唤醒操作）或者为正值（表示有一个或多个唤醒操作）
    - 设立两种操作：
      - down
      - up
      - 分别一般化后的sleep和wakeup
  - down
    - 对一信号量执行down操作，则是检查其值是否大于0
      - 若改值大于0，则将其值减1
      - 若该值为0，则进程将睡眠
    - 检查数值、修改变量值以及可能发生的睡眠的操作均作为一个单一的、不可分割的原子操作完成
    - 原子性对于解决同步问题和避免竞争条件是绝对必要的
      - 原子操作，是指一组相关联的操作要么都不间断地执行
      - 原子操作在计算机科学的其他领域也是非常重要的
  - up
    - 该操作对信号量的值增1
- 用信号量解决生产者-消费者问题
  - 用信号量解决丢失的wakeup问题
  - 为确保信号量能正确工作，最重要的是要采用一种不可分割的方式来实现它
  - 如果使用多个CPU，则每个信号量应由一个锁变量进行保护
    - 通过TSL或XCHG指令来确保同一时刻只有一个CPU在对信号量进行操作
  - 该解决方案使用了三个信号量：
    - 一个称为full，用来记录充满的缓冲槽数目
      - 初值为0
    - 一个称为empty，记录空的缓冲槽总数
      - 初值为缓冲区中槽的数目
    - 一个称为mutex，用来确保生产者和消费者不会同时访问缓冲区
      - 初值为1
  - 二元信号量（binary semaphore）：供两个或多个进程使用的信号量，其初值为1，保证同时只有一个进程可以进入临界区
  - 在使用信号量的系统中，隐藏中断的最自然的方法是为每一个I/O设备设置一个信号量，其初值为0
  - 信号量mutex用于互斥，它用于保证任一时刻只有一个进程读写缓冲区和变量相关的变量
- 信号量的另一用途是用于实现同步（synchronization）
  - 信号量full和empty用来保证某种事件的顺序发生或不发生

2.3.6 互斥量

- 如果不需要信号量的计数能力，有时可以使用信号量的一个简化版本，称为互斥量（mutex）
  - 仅仅适用于管理共享资源或一小段代码
  - 互斥量是一个可以处于两态之一的变量：解锁和加锁
- 在（用户）线程中，情形有所不同，因为没有时钟停止运行时间过长的线程。
- 互斥量系统是一套调用框架
  - 对于软件来说，总是需要更多的特性，而同步原语也不例外
- Peterson算法、信号量或公共缓冲区中，如何共享turn变量
  - 有些共享数据结构，如信号量，可以存放在内核中，并且只能通过系统调用来访问
  - 多数现代操作系统（包括UNIX和Windows）提供一种方法，让进程与其他进程共享其部分地址空间
- Pthread中的互斥
  - Pthread提供许多可以用来同步线程的函数
    - 其基本机制是使用一个可以被锁定和解锁的互斥量来保护每个临界区
    - 一些与互斥量相关的pthread调用
    -   线程调用                 	描述         
        pthread_mutex_init   	创建一个互斥量    
        pthread_mutex_destroy	撤销一个已存在的互斥量
        pthread_mutex_lock   	获得一个锁或阻塞   
        pthread_mutex_trylock	获得一个锁或失败   
        pthread_mutex_unlock 	释放一个锁      
  - 除互斥量之外，pthread提供了另一种同步机制：条件变量
    - 互斥量在允许或阻塞对临界区的访问上是很有用的，条件变量则允许线程由于一些未达到的条件而阻塞
  - 线程、互斥量、条件变量之间的关联：
    - 一个线程将产品放在一个缓冲区内，另一个线程将它们取出
      线程调用                  	描述              
      pthread_cond_init     	创建一个条件变量        
      pthread_cond_destory  	撤销一个条件变量        
      pthread_cond_wait     	阻塞以等待一个信号       
      pthread_cond_signal   	向另一个线程发出信号来唤醒它  
      pthread_cond_broadcast	向多个线程发信号来让它们全部唤醒

2.3.7 管程

- 两个进程永远的阻塞下去，无法再进行有效的工作，这种不幸的状况称作死锁（dead lock）
- 管程（monitor）：一种高级同步原语
  - 一个管程以一个由过程、变量及数据结构等组成的一个集合
    - 它们组成一个特殊的模块或软件包
    - 一种抽象、类Pascal语言描述的管程
        monitor example
        	integer i;
        	condition c;
        	
        	procedure producer();
        	.
        	.
        	.
        	end;
        	
        	procedure consumer();
        	.
        	end;
        end monitor;
  - 管程有一个很重要的特性，即任一时刻管程中只能有一个活跃进程
  - 进入管程是的互斥由编译器负责，但通常的做法是用一个互斥量或二元信号量
  - 生产者在发现缓冲区满的时候如何阻塞：
    - 解决的方法是引入条件变量（condition variable）以及相关的两个操作：wait和signal
    - 当一个管程过程发现它无法继续运行时，它会在某个条件变量上（如full）执行wait操作
      - 该操作导致调用进程自身阻塞，并且还将另一个以前等在管程之外的进程调入管程
    - 消费者可以唤醒正在睡眠的伙伴正在等待的一个条件变量执行signal完成
      - 如果在一个条件变量上有若干进程正在等待，则对该条件变量执行signal操作后，系统调用程序只能在其中选择一个使其恢复运行
      - 第三种方法让发信号者继续运行，并且只有在发信号者退出管程之后，才允许等待的进程开始运行
- wait和signal操作看起来像前面提到的sleep和wakeup，但后者存在严重的竞争条件
- Java是面向对象的语言，它支持用户级线程，还允许将方法（过程）划分为类
  - 只要将关键词synchronized加入到方法声明中，Java保证一旦某个线程执行该方法，就不允许其他线程执行该对象中的任何synchronized方法
      public class ProducerConsumer{
        static final N = 100;//定义缓冲区大小的常量
        static producer p = new producer();//初始化一个新的生产者线程
        static consumer c = new consumer();//初始化一个新的消费者线程
        static out_monitor mon = new our_monitor();//初始化一个新的管程
        
        public static void main(String args[]){
          p.start();//开始生产者线程
          c.start();//开始消费者线程
        }
        
        static class producer extends Thread{
          public void run(){//run方法包含了线程代码
            int item;
            while(true){//生产者循环
              item = produce_item();
              mon.inset(item);
            }
          }
          private int produce_item(){...}//实际生产
        }
        
        static class consumer extends Thread{
          public void run(){//run方法包含了线程代码
            int item;
            while(true){//消费者循环
              item = mon.remove();
              consume_item(item);
            }
          }
          private void comsumer_item(int item);//实际消费
        }
        
        static class our_monitor{
          private int buffer[] = new int[N];
          private int count = 0, lo = 0, hi = 0;//计数器和索引
          
          public synchronized void insert(int val){
            if(count == N)go_to_sleep();//如果缓冲区满，则进入休眠
            buffer[hi] = val;//向缓冲区中插入一个新的数据项
            hi = (hi+1) % N;//设置下一个
            count = count + 1;//缓冲区中的数据项又多了一项
            if(count == 1)notify();//如果消费者在休眠，则将其唤醒
          }
          public synchronized int remove(){
            int val;
            if(count == 0)go_to_sleep();//如果缓冲区空，进入休眠
            val = buffer[lo];//从缓冲区中取出一个数据项
            lo = (lo + 1) % N;//设置待取数据项的槽
            count = count - 1;
            if(count == N - 1)notify();//如果生产者在休眠，则将其唤醒
            return val;
          } 
          private void go_to_sleep(){try(wait();)catch(InterruptedException exc){};}
        }
        
      }
- 于管程和信号量有关的另一个问题是，这些机制都是设计用来解决访问公共内存的一个或多个CPU上的互斥问题的
- 信号量太低级了，而管程在少数几种编程语言之外无法使用，并且，这些原语均未提供机器间的信息交换方法

2.3.8 消息传递

- 消息传递，message passing 
- 这种进程间通信的方法使用两条send和receive，它们像信号量而不像管程
  - 系统调用而不是语言成分
- 前一个调用向一个给定的目标发送一条消息，后一个调用从一个给定的源接收一条消息
- 消息传递系统的设计要点
  - 消息传递系统面临着许多信号量和管程所未涉及的问题和设计难点
    - 特别是位于网络中不同机器上的通信进程的情况
    - 为防止消息丢失，发送方和接收方可以达成如下一致：一旦接收到信息，接收方马上回送一条特殊的确认（acknowledgement）消息
  - 不可靠消息传递中成功通信问题是计算机网络的主要研究内容
  - 消息系统还需要解决进程命名问题，在send和receive调用中所指定的进程必须是没有二义性的
  - 身份确认（authentication）也是一个问题
  - 对于发送者和接收者在同一台机器上的情况，也存在若干设计问题
    - 性能问题
      - 将消息从一个进程复制到另一个进程通常比信号量操作和进入管程要慢
- 用消息传递解决生产者-消费者问题
  - 消息传递而不是共享内存来解决生产者-消费者问题
  - 消息传递方式可以有许多变体，我们首先介绍如何对消息进程编址
    - 为每个进程分配一个唯一的地址，让消息按进程的地址编址
    - 引入一种新的数据结构，称作信箱（mailbox）
      - 信箱是一个用来对一定数量的消息进程缓冲的地方，信箱中消息数量的设置方法也有很多种
        - 典型的方法是在信箱创建时确定消息的数量
      - 对于生产者-消费者问题，生产者和消费者均应创建足够容纳N条消息的信箱
  - 使用信箱的另一种极端方法是彻底取消缓冲
    - 会合（rendezvous）：如果先执行receive，则接受者会被阻塞，直到send方式
    - 通常在并行程序设计系统中使用消息传递
      - 消息传递接口，Message-Passing Interface，MPI
        - 它广泛应用在科学计算中

2.3.9 屏障

- 用于进程组而不是用于双进程的生产者-消费者类情形的
  - 在有些应用中划分了若干阶段，并且规定，除非所有的进程都就绪准备着手下一个阶段，否则任何进程都不能进入下一个阶段
- 可以通过在每个阶段的结尾安置屏障（barrier）来实现若干阶段的进程
  - 考虑在物理或工程中的一个典型的弛豫问题

2.4 调度

- 在操作系统中，如果只有一个CPU可用，那么就必须选择下一个要运行的进程，完成选择工作的这一部分称为调度程序（scheduler）
  - 该程序使用的算法称为调度算法（scheduling algorithm）
- 本节将首先关注适用于进程与线程两者的调度问题，然后会明确地介绍线程调度以及它所产生的独特问题

2.4.1 调度介绍

- 早期以磁带上的卡片作为输入的批处理系统时代
  - 依次运行磁带上的每一个作业
- 大型机
  - 将批处理和分时服务结合使用
- 个人计算机
  - 两个方面发展
    - 在多数时间内只有一个活动进程
    - 现在计算机速度极快
- 进程切换的代价是比较高的
  - 首先用户态必须切换到内核态
  - 然后要保存当前进程的状态，包括在进程表中存储寄存器以便以后重新装载
  - 通过运行调度算法选定一个新进程
  - 将新进程的内存映像重新装入MMU
  - 新进程开始运行
- 进程行为
  - 几乎所有进程的（磁盘）I/O请求或计算都是交替突发的
  - 计算密集型，compute-bound：
    - 某些进程花费了绝大多数时间在计算上
    - 具有较长时间的CPU集中使用和较小频度的I/O等待
  - I/O密集型，I/O-bound：
    - 在等待I/O上花费了绝大多数时间
    - 具有较短时间的CPU集中使用和频繁地I/O等待
  - 随着CPU变得越来越快，更多的进程倾向为I/O密集型
- 何时调度
  - 调度处理的各种情形
    - 在创建一个新进程之后，需要决定是运行父进程还是运行子进程
    - 在一个进程退出时必须做出调度决策
    - 当一个进程阻塞在I/O和信号量上或由于其他原因阻塞时，必须选择另一个进程运行
    - 在一个I/O中断发生时，必须做出调度决策
  - 根据如何处理时钟中断，可以把调度算法分为两类
    - 非抢占式调度算法挑选一个进程，然后让该进程运行直至被阻塞（阻塞在I/O上或等待另一个进程）
    - 抢占式调度算法挑选一个进程，并且让该进程运行某个固定时段的最大值
- 调度算法分类
  - 不同的环境需要不同的调度算法
  - 不同的系统中，调度程序的优化是不同的
    - 批处理
      - 批处理系统在商业领域仍在广泛应用
        - 用来处理薪水册、存货清单、账目收入、账目支出、利息计算（在银行）、索赔处理（在保险公司）和其他的周期性的作业
        - 非抢占式算法，或对每个进程都有长时间周期的抢占式算方法，通常都是可接受的
    - 交互式
      - 抢占式必须的
    - 实时
      - 在有实时限制的系统中，抢占有时是不需要的
- 调度算法的目标
  - 所有系统
    - 公平
      - 给每个进程公平的CPU份额
    - 策略强制执行
      - 看到所宣布的策略执行
    - 平衡
      - 保持系统的所有部分都忙碌
  - 批处理系统
    - 吞吐量
      - 每小时最大作业数
    - 周转时间
      - 从提交到终止间的最小时间
    - CPU利用率
      - 保持CPU始终忙碌
  - 交互式系统
    - 响应时间
      - 快速响应请求
    - 均衡性
      - 满足用户的期望
  - 实时系统
    - 满足截止时间
      - 避免丢失数据
    - 可预测性
      - 在多媒体系统中避免品质降低
  - 在所有的情形中，公平是很重要的
  - 与公平有关的是系统策略的强制执行
  - 另一个共同的目标是保持系统的所有部分尽可能忙碌
  - 运行大量批处理作业的大型计算中心的管理者们为了掌握其系统的工作状态，通常检查三个指标：
    - 吞吐量
      - 系统每小时完成的作业数量
    - 周转时间
      - 从一个批处理作业提交时刻开始直到该作业完成时刻为止的统计平均时间
      - 小就是好
      - 能够使吞吐量最大化的调度算法不一定就有最小的周转时间
    - CPU利用率
      - 用于对批处理系统的度量
      - 并不是一个好的度量单位
  - 交互式系统
    - 最重要的是最小响应时间
      - 从发出命令到得到响应之间的时间
    - 均衡性问题
  - 实时系统
    - 或多或少必须满足截止时间
    - 可预测性

2.4.2 批处理系统中的调度

- 先来先服务
  - 先来先服务，first-come first-serverd算法
    - 非抢占式
    - 最简单的
  - 进程按照它们请求CPU的顺序使用CPU
  - 主要优点是易于理解并且便于在程序中运用
  - 缺点：
    - 一次运行1秒钟的计算密集型进程和很少使用CPU但是每个都要进行1000此磁盘读操作才能完成的大量I/O密集型进程
- 最短作业优先
  - 最短作业优先，shortest job first
    - 适用于运行时间可以预知的
    - 非抢占式
  - 只有在所有的作业都可同时运行的情形下，最短作业优先算法才是最优化的
- 最短剩余时间优先
  - 最短剩余时间优先（shortest remaining time next）
    - 最短作业优先的抢占式版本
    - 使用这个算法，调度程序总是选择剩余时间最短的那个进程运行

2.4.3 交互式系统中的调度

- 在个人计算机、服务器和其他类系统中都是常用的
- 轮转调度
  - 轮转调度，round robin
    - 一种最古老、最简单、最公平且使用最广的算法
  - 每个进程被分配一个时间段，称为时间片（quantum）
    - 允许该进程在该时间段中运行
  - 进程切换，process switch
    - 有时称为上下文切换，context switch
  - 时间片设得太短会导致过多的进程切换，降低了CPU效率，而设得太长又可能对短的交互请求的响应时间变长
    - 将时间片段设为20ms~50ms通常是一个比较合理的折中
- 优先级调度
  - 轮转调度中，所有的进程同等重要
  - 优先级调度
    - 每个进程被赋予一个优先级，允许优先级最高的可运行进程先运行
  - 每个进程可以被赋予一个允许运行的最大时间片，当这个时间片用完时，下一个次高优先级的进程获得机会运行
  - 优先级可以是静态赋予或动态赋予
    - UNIX系统中有一条命令，它允许用户为了照顾别人而自愿降低自己进程的优先级
  - 为了达到目的，优先级也可以由系统动态确定
    - 使I/O密集型进程获得较好服务的一种简单算法是，将其优先级设为1/f，f为该进程上在上一时间片中所占内存的部分
  - 将一组进程按优先级分为若干类，并且在各类之间采用优先级调度，而在各类进程的内部采用轮转调度
- 多级队列
  - CTSS（Compatible TimeSharing System），兼容分时系统
    - 最早使用优先级调度的系统之一
    - 进程切换速度太慢
      - 为CPU密集型进程设置较长时间片比频繁地分给它们很短的时间片要更为高效
      - 长时间片的进程有会影响到响应时间
        - 设立优先级类
  - 对进程划分优先级
    - 在伯克利制造的著名的XDS940系统中，有4个优先级类，分别是终端、I/O、短时间片和长时间片
- 最短进程优先
  - 最短作业优先用于交互进程
    - 唯一的问题是如何从当前可运行进程中找出最短的那一个进程
      - 一种办法是根据进程过去的行为进行推测，并执行估计运行时间最短的那一个
      - 老化，aging：通过当前测量量和先前估计值进行加权平均得到下一个估计值的技术
        - 它适用于许多预测值必须基于先前值的情况
- 保证调度
  - 向用户作出明确地性能保证，然后去实现它
    - 一种完全不同的调度算法
  - 一种很实际并很容易的保证是：
    - 若用户工作时有n个用户登录，则用户将获得CPU处理能力的1/n
- 彩票调度
  - 彩票调度，lottert scheduling
    - 有一种即可给出类似预测结果而又有非常简单的实现方法的算法
    - 基本思想是向进程提供各种系统资源（如CPU时间）的彩票
    - 给重要的进程额外的彩票，以便增加它们获胜的机会
  - 彩票调用具有若干有趣的性质
    - 反应迅速
      - 如果有一个新的进程出现并得到一些彩票，那么在下一次的抽奖中，该进程会有同它持有彩票数量成比例的机会赢得奖励
    - 协作进程交换彩票
    - 彩票调度可以用来解决用其他方法很难解决的问题
- 公平共享调度
  - 假设被调度的都是各个进程自身，并不关注其所有者是谁
  - 为避免这种情形，某些系统在调度处理之前考虑谁拥有进程这一因素

2.4.4 实时系统中的调用

- 实时系统通常可以分为
  - 硬实时（hard-real time）
    - 必须满足绝对的截止时间
  - 软实时（soft real time）
    - 虽然不希望偶尔错失截止时间，但是可以容忍
- 实时系统中的事件可以按照响应方式进一步分类为周期性（以规则的时间间隔发生）事件或非周期（发生时间不可预知）事件
- 如果有m个周期事件，事件i以周期Pi发生，并需要Ci秒CPU时间处理一个事件，那么可以处理负载的条件是
  - \sum_{i=0}^n\frac{C_i }{P_i}
  - 满足这个条件的实时系统称为是可调度的
- 实时系统的调度算法可以是静态或动态的
  - 前者开系统开始之前作出调度决策
  - 后者在运行过程中进程调度决策

2.4.5 策略和机制

- 假设系统中所有进程分属不同的用户，进程间互相竞争CPU
- 调度算法中没有一个算法从用户进程接收有关的调度决策信息，这就导致了调度程序很少能够做出最优的选择
  - 解决问题的方法是将调度机制（scheduling mechanism）与调度策略（scheduling policy）分离
    - 将调度算法以某种形式参数化，而参数可以由用户进程填写

2.4.6 线程调度

- 当若干进程都有多个线程时，就存在两个层次的并行：
  - 进程
  - 线程
- 用户级线程
  - 轮转调度和优先级调度更为常用
  - 局限性是，缺乏一个时钟将运行过长的线程加以中断
- 内核级线程
  - 内核选择一个特定的线程运行，不用考虑该线程属于那个进程
- 用户级线程和内核级线程之间的差别在于性能
  - 用户级线程的线程切换需要少量的机器指令
  - 内核级线程需要完整的上下文切换，修改内存映像
- 用户级线程可以使用专为应用程序定制的线程调度程序

2.5 经典的IPC问题

2.5.1 哲学家就餐问题

- 1965年，Dijkstra提出了一个他称之为哲学家就餐的同步问题
  - 五个哲学家围坐在一张圆桌周围，每个哲学家面前都有一盘通心粉。由于通心粉很滑，所以需要两把叉子才能夹住。相邻两个盘子之间放有一把叉子
  - 能为每个哲学家写一段描述其行为的程序且绝不会死锁吗
- 饥饿，starvation：所有的程序都在不停地运行，但都无法取得进展
- 如果哲学家在拿不到右边叉子时等待一段随机时间，而不是等待相同的时间，这样发生互锁的可能性就很小了，事情就可以继续了
- 若下改进，既不会发生死锁又不会产生饥饿
  - 使用一个二元信号量对调用think之后的五个语句进行保护
  - 在开始拿叉子之前，哲学家先对互斥量mutex执行down操作
  - 在放回叉子后，他在对mutex执行up操作
  - 局限：在任何一时刻只能有一位哲学家进餐。而五把叉子实际上可以允许两位哲学家同时进餐
      //哲学家的数目
      #define N 5 
      //i的左邻居编号
      #define LEFT (i+N-1)%N
      //i的右邻居编号
      #define RIGHT (i+1)%N
      //哲学家在思考
      #define THINKING 0 
      //哲学家试图拿起叉子
      #define HUNGRY 1
      //哲学家在进餐
      #define EATING 2
      //信号量是一种特殊的整型数据
      typedef int semaphore;
      //数组用来跟踪记录每位哲学家的状态
      int state[N];
      //临界区的互斥
      semaphore mutex = 1;
      //每个哲学家一个信号量
      semaphore s[N]；
      
      //i:哲学家编号，从0至N-1
      void philosopher(int i)
      {
        //无限循环
        while(TRUE){
        }
      }
      
      //i：哲学家编号，从0至N-1
      void take_forks(int i)
      {
        //进入临界区
        down(&mutex);
        //记录哲学家i处于饥饿的状态
        state[i] = HUNGRY;
        //尝试获取2把叉子
        test(i);
        //离开临界区
        up(&mutex);
        //如果得不到需要的叉子则阻塞
        down(&s[i]);
      }
      
      //i:哲学家编号，从0至N-1
      void take_forks(int i)
      {
        //进入临界区
        down(&mutex);
        //哲学家已经就餐完毕
        test(LEFT);
        //检查左边的邻居现在可以吃吗
        test(LEFT);
        //检查右边的邻居现在可以吃吗
        test(RIGHT)；
        //离开临界区
        up(&mutex);
      }
      
      //i:哲学家编号，从0至N-1
      void test(i)
      {
        if(state[i] == HUNGRY && state[LEFT] != EATING && EATING){
          
        }
      }
- 该程序使用了一个信号量数组，每个信号量对应一位哲学家
- 哲学家就餐问题对于互斥访问有限资源的竞争问题（如I/O设备）一类的建模过程十分有用

2.5.2 读者-写者问题

- 读者-写者问题
  - Conrtois等人，1971
  - 它为数据库访问建立模型

    //运用你的想象
    typedef int semaphore;
    //控制对rc的访问
    semaphore mutex = 1;
    //控制对数据库的访问
    semaphore db = 1;
    //正在读或者即将读的进程数目
    int rc = 0;
    
    void reader(void)
    {
      //无限循环
      while(TRUE){
        //获得对rc的互斥访问权
        down（&TRUE）;
        //现在又多了一个读者
        rc = rc + 1;
        //如果这是第一个读者
        if(rc == 1)down(&db)；
        //释放对rc的互斥访问
        up(&mutex);
        //访问数据
        read_data_base();
        //获取对rc的互斥访问
        down(&mutex);
        //现在减少了一个读者
        rc = rc - 1;
        //如果这是最后一个读者
        if(rc == 0)up(&db)；
        //释放对rc的互斥访问
        up(&mutex)；
        //非临界区
        use_data_read();
      }
      
      void writer(void)
      {
        //无限循环
        while(TRUE){
          //非临界区
          think_up_data();
          //获取互斥访问
          down(&db);
          //更新数据
          write_data_base();
          //释放互斥访问
          up(&db);
        }
      }
    }

- 在该解法中，第一个读者对信号量db执行down操作。随后的读者只是递增一个计数器rc。当读者离开时，它们递减这个计数器，而最后一个读者对信号量执行up，这样就允许一个被阻塞的写者可以访问该数据库
- 为了避免写者等待，可以稍微改变一下程序的写法
  - 在一个读者到达，且一个写者在等待时，读者在写者之后被挂起，而不是立即允许进入
  - 缺点是，并发度和效率低

2.6 有关进程和线程的研究

- 关于进程概念的研究已经获得良好的解决方案
  - 激活所有的系统都把一个进程视为一个容器，该容器用以聚集相关的资源
    - 地址空间
    - 线程
    - 打开的文件
    - 保护许可
- 线程是比进程更新的概念，但是它们同样也经过了相当多的考虑
- 进程同步问题已经相当成熟和固定
  - 无锁并发处理的问题
  - 实时系统中的无阻塞同步问题
- 调度（单处理器和多处理器）
  - 移动设备上的能耗节省调度
  - 超线程调度
  - 当CPU空闲时该做什么
  - 虚拟时间调度

2.7 小结

- 为了屏蔽中断的影响，操作系统提供了一个由并行运行的顺序进程组成的概念模型
  - 进程可以动态地创建和终止
  - 每个进程都有自己的地址空间
- 对于某些应用而言，在一个进程中使用多个控制线程是有益的
  - 线程被独立调度
    - 每个线程都有自己的堆栈
  - 但是在一个进程中的所有线程共享一个公共地址空间
  - 线程可以在用户空间或内核中实现
- 进程之间通过进程间通信原语彼此通信
  - 信号量
  - 管程
  - 消息
    - 这些原语用来确保同一时刻不会有两个进程在临界区中，免除了出现混乱的情形
    - 进程可以处在运行、可运行或阻塞状态，并且在该进程或其他进程执行某个进程间通信原语，可以改变其状态
- 进程间通信原语可以用来解决诸如
  - 生产者-消费者问题
  - 哲学家就餐问题
  - 读者-写者问题
- 调度算法
  - 某些算法主要用于批处理系统中
    - 最短作业优先调度算法
  - 批处理系统和交互式系统中
    - 轮转调度
    - 优先级调度
    - 多级队列
    - 保证调度
    - 彩票调度
    - 公平分享调度

习题

1. 阻塞-运行、就绪-阻塞
2. 中断硬件将程序计数器、程序状态字，有时还有一个或多个寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址
3. 一些诸如保存寄存器值和设置堆栈指针等操作，无法用C语言这一类高级语言描述，所以这些操作通过汇编语言来完成
4. 不知道
5. 顺序执行需要20分钟，15分钟
6. 对于三个没有关系的线程而言，应该使用图2-11a的结构，而在三个线程实际完成同一个作业并彼此积极密切合作，图2-11b则比较合适
7. 不会
8. 用户级线程，系统全部改成非阻塞
9. 存在
10. 由于资源管理的单位是进程而非线程
11. 因为不同于进程，（线程库）无法利用时钟中断强制线程让出CPU。所以设法使线程行为“高尚”起来，并且随着时间的推移自动交出CPU，以便让其他线程有机会运行，就变得非常重要
12. 因为不同于进程，（线程库）无法利用时钟中断强制线程让出CPU
13. 单线程11个，多线程13个‘
14. 优点：启动它们比进行内核调用效率更高；缺点：阻塞系统调用问题
15. 没有，这些不同信息交错的顺序是不确定的，并且可能在连续运行程序的情况下发生变化
16. 该过程需要使用这些值，无论该存储空间分配在何处，只有调用线程才可访问其全局变量。
17. 对于任何给定的过程，当前面的调用尚没有结束之前，可以进行第二次调用。解决方案是，为每个过程提供一个包装器，该包装器设置一个二进制位从而标志某个库处于使用中。在先前的调用还没有完成之前，任何试图使用该库的其他线程都会被阻塞。尽管这个方式可以工作，但是它会极大地降低系统潜在的并行性。
18. 当某个线程做了一些会引起在本地阻塞的事情之后，例如，等待进程中另一个线程完成某项工作，它调用一个运行时系统的过程，这个过程检查该线程是否必须进入阻塞状态。如果是，它在线程表中保存该线程的寄存器（即它本身的），查看表中可运行的就绪线程，并把新线程的保存值重新装入机器的寄存器中。只要堆栈指针和程序计数器一被切换，新的线程就又自动投入运行。如果机器有一条保存所有寄存器的指令和另一条装入全部寄存器的指令，那么整个线程的切换可以在几条指令内完成。
19. 不可能，只有进程可以
20. 会。轮转调度做了一个隐含的假设，即所有的进程同等重要，而拥有和操作多用户计算机系统的人对此常有不同的看法的程序计数器、堆栈指针、寄存器和状态等。
21. 用户级线程每个线程一个堆栈，每个进程需要有其专用的线程表（thread table），用来跟踪该进程中的线程。这些表和内核中的进程表类似，不过它仅仅记录各个线程的属性，如每个线程。内核的线程表保存了每个线程的寄存器、状态和其他信息
22. 不知道
23. 不知道
24. 不知道
25. 测试信号量、更新信号量以及在需要时使某个进程睡眠
26. 如果每个进程在进入临界区前都执行一个down操作，并在刚刚退出时执行一个up操作，就能够实现互斥
27. 不能，不是用于双进程的生产者-消费者类情形的
28. 可以，信号量full和empty用来保证某种事件的顺序发生或不发生。通过使用这些过程，用户线程完全可以实现在用户空间中的同步，这些过程仅仅需要少量的指令。
29. 条件变量允许这种等待与阻塞原子性地进行
30. 不知道
31. 不会，当一个进程试图向一个满的信箱发消息时，它将被挂起，直到信箱内有消息被取走，从而为新消息腾出空间。
32. n/10*T
33. 可以，计算密集型，compute-bound：某些进程花费了绝大多数时间在计算上，具有较长时间的CPU集中使用和较小频度的I/O等待。I/O密集型，I/O-bound：在等待I/O上花费了绝大多数时间，具有较短时间的CPU集中使用和频繁地I/O等待
34. 抢占式进程。抢占式调度算法挑选一个进程，并且让该进程运行某个固定时段的最大值。如果在该时段结束时，该进程仍在运行，它就被挂起，而调度程序挑选另一个进程运行（如果存在一个就绪进程）。进行抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便把CPU控制返回给调度程序。
35. a）


