

# 现代操作系统 第4章 文件系统

- 所有的计算机应用程序都需要存储和检索信息
- 进程运行时，可以在它自己的地址空间存储一定量的信息
  - 存储容量受虚拟地址空间大小的限制
  - 进程终止时，它保存的信息也随之丢失
  - 经常需要多个进程同时存取同一信息（或者其中部分信息）
    - 使信息本身独立于任何一个进程
- 因此，长期存储信息有三个基本要求：
  - 能够存储大量信息
  - 使用信息的进程终止时，信息仍旧存在
  - 必须能够使多个进程并发存取有关信息
- magnetic disk，磁盘
  - 由于其长期存储的性质，已经有多年的使用历史
  - 我们可以把磁盘当作一种固定块大小的线性序列，并且支持如下两种操作：
    - 读块k；
    - 写块k；
  - 这种情况下，很容易产生一些问题
    - 如何找到信息？
    - 如何防止一个用户读取另一个用户的数据？
    - 如何知道哪些块是空闲的？
- 进程（与线程）、地址空间和文件，这些抽象概念均是操作系统中最重要的概念。
- 文件是进程创建的信息逻辑单元
  - 一个磁盘一般含有几千甚至几百万个文件，每个文件是独立于其他文件的
  - 文件不仅仅被用来对磁盘建模，以代替对随机存储器（RAM）的建模
  - 进程可以读取已经存在的文件，并在需要时建立新的文件
- 文件是受操作系统管理的
  - 有关文件的构造、命名、存取、使用、保护、实现和管理方法都是操作系统设计的主要内容
- file system，文件系统
  - 操作系统中处理文件的部分称为文件系统
- 从用户角度来看，文件系统中最重要的是它在用户眼中的表现形式，也就是文件是由上面组成的，怎样给文件命名，怎样保护文件，以及可以对文件进行哪些操作等
- 用链表还是用位图来记录空闲存储区以及在一个逻辑磁盘块中有多少个扇区等细节并不是用户所关心的

## 4.1 文件

- 用户如何使用文件，文件具有哪些特性

### 4.1.1 文件命名

- 文件是一种抽象机制
  - 它提供了一种在磁盘上保留信息而且方便以后读取的方法
  - 这种方法可以使用户不用了解存储信息的方法、位置和实际磁盘工作方式等有关细节
- 任何一种抽象机制的最重要的特性就是对管理对象的命名方式
  - 文件的具体命名规则在各个系统中是不同的，不过所有的现代操作系统都允许用1至8个字母组成的字符串作为合法的文件名
    - 许多文件系统支持长达255个字符的文件名
  - 有的文件系统区分大小写字母，有的则不区分
    - UNIX是前一类，MS-DOS是后一类
  - FAT-16
    - WIndows 95与Windows 98用的都是MS-DOS的文件系统，即FAT-16
    - FAT-32
      - WIndows 98对FAT-16引入了一些拓展，从而形成了FAT-32
    - Windows NT、Windows 2000、Windows XP和Windows Vista支持这两种已经过时的FAT文件系统
      - 有一个自带文件系统（NTFS）
  - file extension，文件拓展名
    - 许多操作系统支持文件名用圆点隔开分为两部分
    - 圆点后面的部分称为文件拓展名
      - 文件拓展名通常表示文件的一些信息，
        - 如MS-DOS中，文件名由1至8个字符以及1至3个字符的可选拓展名组成
        - 在UNIX里，如果有拓展名，则拓展名完全由用户决定，一个文件甚至可以包含两个或更多的拓展名
    - 在某些系统中（如UNIX），文件拓展名只是一种约定，操作系统并不强迫采用它
      - 对于可以处理多种类型文件的某个程序，这类约定是特别有用的
    - 相反，Windows对拓展名赋予含义

### 4.1.2 文件结构

- 文件可以有多种构造方式
  - 一种无结构的字节序列
    - 为操作系统提供了最大的灵活性
    - 所有UNIX、MS-DOS以及Windows都采用这种文件模型
  - 文件结构上的第一步改进
    - 文件是具有固定长度记录的序列，每个记录都有其内部结构
      - 记录
        - 几十年前，当80列的穿孔卡片还是直流的时候，很多（大型机）操作系统把文件系统建立在由80个字符的记录组成的文件基础之上
        - 也支持132个字符的记录组成的文件
  - 文件在这种结构中由一棵记录树构成，每个记录并不具有同样的长度，而记录的固定位置上有一个“键”字段
    - 在一些处理商业数据得大型计算机中获得广泛使用

### 4.1.3 文件类型

- 很多操作系统支持多种文件类型
  - UNIX和Windows中都有普通文件和目录
  - UNIX有
    - character speicial file，字符特殊文件
      - 和输入/输出有关
      - 用于串行I/O类设备，如终端、打印机、网络等
    - block special file，块特殊文件
      - 用于磁盘类设备
    - regular file，普通文件
      - 包含有用户信息、
      - 一般分为ASCⅡ文件和二进制文件
        - ASCⅡ文件由多行正文组成
          - 在某些系统中，每行用回车符结束，其他系统则用换行符结束
          - 有些系统还同时采用回车符和换行符（如MS-DOS）
        - 二进制文件有一定的内部结构、
          - 打印出来的二进制文件是无法理解的、充满混乱字符的一张表
          - 使用该文件的程序才了解这种结构
          - UNIX中，可执行二进制文件有五个段
            - 文件头
              - magic number，魔数
                - 文件头以所谓的魔数开始，表明该文件是一个可执行的文件
                  - 防止非这种格式的文件偶然运行
            - 正文
            - 数据
              - 正文和数据在文件头的后面
            - 重定位位
              - 使用重定位位重新定位
            - 符号表
              - 用于调试
          - UNIX的存档文件
            - 由已编译但没有连接的库过程（模块）集合而成
            - 每个文件以模块头开始，其中记录了名称、创建日期、所有者、保护码和文件大小
    - directory，目录
      - 管理文件系统结构的系统文件
- 所有操作系统必须能够识别它们自己的可执行文件的文件类型
  - 一种老式的TOPS-20操作系统（用于DECsystem20计算机）可检查可执行文件的创建时间
  - 在UNIX中，就是在shell中嵌入make程序
- 如果用户执行了系统设计者没有考虑到的某种操作，这种强制类型的文件有可能会引起麻烦

### 4.1.4 文件存取

- 早期操作系统只有只有一种文件存取方式：

  - sequential access，顺序存取
    - 进程在这些系统中从头顺序读取文件的全部字节或记录
    - 顺序存取文件是可以返回到起点的，需要时可多次读取该文件
    - 在存储介质是磁带而不是磁盘时，顺序存取文件是很方便的

- random access file，随机存取文件

  - 以任何次序读取其中字节或记录的文件

  - |     属性     |         含义          |
    | :--------: | :-----------------: |
    |     保护     |  谁可以存取文件，以什么方式存取文件  |
    |     口令     |      存取文件需要的口令      |
    |    创建者     |      创建文件者的ID       |
    |    所有者     |        当前所有者        |
    |    只读标志    |    0表示读/写；1表示只读     |
    |    隐藏标志    |  0表示正常；1表示不再列表中显示   |
    |    系统标志    |   0表示普通文件；1表示系统文件   |
    |    存档标志    |   0表示已经备份；1表示需要备份   |
    | ASCⅡ/二进制标志 | 0表示ASCⅡ码文件；1表示二进制文件 |
    |   随机存取标志   | 0表示只允许顺序存取；1表示随机存取  |
    |    临时标志    | 0表示正常；1表示进程退出时删除该文件 |
    |    加锁标志    |    0表示未加锁；非零表示加锁    |
    |    记录长度    |      一个记录中的字节数      |
    |    键的位置    |     每个记录中键的偏移量      |
    |    键的长度    |       键字段的字节数       |
    |    创建时间    |     文件创建的日期和时间      |
    |  最后一次存取时间  |    文件上一次存取的日期和时间    |
    |  最后一次修改时间  |    文件上一次修改的日期和时间    |
    |    当前大小    |       文件的字节数        |
    |    最大长度    |     文件可能增长到的字节数     |

    随机存取文件对很多应用程序而言是必不可少的，如数据库系统

- 有两种方法可以指示从何处开始读取文件

  - 每次read操作都给出开始读文件的位置
  - 用一个特殊的seek操作设置当前位置
    - UNIX和WIndows使用

### 4.1.5 文件属性

- attribute，文件属性
  - 所有的操作系统还会保存其他与文件相关的信息
  - 如文件创建的日期和时间、文件大小等
  - metadata，元数据
- 前4个属性与文件保护相关，它们指出了谁可以存取这个文件，谁不能存取这个文件
- 标志是一些位或短的字段
  - 用于控制或启用某些特殊属性
- 记录长度、键的位置和键的长度等字段只能出现在关键字查找记录的文件里
  - 提供了查找关键字所需的信息
- 时间字段记录了文件的创建时间、最近一次存取时间以及最后一次修改时间。
  - 它们的作用不同
- 当前大小字段指出了当前的文件大小
  - 在一些老式大型机操作系统中创建文件时，要给出文件的最大长度，以便操作系统事先按最大长度留出存储空间
  - 工作站和个人计算机中的操作系统则聪明多了，不需要这一点提示

### 4.1.6 文件操作

- 使用文件的目的是存储信息并方便以后的检索
- 对于存储和检索，不同系统提供了不同的操作
- 与文件有关的最常见的一些系统调用
  - create
    - 创建不包含任何数据的文件
    - 目的是表示文件即将建立，并设置文件的一些属性
  - delete
    - 当不在需要某个文件时，必须删除该文件以释放磁盘空间
  - open
    - 在使用文件之前，必须先打开文件
    - 目的是把文件属性和磁盘地址表装入内存，便于后续调用的快速存取
  - close
    - 存取结束后，不在需要文件属性和磁盘地址，这是应该关闭文件以释放内部表空间
  - read
    - 在文件中读取数据
    - 调用者必须指明需要读取多少数据，并提供存放这些数据的缓冲区
  - write
    - 向文件写数据
  - append
    - 此调用是write的限制形式
    - 此调用是write的限制形式，它只能在文件末尾添加数据
  - seek
    - 对于随机存取文件，要指定从何处开始取数据，通常的方法是用seek系统调用把当前位置指针指向文件中的特定位置
  - get attribute
    - 进程运行常需要读取文件属性
  - set attribute
    - 某些属性是可由用户设置的，在文件创建之后，用户还可以通过系统调用set attribute来修改它们
  - rename
    - 用户常常要改变已有文件的名字

### 4.1.7 使用文件系统调用的一个示例程序

- 本节会考察一个简单的UNIX程序，它把文件从源文件处复制到目标文件处
- 在程序的开头是四个#include语句，它们把大量的定义和函数原型包含在这个程序
  - 接下来的第一个#define语句是一个宏定义，它把BUF_SIZE字符串定义为一个宏，其数值为4096
  - 第二个#define语句决定谁可以访问输出文件
- 主程序名为main，它有两个参数：argc和argv
  - 第一个参数表示在调用该程序的命令行中包含多少个字符串，包括该程序名
  - 第二个参数是指向程序参数的指针数组
    - 声明了五个变量
      - 前面两个（in_fd和out_fd）用来保存文件描述符
        - 即打开一个文件时返回一个小整数
      - 后面两个（rd_count和wt_count）分别是由read和write系统调用所返回的字节计数
      - 最后一个（buffer）是用于保存所读出的数据以及提供写入数据得缓冲区
    - 第一行实际语句检查argc，看它是否是3
      - 如果不是，它以状态码1退出
      - 任何非0的状态码均表示出错
    - 接着我们试图打开源文件并创建目标文件
    - 接下来是用来复制文件的循环
      - 第一个文件标识文件
      - 第二个参数指定缓冲区
      - 第三个参数指定读出多少字节
- 调用write把缓冲区的内容输出到目标文件中
  - 第一个参数标识文件
  - 第二个参数指定缓冲区
  - 第三个参数指定写入多少字节
- 当整个文件处理完时，超出文件尾部的首次调用会把0值返回给rd_count
  - 这样，程序会退出循环

```c
/*复制文件程序，有基本的错误检查和错误报告*/

//包括必要的头文件
#include <sys/types.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>

//ANSI原型
int main(int argc, char *argv[]);

//使用一个4096字节大小的缓冲区
#define BUF_SIZE 4096
//输出文件的保护位
#define OUTPUT_MODE 0700

int main(int argc, char *argv[])
{
  int in_fd, out_fd, rd_count, wt_count;
  char buffer(BUF_SIZE);
  
  //如果argc不等于3，语法错
  if(argc != 3)exit(1);
  //打开输入文件并创建输出文件
  //打开源文件
  in_fd = open(argv[1], O_RDONL);
  //如果该文件不能打开，退出
  if(in_fd < 0)exit(2);
  //创建目标文件
  out_fd = creat(argv[2], OUTPUT_MODE);
  //如果该文件不能被创建，退保护
  if(out_fd < 0)exit(3);
  
  //循环复制
  while(TRUE){
    //读一块数据
    rd_count = read(in_fd, buffer, BUF_MODE);
    //如果文件结束或读时出错，退出循环
    if(rd_count <= 0)break;
    	//写数据
    	wt_count = write(out_fd, buffer, rd_count);
    	//wt_count<=0是一个错误
    	if(wt_count<=0)exit(4);
  }
  //关闭文件
  close(in_fd)；
  close(out_fd);
  //没有读取错误
  if(rd_count == 0)
    //没有读取错误
    exit(0);
  else
    //有读取错发生
    exit(5);
}
```

## 4.2 目录

- ​文件系统通常提供目录或文件夹用于记录文件，在很多系统中目录本身也是文件                                                                                                                                                                                                                                              

## 4.2.1 一级目录系统

- 根目录
  - 目录系统的最简单形式是在一个目录中包含所有的文件
  - 世界上第一台超级计算机CDC 660对于所有的文件也只有一个目录
  - 这种目录系统经常用于简单的嵌入式中，诸如电话、数码相机以及一些便携式音乐播放器等

### 4.2.2 层次目录系统

- 对于简单的特殊应用而言，单层目录是合适的
  - 单层目录甚至用在了第一代个人计算机中
- 层次结构，即一个目录树
  - 通过这种方式，可以用很多目录把文件以自然的方式分组
- 用户可以创建任意数量的子目录
  - 这种能力为用户组织起工作提供了强大的结构化工具

### 4.2.3 路径名

- 用目录树组织文件系统时，需要有某种方法指明文件名
  - absolute path name，第一种是，每个文件都赋予一个绝对路径名
    - 它由从根目录到文件的路径组成
      - 在UNIX中，路径各部分之间用“/”分隔
      - 在Windows中，分隔符是“\”\
      - 在MULTICS中是“>”
    - 不管采用哪种分隔符，如果路径名的第一个字符是分隔符，则这个路径就是绝对路径
  - relative path name，另一种指定文件名的方法是使用相对路径名
    - 它常和工作目录（working directory）（也称作当前目录（current directory）一起使用
    - 用户可以指定一个目录作为当前工作目录
      - 这时，所有的不从根目录开始的路径名都是相对于工作目录的
    - 相对路径往往更方便，而它实现的功能和绝对路径完全相同
- 一些程序需要存取某个特定文件，而不论当前目录是什么
  - 应该采用绝对路径名
  - 若要从目录中读很多文件，可以用另一种方法
    - 执行一个系统调用把该程序的工作目录切换到/usr/lib，然后只需用dictionary作为open的第一个参数
    - 通过显式地改变工作目录，可以知道该程序在目录树中的确切位置，进而可以采用相对路径名、
- 每个进程都有自己的工作目录
  - 这样在进程改变工作目录并退出后，其他进程不会受到影响，文件系统中也不会有改变的痕迹
- 支持层次目录结构的大多数操作系统在每个目录中有两个特殊的目录项“.”和“..”，常读作“dot”和“dotdot”
  - dot指当前目录
  - dotdot指其父亲目录（在根目录中例外，根目录中它指向自己
    - $cp../lib/dictionary$.
      - 把文件usr/lib/dictionary复制到自己的目录下。
      - 第一个路径告诉系统上溯（到usr目录），然后向下到lib目录，找到dictionary文件
      - 第二个参数（.）指定当前目录
        - 当cp命令用目录名（包括“.”）作为最后一个参数时，则把全部的文件复制到该目录中
      - $cp/usr/lib/dictionary.$
        - 是更常用的方法
        - 用户这里采用“.”可以避免键入两次dictionary

### 4.2.4 目录操作

- 不同系统中管理目录的系统调用的差别比管理文件的系统调用的差别大
- 为了了解这些系统调用有哪些及它们怎样工作（取自UNIX）
  - create
    - 创建目录
    - 除了目录项“.”和“..”外，目录内容为空
  - delete
    - 删除目录
    - 只有空目录可删除
    - 值包含目录项“.”和“..”的目录被认为是空目录，这两个目录项通常不能删除
    - opendir
      - 目录内容可被读取
        - 与打开和读文件相同，读目录前，必须打开目录
    - closedir
      - 读目录结束后应关闭以释放内部表空间
    - readdir
      - 系统调用readdir返回打开目录的下一个 目录项
    - rename
      - 在很多方面目录和文件都相似
    - link
      - 连接技术允许在多个目录中出现同一个文件
      - hard link，硬链接
        - 这种类型的连接，增加了该文件的i节点（i-node）计数器的计数（记录含有该文件的目录项数目）
    - unlink
      - 删除目录项
      - 在UNIX中，用于删除文件的系统调用实际上就是unlink
- 符号连接
  - 关于连接文件的一种不同想法
  - 优点在于它能够跨越磁盘的界限，甚至可以命名在远程计算机上的文件
  - 不过符号连接的实现并不如硬链接那样有效率

## 4.3 文件系统的实现

- 用户关心的是文件是怎样命名的、可以进行哪些操作、目录树是什么样的以及类似的界面问题
- 而实现者感兴趣的是文件和目录是怎样存储的、磁盘空间是怎样管理的以及怎样使系统有效而可靠地工作等

### 4.3.1 文件系统布局

- 文件系统存放在磁盘上，多数磁盘划分为一个或多个分区，每个分区中有一个独立的文件系统


- Master Boot Record，主引导记录
  - 磁盘的0号扇区称为主引导记录
  - 用来引导计算机
- 在MBR的结尾是分区表
  - 该表给出了每个分区的起始和结束地址
  - 活动分区
    - 表中的一个分区
  - 在计算机被引导时，BIOS读入并执行MBR
    - boot block，引导块
      - MBR做的第一件事是确定活动分区，读入它的第一个块
      - 引导快中的程序被装载该分区中的操作系统
- 除了从引导块开始之外，磁盘分区的布局是随着文件系统的不同而变化的
  - superblock，超级块
    - 超级块包含文件系统的所有关键参数
    - 在计算机启动时，或者在该文件系统首次使用时，把超级块存入内存
    - 超级块中的典型信息包括
      - 确定文件系统类型用的魔数
      - 文件系统中数据块的数量
      - 其他重要的管理信息
  - 文件系统中的空闲块的信息
    - 后面也许跟随的是一组i节点
    - 接着可能是根目录
      - 存文件系统目录树的根部
    - 磁盘的其他部分存放了其他所有的目录和文件

### 4.3.2 文件的实现

- 文件存储的实现的关键问题是记录各个文件分别用到哪些磁盘块
- 连续分配
  - 最简单的分配方案是把文件作为一连串连续数据存储在磁盘上
    - 每个文件都从一个新的块开始
  - 连续磁盘空间分配方案有两个优势
    - 实现简单，记录每个文件用到的磁盘简化为只需记住两个数字即可
      - 第一块的磁盘地址和文件的块数
    - 读操作性能较好
      - 因为在单个操作系统中就可以从磁盘上读出整个文件
  - 同样有相当明显的不足之处
    - 随着时间的推移，磁盘会变得零碎
  - 存在着一种情形，使得连续分配方案是可行的
    - 实际上，这个办法在CD-ROM上被广泛使用着
    - DVD的情况有些复杂
      - University Disk Format，UDF格式
        - 使用了一个30位的数来代表文件长度，从而把文件大小限制在1GB
        - DVD电影一般存储在3个或4个1GB的连续文件中
      - extents
        - 这些构成一个逻辑文件（电影）的物理文件块


- 链表分配
  - 为每个文件构造磁盘块链表
  - 这一方法可以充分利用每个磁盘块
  - 尽管顺序读文件非常方便，但是随即存取却相当缓慢
  - 由于指针占用去了一些字节，每个磁盘块存储数据的字节数不再是2的整数次幂
- 在内存中采用表的链表分配
  - 如果取出每个磁盘块的指针字，把它放在内存的一个表中
    - 就可以解决上述链表的两个不足
  - File Allocation Table，FAT，文件分配表
    - 内存中的这样一个表格称为文件分配表
  - 按这类方式组织，整个块可以存放数据
    - 这种法法的主要缺点是必须把整个表都存放在内存中
  - FAT方案对于大磁盘而言不太合适
- index-node，i节点
  - 给每个文件赋予一个称为i节点的数据结构
    - 其中累出来文件属性和文件块的磁盘地址
    - 给定i节点，就有可能找到文件的所有块
    - 这种机制具有很大的优势
      - 只有在对应文件打开时，其i节点才在内存中
      - 这个数组通常比上一节中叙述的文件分配表（FAT）所占据的空间要小
      - 保留所有磁盘块的链接表的表大小正比于磁盘自身的大小
    - i节点的一个问题、
      - 如果每个i节点只能存储固定数量的磁盘地址，那么当一个文件所含的磁盘块的数目超出了i基地单所能荣南的数目怎么办
        - 一个解决方案是最后一个“磁盘地址”不指向数据块，而是指向一个包含块地址的块的地址
        - 可以有两个或更多个包含磁盘地址的块或者指向其他存放地址的磁盘块的磁盘块

### 4.3.3 目录的实现

- 目录系统的主要功能
  - 把ASCⅡ文件名映射成定位文件数据所需的信息
- 与此密切相关的问题在何处存放文件属性
  - 把文件属性直接存放在目录项中
    - 目录中有一个固定大小的目录项列表，每个文件对应一项，其中包含一个（固定长度）文件名，一个文件属性结构以及用以说明磁盘块位置的一个或多个磁盘地址
  - 把文件属性放在i节点中而不是目录中
    - 这种方法更好
- 所有现代操作系统都支持可变长度的长文件名
  - 给予文件名一个长度限制
    - 这种处理很简单，但是浪费了大量的目录空间
  - 放弃“所有目录项大小一样”的想法
    - 一个目录项有一个固定部分，这个固定部分通常以目录项的长度开始，后面是固定格式的数据
    - 这个方法的缺点是
      - 当移走文件后，就引入一个长度可变的空隙
      - 一个目录项可能会分在多个页面上
  - 使目录项自身都有固定长度，而将文件名放置在目录后面的堆中
    - 当一个文件目录项被移走后，另一个文件的目录项总是可以适合这个空隙
    - 文件名不再需要从字的边界开始
  - 对于非常长的目录，线性查找就太慢了
    - 加快查找速度的方法
      - 在每个目录中使用散列表
      - 对构成文件名的字求和，其结果被n除，或某些类似的方法
    - 不论哪种方法都要对散列码相对应的散列表表项进行检查
      - 查找文件按照相同的过程进行
      - 使用散列表的优点
        - 查找非常迅速
      - 使用散列表的缺点是
        - 需要复杂的管理
        - 只有在预计系统中的目录经常会有成百上千个文件时，才能把散列方案作为使用方案
    - 一种完全不同的加快大型目录查找速度的方法是
      - 将查找结果存入高速缓存
      - 只有在构成查找主体的文件非常少的时候，方案才有效果

### 4.3.4 共享文件

- 当几个用户在同一个项目中工作时，他们常常需要共享数据
- link，连接
  - 目录与共享文件的联系
- Directed Acyclic Graph，DAG
  - 文件系统本身是一个有向无环图，而不是一棵树
- 共享文件是方便的，但也带来一些问题
  - 如果目录中包含磁盘地址，则新的数据块将只列入进行添加工作的用户的目录中
    - 磁盘块不列入目录，而是列入一个与文件本身关联的小型数据结构中
    - UNIX系统中所采用的方法
    - 小型数据结构即是i节点
  - 通过让系统建立一个类型为LINK的新文件
    - symbolic linking，符号连接
      - 当读该连接文件时，操作系统查看要读的文件时LINK类型，则找到该文件所连接的文件的名字，并且去读那个文件
  - 指向目录的指针不能存储在i节点中
    - 有可能有无数个目录
    - 对于符号连接，不会发生
      - 因为只有真正的文件所有者才有一个指向i节点的指针
  - 符号连接的问题
    - 需要额外的开销
    - 必须读取包含路径的文件，然后一个部分一个部分地扫描路径，直到直到i节点
    - 符号连接有一个优势
      - 只要简单地提供一个机器的网络地址以及文件在该机器上驻留的路径，就可以连接全球任何地方的机器上的文件
  - 还有另一个有连接带来的问题
    - 在符号连接和其他方式中都存在
    - 查找一指定目录及其子目录下的全部文件的程序将多次定位到被连接文件

### 4.3.5 日志结构文件系统

- Log-structured File System，LFS，日志结构文件系统
  - 没有得到快速发展的参数是磁盘的寻道时间
  - Berkeley设计了一种全新的文件系统，试图缓解这个问题
- 促使设计LFS的主要原因是
  - CPU的运行速度越来越快，RAM内存容量变得更大，同时磁盘高速缓存也迅速地增加
  - 这样，在一些文件系统中使用的提前读机制，并不能获得很好的性能
  - 更为糟糕的情况是，大多数文件系统中，写操作往往都是零碎的
  - 为了写文件，必须写该文件目录的i节点、目录块、文件的i节点以及文件本身
- LFS的设计者绝额定重新实现一种UNIX文件系统
  - 其基本思想是
    - 将整个磁盘结构化为一个日志
  - 在LFS的设计中，同样存在着i节点，且具有与UNIX中一样的结构，但是i节点分散在整个日志中，而不是放在磁盘的某一个固定位置
    - 为了能找到i节点，必须要维护一个由i节点编号索引组成的i节点图
  - 总而言之，所有的写操作最初都被缓冲在内存中，然后周期性地把所有已缓冲的写作为一个单独的段，在日志的末尾处写入磁盘
  - LFS有一个清理线程
    - 该清理线程周期地扫描日志进行磁盘压缩
  - LFS在处理大量的零碎的写操作时性能上优于UNIX，而在读和大块写操作的性能方面并不比UNIX文件系统差

### 4.3.6 日志文件系统

- 虽然基于日志结构的文件系统以一个很吸引人的想法，但是由于它们和现有的文件系统不相匹配，所以还没有被广泛应用
- 这里的基本想法是
  - 保存一个用于记录系统下一步将要做什么的日志
- 日志文件系统
  - 当系统在完成它们即将完成的任务崩溃时，重新启动后，可以通过查看日志，获取崩溃计划完成的任务，并完成它们
  - 微软（MIcrosoft）的NTFS文件系统、Linux ext3和ReiserFS文件系统都使用日志
- 考虑一个简单、普通并经常发生的操作：
  - 移出文件
  - 在UNIX中需要三个步骤
    - 在目录中删除文件
    - 释放i节点到空闲i节点池
    - 将所有磁盘块归还空闲磁盘块池
  - 在Windows中，也需要类似的步骤
- 日志文件系统则先写一个日志项，列出三个将要完成的动作。然后日志项被写入磁盘
- 为了让日志文件系统工作，被写入日志的操作必须是幂等的‘
  - 它意味着只要有必要，它们就可以重复执行很多次，并不会带来破坏
- atomic transaction，原子事务
  - 为了增加可信性，一个文件系统可以引入数据库中原子事务的概念
- NTFS有一个拓展的日志文件系统，并且它的结构几乎不会因系统崩溃而受到破坏
  - Linux上有日志功能的第一个文件系统是ReiserFS

### 4.3.7 虚拟文件系统

- 一个Windows可能有一个主要的NTFS文件系统，但是也有继承的FAT-32或FAT-16驱动，或包含旧的但仍被使用的数据的分区
  - 并且不时地可能需要一个CD-ROM或者DVD
- 现代的UNIX系统做了一个很认真的尝试
  - 将多种文件系统整合到一个统一的结构中
    - 一个Linux系统可以用ext2作为根文件系统，ext3分区装载在/home下，另一块采用ReiserFS文件系统的硬盘装载到/home下，以及一个ISO 9660的CD-ROM临时装载在/mnt下
- Virtual FIle System，VFS，虚拟文件系统
  - 绝大多数UNIX操作系统都使用虚拟文件系统
  - 将多种文件系统统一成一个有序的框架
  - 关键思想是
    - 抽象出所有文件系统都共有的部分，并且将这部分代码放在单独的一层，该层调用底层的实际文件系统来具体管理数据
  - 所有和文件相关的系统调用在最初的处理上都指向虚拟文件系统
    - 这些来自用户进程的调用，都是标准的POSIX系统调用
    - POSIX接口
      - 虚拟文件系统对用户进程有一个“更高层”接口，它就是著名的POSIX接口
- VFS也有一个对于实际文件系统的“更底层”接口
  - 这个接口包含许多功能调用，这样VFS可以使每一个文件完成任务
  - VFS有两个不同的接口
    - 上层给用户进程的接口
    - 下层给实际文件系统的接口
  - Network File System，NFS，网络文件系统
    - Sun建立虚拟文件系统最原始的动机是支持使用NFS协议的远程文件系统
    - VFS设计是只要实际的文件系统提供VFS需要的功能
  - 大多数VFS应用本质上都是面向对象的
    - 有几种通常支持的主要的对象类型，包括
      - 超块，描述文件系统
      - v节点，描述文件
      - 目录，描述文件系统目录
    - VFS有一些供它自己使用的内部数据结构，包括
      - 用于跟踪用户进程中所有打开文件的装载表
      - 文件描述等数组
- VFS是如何工作的
  - 当系统启动时，根文件系统在VFS中注册
    - 当一个文件系统注册时，它做的最基本而的工作就是提供一个包含VFS所需的函数地址的列表
      - 可以是一个长的调用矢量（表），或者是许多这样的矢量，每个VFS对象一个
    - VFS也知道如何执行实际文件系统提供的每一个其他功能
      - 它只需要调用某个功能，该功能的所在的地址在文件系统注册时就提供了
  - 装载文件系统后就可以使用它了
    - 当解析路径时，VFS看到新的文件系统被装载到/usr，并且通过搜索已经装载文件的超块表来确定它的超块
    - 然后VFS创建一个v节点并调用实际文件系统，以返回所有的在文件i节点中的信息
      - 这个信息被和其他信息一起复制v节点中（在RAM中），而这些信息中最重要的是指向包含调用v节点操作的功能表的指针
  - 当v节点被创建以后，VFS在文件扫描符表中为调用进程创建一个入口，并且将他指向一个新的v节点
    - 为了简单，文件描述符实际上指向另一个包含当前文件位置和指向v节点的指针的数据结构
  - 最后，VFS项调用者返回文件描述符，所以调用者可以用它去读、写或者关闭文件
- 随后，当进程用文件描述符进行一个读操作，VFS通过进程表和文件描述符表确定v节点的位置，并跟随指针指向功能表
  - 从调用者进程号和文件描述符开始，进而是v节点，读功能指针，然后是对实际文件系统的入口函数定位
- 通过这种方法，加入新的文件系统变得相当直接
  - 设计者首先获得一个VFS期待的功能调用的列表
  - 然后编写文件系统实现这些功能
- 如果文件系统已经存在
  - 它们必须提供VFS需要的包装功能
    - 通常通过建造一个或者多个内在的指向实际文件系统的调用来实现

## 4.4 文件系统管理和优化

- 使真实世界中的文件系统有效、鲁棒地工作

### 4.4.1 磁盘空间管理

- 文件通常存放在磁盘上，所以对磁盘空间的管理是系统设计者要考虑的一个主要问题

  - 存储n个字节的文件可以有两种策略：
    - 分配n个字节的连续磁盘空间
    - 把文件分成很多各个连续（或并不一定连续）的块
  - 在存储管理系统中，分段处理和分页处理之间也要进行同样的权衡
  - 几乎所有的文件系统都把文件分割成固定大小的块来存储，各块之间不一定相邻

- 块大小

  - 把文件按固定大小的块来存储，就会出现一个问题

    - 块的大小是多少
    - 按照磁盘组织方式，扇区、磁道和柱面显然都可以作为分配单位
    - 在分页系统中，页面大小也是主要讨论的问题之一

  - 如果分配的单元太大，则浪费了空间；如果太小，则浪费时间

  - 做出一个好的决策需要知道有关文件大小分配的信息

    - 磁盘被少量的大文件（视频）给占用了，并且小文件所占空间的总量根本无关紧要
    - 分配单位很小意味着每个文件由很多块组成
      - 读取由很多小块组成的文件会非常慢

  - 磁盘数据率和磁盘空间利用率曲线得到

    - 对一个块的访问时间完全由寻道时间和旋转延迟所决定
      - 因此，数据率随着磁盘块的增大而增大
        - 直到传输花费很长的时间以至于传输时间成为主导因素
    - 空间利用率
      - 一个文件的最后一个磁盘块中总是有一些空间浪费
    - 这些曲线显示出性能与空间利用率天生就是矛盾的
      - 小的块会导致低的性能但是高的空间利用率
      - 对于这些数据，不存在合理的折中方案

  - NT的文件使用情况比UNIX的文件使用情况复杂得多

    - 当我们在notepad文本编辑器中输入一些字符后，将内容保存到一个文件中将触发26个系统调用，包括3个失败的open企图、1个文件重写和4个打开和关闭序列

    - 文件大小的中间值（以使用情况作为权重）

      - 只读的为1KB，只写的为2.3KB，读写的文件为4.2

        KB

- 记录空闲块

  - 一旦选定了块大小，下一个问题就是怎样跟踪空闲块
    - 第一种方法是采用磁盘块链表
      - 每个块中包含尽可能多的空闲磁盘块号
    - 另一种空闲磁盘空间管理的方法是采用位图
      - n个块的磁盘需要n位位图
      - 在位图中，空闲块用1表示，已分配块用0表示
      - 位图方法所需空间少
  - 如果空闲块倾向于成为一个长的连续分块的话，则空闲列表系统可以改成记录分块而不是单个的块
    - 在最好的情况下，一个基本上空的磁盘可以用两个数表达
      - 第一个空闲块的地址
      - 空闲块的计数
    - 如果磁盘产生了很严重的碎片，记录分块会比记录单独的块效率要低
      - 因为不仅要存储地址，而且还要存储计数
  - 这种情形说明了一个问题
    - 有许多数据结构与算法可以用来解决一个问题，但选择其中最好的则需要数据，而这些数据是设计者无法预先拥有的，只有在系统被部署完毕并被大量使用后才会获得
      - 更有甚者，有些数据可能就是无法获取
  - 空闲表方法只需要在内存中保存一个指针块
    - 在某些特定情形下，这个方法产生了不必要的磁盘I/O
  - 一个可以避免过多I/O的替代策略是
    - 拆分满了的指针块
    - 思想是
      - 保持磁盘上的大多数指针块为满的状态（减少磁盘的使用），但是在内存中保留一个丰满的指针块
        - 这样它可以既处理文件的创建又同时处理文件的删除操作，而不会为空闲表进行磁盘I/O
  - 对于位图，在内存中保留一个块是有可能的
    - 只有在该块满了或空了的情形下，才到磁盘上区另一块
    - 好处是通过位图的单一块上进行所有的分配操作，磁盘块会较为紧密地聚集在一起，从而减少了磁盘臂的运动

- 磁盘配额

  - 为了防止人们贪心而占有太多的磁盘空间，多用于操作系统常常提供一种强制性磁盘配额机制
    - 思想是系统管理员分给每个用户拥有文件和块的最大数量，操作系统确保每个用户不超过分给他们的配额
  - 当用户打开一个文件时，系统找到文件属性和磁盘地址，并把它们送入内存中的打开文件表
  - 第二张表包含了每个用户当前打开文件的配额记录，并把它们送入内存中的打开文件表
    - 该表的内容是从被打开文件的所有者的磁盘配额文件中提取出来的
  - 当在打开文件表中建立一新表项时，会产生一个指向所有者配额记录的指针
  - 当用户试图登录时，系统检查配额文件，查看该用户文件数目或磁盘块数目是否超过软限制
    - 这一方法具有一种性质，即只要用户在退出系统前消除所超过的部分，他们就可以在一次终端会话期间超过其软限制
    - 但无论什么情况下都不能超过硬限制

### 4.4.2 文件系统备份

- 比起计算机的损坏，文件系统的破坏往往要糟糕得多
- 做磁带备份主要是要处理好两个潜在问题中的一个：
  - 从意外的灾难中恢复
    - 第一个问题主要是由磁盘破裂、火灾、洪水等自然灾害引起的
  - 从错误的操作中恢复
    - 第二个额原因主要是用户意外地删除了原本还需要的文件
    - 这种情况发生地很频繁，使得Windows的设计者们针对“删除”命令设计了特殊目录
      - 回收站
        - 在人们删除文件的时候，文件本身并不真正从磁盘上消失，而是被放置到这个特殊目录下，代以后需要的时候可以还原回去
- 为文件做备份既耗时间又费空间，所以需要做得又快又好
  - 首先，是要备份整个儿文件系统还是备份一部分呢
    - 在UNIX中，所有的特殊文件（也就是I/O设备）都放置在/dev目录下，对这个目录做备份不仅没有必要而且还十分危险
    - 合理的做法是只备份特定目录及其下的全部文件，而不是备份整个文件系统
  - 其次，对前一次备份以来每个更改过的文件再做备份是一种浪费，因而产生了增量转储的思想
    - 最简单的增量转储形式就是周期性地（每周一次或没有一次）做全面的转储（备份），而每天只对当天更改的数据做备份
    - 稍好一点的做法只备份最近一次转储以来更改过的文件
    - 极大地缩减了转储时间，但操作起来却更复杂
    - 为了方便，人们忘完更实用更复杂的增量转储模式
  - 第三，既然待转储的往往是海量数据，那么将其写入磁带之前对文件进行压缩就很有必要
  - 第四，对活动文件系统做备份是很难的
    - 因为在转储过程中添加、删除或修改文件和目录可能会导致文件系统的不一致性
      - 人们修改了转储算法，记下文件系统的瞬间状态，即复制关键的数据结构，然后把将来对文件和目录所做的修改复制到块中，而不是处处更新它们
  - 第五，即最后一个问题，做备份会给一个单位引入很多非技术性问题
    - 备份磁带应该远离现场存放
- 转储磁盘到磁带上有两种方案
  - 物理转储
    - 从磁盘的第0块开始，将全部的磁盘块按序输出到磁带上，直到最后一块复制完毕
    - 物理转储的评价
      - 未使用的磁盘块无须备份
        - 项略过未使用的磁盘块就需要在每个磁盘块前边写下该磁盘块的号码
      - 坏块的转储
        - 有时进行低级格式化后，坏块会被检测出来，标记为坏的，并被应对这种紧急状况的在每个轨道末端的一些空闲块所替换
        - 有时格式化后块也会变坏，在这种情况下操作系统可以检测到它们
          - 可以通过建立一个包含所有坏块的“文件”来解决这个问题
        - 如果磁盘控制器将所有坏块重新映射，并对操作系统隐藏的话，物理转储工作还是能够顺利进行的
      - 主要优点是简单、极为快速（基本上是以磁盘的速度运行）
      - 主要缺点是，既不能跳过选定的目录，也无法增量转储，还不能满足恢复个人文件的请求
        - 正因如此，绝大部分配置都使用逻辑转储
  - 逻辑转储
    - 逻辑转储从一个或几个指定的目录开始，递归地转储其自给定基准日期后有所更改的全部文件和目录
      - 例如，最近一次增量转储或全面系统转储的日期
    - 转储磁带上会有一连串精心标识的目录和文件，这样就很容易满足恢复特定文件或目录的请求
    - 在UNIX系统上广为使用的通用算法
      - 该算法还转储通向修改过的文件或目录的路径上的所有目录（甚至包括未修改的目录）
        - 为了将这些转储的文件和目录恢复到另一台计算机的新文件系统中
        - 为了可以对单个文件进行增量恢复（很可能是对愚蠢操作所损坏文件的恢复
- 逻辑转储算法要维持一个以i节点号为索引的位图，每个i节点包含了几位
  - 算法的执行分为四个阶段
    - 第一阶段从起始目录开始检查其中的所有目录项
      - 第一阶段结束时，所有修改过的文件和目录都在位图中标记了
    - 第二阶段再次递归地遍历目录树，并去掉目录树中任何不包含被修改过的文件或目录上的标记
      - 为了提高算法效率，可以将这两个阶段的目录树遍历合二为一
    - 第三阶段算法将以节点号为序，扫描这些i节点并转储所有标记的目录
      - 为了进行恢复，每个被转储的目录都用目录的属性（所有者、时间等）作为前缀
    - 第四阶段中被标记的文件也被转储，同样，由其文件属性作为前缀
- 从转储磁带上恢复文件系统很容易办到
  - 首先要在磁盘上创建一个空的文件系统，然后恢复最近一次的完整转储
  - 恢复目录，给出文件系统的框架，然后恢复文件本身
- 尽管逻辑转储十分简单，还是有几点棘手之处
  - 首先，既然空闲块列表并不是一个文件，那么在被转储的文件恢复完毕之后，就需要重新开始构造
  - 另一个问题是关于连接。如果一个文件被连接到两个或多个目录中，要注意在恢复时只对该文件恢复一次，然后要恢复所有指向该文件的目录
  - 还有一个问题是，UNIX文件实际上包含了许多“空洞”
  - 最后，无论属于哪一个目录，特殊文件、命名管道以及类似的文件都不应该转储
- 磁带密度不会像磁盘密度那样改进得那么快
  - 这会导致备份一个很大的磁盘需要多个磁带的状况
  - 在那种情况下，备份一个磁盘的惟一方式是在另一个磁盘上
    - 对每一个磁盘直接做镜像是一种方式
    - 一个更加复杂的方案，称为RAID

### 4.4.3 文件系统的一致性

- 影响文件系统可靠性的另一个问题是文件系统的一致性
- 为了解决文件系统的不一致问题，很多计算机都带有一个实用程序以检验文件系统的一致性
  - UNIX有fsck，而Windows用scandisk
- 一致性检查分为两种：
  - 块的一致性检查
    - 在检查块的一致性时，程序构造两张表，每张表中为每个块设立一个计数器，都初始化为0
      - 第一个表中的计数器跟踪该块在文件中的出现次数
      - 第二个表中的计数器跟踪该块在空闲表中的出现次数
    - 接着检验程序使用原始设备读取全部的i节点，忽略文件的结构，只返回所有的磁盘块，从0开始
  - 文件的一致性检查
    - 如果文件系统一致，则每一块或者在第一个表计数器中为1，或者在第二个表计数器中为1
- 块丢失
  - 磁盘块没有出现在任何一张表中
  - 块丢失问题的解决很容易
    - 文件系统检验程序把它们加到空闲表中即可
- 出现重复
  - 只在空闲表是真正意义上的一张表时，才会出现重复，在位图中，不会发生这类情况
  - 解决方法也很简单：
    - 只要重新建立空闲表即可
- 最糟的情况是，在两个或多个文件中出现同一个数据块
  - 文件系统检验程序可以采取相应的处理方法是
    - 先分配一空闲块，把块5中的内容复制到空闲块中，然后把它插到其中一个文件之中
    - 除检查每个磁盘块计数的正确性之外，文件系统检验程序还检查目录系统
    - 在检验程序全部完成后，得到一张由i节点号索引的表，说明每个文件被多少个目录包含
      - 有可能出现两种错误，即i节点中的连接计数太大或者太小
        - 如果i节点的连接计数大于目录项个数，这时即使所有的文件都从目录中删除，这个计数仍是非0，i节点不会被删除
        - 另一种错误则是潜在的灾难
          - 这会导致其中一个目录指向一未使用的i节点，而很有可能其块马上就被分配给其他文件
          - 解决方法同样是把i节点中连接计数设为目录项的实际个数值
- 由于效率上的考虑，以上的块检查和目录检查经常被集成到一起（即仅对i节点扫描一遍）
- 每个i节点都有一个访问权限项
  - 一些访问权限是合法的，但是很怪异
- 某一些文件系统也防止用户自身的误操作
  - 在MS-DOS和一些其他系统中，文件的删除仅仅是在对应目录或i节点上设置某一位，表示文件被删除，并没有吧磁盘块返回到空闲表中，知道确实需要时才这样做
  - 在Windows中，删除的文件被转移到回收站目录中（一个特别的目录），稍后若需要，可以从那里还原文件

### 4.4.4 文件系统性能

- 访问磁盘比访问内存慢得多
- 考虑到访问时间的这个差异，许多文件系统采用了各种优化措施以改善性能
  - 高速缓存
    - block cache，高速缓存
    - buffer cache，缓冲区高速缓存
      - 最常用的减少磁盘访问次数技术是块高速缓存或者缓存区高速缓存
      - 高速缓存指的是一系列的块，它们在逻辑上属于磁盘，但实际上基于性能的考虑被保存在内存中
- 管理高速缓存有有不同的算法，常用的算法是
  - 检查全部的的读请求，查看在高速缓存中是否有所需要的块
    - 由于在高速缓存中有许多块，所以需要有某种方法快速确定所需要的块是否存在
      - 常用的方法是将设备和磁盘地址进行散列操作，然后，在散列表中查找结果
    - 如果高速缓存缓存已满，则需要调入原来的块调出高速缓存
  - 这种情况与分页非常相似，所有常用的页面置换算法都适用于高速缓存
    - 与分页相比，高速缓存的好处在于对高速缓存的引用不很频繁
    - 除了散列表的冲突之外，还有一个双向链表把所有的块按照使用时间的先后次序链接起来
      - 存在一种情形，使我们有可能获得精确的LRU，但是碰巧该LRU却又不符合要求
      - ​

## 4.5 文件系统实例

### 4.5.2 MS-DOS文件系统

- 这个限制对于存储采用DV标准的数字视频来说，一个2GB的文件仅能保存9分钟多一点的视频

- 随着Windows 95第2版的发行，引入了FAT-32文件系统，它具有28位磁盘地址

  - 在这个系统中，分区理论上能达到$2^{28}×2^{15}$ 字节
  - 但实际上是限制在2TB（2048GB）
    - 因为系统在内部的512字节长的扇区中使用了一个32位的数字来记录分区的大小
  - 对应不同的块大小的最大分区

  |  块大小  | FAT-12 | FAT-16 | FAT-32 |
  | :---: | :----: | :----: | :----: |
  | 0.5KB |  2MB   |        |        |
  |  1KB  |  4MB   |        |        |
  |  2KB  |  8MB   | 128MB  |        |
  |  4KB  |  16MB  | 256MB  |  1TB   |
  |  8KB  |        | 512MB  |  2TB   |
  | 16KB  |        | 1024MB |  2TB   |
  | 32KB  |        | 2048MB |  2TB   |

- FAT-32文件系统相比FAT-16文件系统有另外两个优点

  - 一个FAT-32的8GB磁盘可以是一个分区，而使用FAT-16则必须是四个分区
  - 对于一个给定大小的硬盘分区，可以使用一个小一点的块大小
    - 使用小块的好处是大部分文件都小于32KB

- MS-DOS使用FAT来跟踪空闲磁盘块

  - 所以不需要位图或者空闲表

### 4.5.3 UNIX V7文件系统

- 即使是早期版本的UNIX也有一个相当复杂的多用户文件系统
  - 因为它是从MULTICS继承下来的
- UNIX V7文件系统从根目录开始形成树状，加上链接，形成了一个有向无环图
- UNIX目录中为每个文件保留了一项
  - 每项都很简单，因为UNIX使用i节点
  - 一个目录项包含了两个域
    - 文件名（14个字节）
    - i节点的编号（2个字节）
- UNIX的i节点包含一些属性，包括
  - 文件大小
  - 三个时间
    - 创建时间
    - 最后访问时间
    - 最后修改时间
  - 所有者
  - 所在组
  - 保护信息
  - 一个计数
    - 用于记录指向i节点的目录项的数量
    - 为了链接而设的
- single indirect block，一次间接块
  - 对于大一些的文件，i节点内的其中一个地址是称为一次间接块的磁盘块地址
    - 这个块包含了附加的磁盘地址
  - double indirect block，二次间接块
    - 如果还不够的话，在i 节点中还有另一个地址，称为二次间接块
      - 它包含了一个块的地址，在这个快中包含若干个一次间接块。每一个这安阳的一次间接块指向数百个数据块
  - triple indirect block，三次间接块
    - 如果这样还不够的话，可以使用三次间接块
- 当打开某个文件系统时，文件系统必须要获得文件名并且定位它所在的磁盘块
  - 首先，文件系统定位根目录
  - 接下来，系统读根目录并且在根目录中查找路径的的第一个分量usr，以获取/usr目录的i节点号
    - 由i节点号来定位i节点是很直接的
    - 根据这个i节点，系统定位/usr目录并在其中查找下一个分量ast
    - 同理，查找mbox
    - 然后，这个文件的i节点被读入内存，并且在文件关闭之前一直保留在内存中
- 相对路径名的查找同绝对路径名的查找方法相同
  - 每个目录都有.项和..项，它们是在目录同时创建的
    - .表项是当前目录的i节点号，而..表项是父目录的i节点号
    - 目录系统只要把这些名字看做普通的ASCⅡ字符串即可

## 4.6 有关文件系统的研究

- 有关文件系统的研究总是比操作系统的其他部分吸引了更多的研究
- 很多后续的关于优化高速缓存管理的研究
- 新类型的文件系统
  - 用户级别的文件系统
  - 闪存文件系统
  - 日志文件系统
  - versioning，版本控制文件系统
  - peer-to-peer，对等文件系统
  - Google文件系统也不寻常，因为他有极好的容错性能
- 文件系统内不同的查询方法也是很有意义的
- provenance，起源
  - 追踪数据的历史，包括它们
    - 来自哪里，谁拥有它们，以及它们是如何转换的
  - 与备份有关的还有，设法保持数据几十年，并仍旧可以使用
  - 可靠性与安全性也是需要解决的问题
  - 性能始终是一个值得研究的主题

## 习题

1. 在早期的UNIX系统中，可执行文件（a.out）以一个非常特别的魔数开始，这个数不是随机选择的。这些文件都有文件头，后面是正文段和数据段。为什么要为执行文件挑选一个非常特别的魔数，而其他类型文件的第一个字反而有一个或多或少是随机选择的魔数？

- 这些系统直接把程序载入内存，并且从word0（魔数）开始执行。为了避免将header作为代码执行，魔数是一条branch指令，其目标地址正好在header之上。按这种方法，就可能把二进制文件直接读取到新的进程地址空间，并且从0开始运行。

1. 在图4-4中，一个属性是记录长度。为什么操作系统要关心这个属性？

- 当文件可以被构造为多个记录并且每个记录的特定位置具有键时，操作系统要关心记录长度这个属性，可以通过给定的键访问记录。在这种情况下，系统必须知道记录有多大，才可以通过键搜索到每个记录。

1. 在UNIX中open系统调用绝对需要吗？如果没有会产生什么结果？

- 首先，如果没有open系统调用，每次读取文件都需要指定要打开的文件的名称。系统将必须获取其i节点，虽然可以缓存它，但面临一个问题是何时将i节点写回磁盘。可以在超时后写回磁盘，虽然这有点笨拙，但它可能起作用。

1. 在支持顺序文件的系统中总有一个文件回绕操作，支持随机存取文件的系统是否也需要该操作？

- 否。如果要再次读取文件，只需随机访问字节0。

1. 某一些操作系统提供系统调用rename给文件重命名，同样也可以通过把文件复制到新文件并删除原文件而实现文件重命名。请问这两种方法有何不同？

- rename调用不会改变文件的创建时间和最后的修改时间，但是创建一个新的文件，其创建时间和最后的修改时间都会改为当前的系统时间。另外，如果磁盘满，复制可能会失败。

1. 在有些系统中有可能把部分文件映射进内存中。如此一来系统应该施加什么限制？这种部分映射如何实现？

- 文件的映射部分必须以页边界开始，并且长度为整数页数。每个映射的页面使用文件本身作为后备存储。未映射的内存使用临时文件或分区作为后备存储。

1. 有一个简单操作系统只支持单一目录结构，但是允许该目录中有任意多个文件，且带有任意长度的名字。这样可以模拟层次文件系统吗？如何进行？

- 使用文件名，如/usr/ast/file。虽然它看起来像一个层次化的路径名称，但它只是一个包含嵌入的斜杠的单一名称。

1. 在UNIX 和Windows 中通过使用一个特殊的系统调用把文件的“当前位置”指针移到指定字节，从而实现了随机访问。请提出一个不使用该系统调用完成随机存取的替代方案。

- 一种方法是在读取系统调用中添加一个额外的参数，告诉你要读取哪个地址。 实际上，每次读取都有可能在文件中进行搜索。该方案的缺点是（1）每个读取调用都含有额外参数，以及（2）要求用户跟踪文件指针在哪里。

1. 考虑图4-8中的目录树，如果当前工作目录是/usr/jim，则相对路径名为../ast/x的文件的绝对路径名是什么？

- ..将搜索移动到/usr，所以../ast就是/usr/ast。因此../ast/x与/usr/ast/x相同。

1. 正如书中所提到的，文件的连续分配会导致磁盘碎片，因为当一个文件的长度不等于块的整数倍时，文件中的最后一个磁盘块中的空间会浪费掉，请问这是内碎片还是外碎片？并将它与先前一章的有关讨论进行比较。

- 由于这些被浪费的空间在分配单元(文件)之间，而不是在它们内部，因此，这是外部碎片。这类似于交换系统或者纯分段系统中出现的外部碎片。（原答案有误，应该是内碎片）

1. 一种在磁盘上连续分配并且可以避免空洞的方案是，每次删除一个文件后就紧缩一下磁盘。由于所有的文件都是连续的，复制文件时需要寻道和旋转延迟以便读取文件，然后全速传送。在写回文件时要做同样的工作。假设寻道时间为5ms，旋转延迟为4ms，传送速率为8MB/s，而文件平均长度是8 KB，把一个文件读入内存并写回到磁盘上的一个新位置需要多长时间？运用这些数宇，计算紧缩16GB磁盘的一半需要多长时间？

- 传输前的延迟是9ms，传输速率是2^23B/s，文件大小是2^13B，故从内存读取或写回磁盘的时间都是9+2^13/2^23=9.977ms，总共复制一个文件需要 9.977*2=19.954ms。为了压缩16G磁盘，也就是2^20个文件，每个需要19.954ms，总共就需要20923s。因此，在每个文件删除后都压缩磁盘不是一个好办法。

1. 基于前一个问题的答案，紧缩磁盘有什么作用吗？

- 因为在系统删除的所有文件都会以碎片的形式存在磁盘中，当碎片到达一定量磁盘就不能再装文件了，必须进行外部清理，所以紧缩磁盘会释放更多的存储空间，但是在每个文件删除后都在压缩磁盘不是一个好办法

1. 某些数字消费设备需要存储数据，比如存放文件等。给出一个现代设备的名字，该设备需要文件存储， 并且对文件运用连续分配空间的方法是不错的方法。 

- 数码相机按顺序记录一系列照片，存储在某种非易失性存储媒介（例如，内存）上。当照相机复位时，该媒介被清空。然后，按顺序依次记录一张照片，知道存储满，然后上载到磁盘上。对于这种应用，相机内部文件的连续文件系统时最理想。

1. MS-DOS如何在文件中实现随机访问？

- 它找到目录条目中第一块的地址。然后它跟随FAT链中的指针链，知道它找到了它所需的块，然后它会为下一次read系统调用记住此块号

1. 考虑图4-13中的i节点。如果它含有用4个字节表示的10个直接地址，而且所有的磁块大小是1024KB，那么文件最大可能由多大？

- 由于1024KB = 2^20B，所以可以容纳的磁盘地址个数是2^20/4 =2^18个磁盘地址，间接块可以保存2^18个磁盘地址。与10个直接的磁盘地址一起，最大文件有262154块。由于每块为 1 MB，最大的文件是262154MB。

1. 有建议说，把短文件的数据存在i节点之内会提高效率并且节省磁盘空间， 对于图4-13中的i节点，在i节点之内可以存放多少字节的数据？

- 必须有一种方式来标记磁盘地址保存数据，而不是指针。如果在属性之间的某处存在一点空余，可以使用它。这将留下所有九个指针的数据。如果每个指针是k个字节，那么存储的文件可能长达9k字节。如果属性中没有剩余位，则第一个磁盘地址可以保存无效地址，将以下字节标记为数据而不是指针。在这种情况下，最大文件为8k字节。

1. 两个计算机科学系的学生Carolyn和Elinor正在讨论i节点。Carolyn认为存储器容量越来越大，价格越来越便宜，所以当打开文件时，直接取i节点的副本，放到内存i节点表中，建立一个新i节点将更简单、更快，没有必要搜索整个i节点来判断它是否已经存在。Elinor则不同意这一观点。他们两个人谁对？

- Elinor是正确的。表格中同时有i节点的2个备份是灾难性的，除非都是只读的。最坏的情况就是当两个都同时被更新时。当把i节点写回磁盘时，后写入的会把先写入的删除，而磁盘块就丢失了。

1. 说明硬连接优于符号链接的一个优点，并说明符号链接优于硬连接的一个优点。

- 硬连接无需额外的磁盘空间，而只需在i节点中记录有多少个链接。符号链接需要空间存储所指的文件的名称。符号链接可以指向其他机器上的文件，甚至是Internet上的文件。而硬连接只能指向其自己分区中的文件。

1. 空闲磁盘空间可用空闲块表或位图来跟踪。假设磁盘地址需要D位，一个磁盘有B个块，其中有F个空闲。在什么条件下，空闲块表采用的空间少于位图？ 设D为16位，请计算空闲磁盘空间的百分比。

- 每个磁盘地址需要D位，且有F个空闲块，故需要空闲表为DF位，采用位图则需要B位，当DF<B时，空闲表采用的空间少于位图，当D=16时，得 F/B<1/D=6.25%，即空闲空间的百分比少于6.25%。

1. 一个空闲块位图开始时和磁盘分区首次初始化类似，比如：1000 0000 0000 0000（首块被根目录使用），系统总是从最小编号的盘块开始寻找空闲块，所以在有6块的文件A写入之后，该位图为1111 1110 0000 0000。

- 请说明在完成如下每一个附加动作之后位图的状态：
  - a）写人有5块的文件B。
  - b）删除文件A。
  - c）写入有8块的文件C。
  - d）删除文件B。
- 答：
  - a)1111 1111 1111 0000
  - b)1000 0001 1111 0000
  - c)1111 1111 1111 1100
  - d)1111 1110 0000 1100

1. 如果因为系统崩溃而使存放空闲磁盘块信息的空闲块表或位图完全丢失，会发生什么情况？有什么办法从这个灾难中恢复吗，还是与该磁盘彻底再见？分别就UNIX和FAT-16文件系统讨论你的答案。

- 这根本不是一个严重的问题。恢复是简单直接的，它只需要一些时间。恢复算法是列出所有文件中的所有块，并将补码作为新的空闲块表。在UNIX中，可以通过扫描所有i节点来完成。在FAT文件系统中，由于没有空闲块表，该问题不会发生。即使存在这样的情况，恢复它所需要做的工作是扫描FAT寻找空闲块。

1. Oliver Owl在大学计算中心的工作是更换用于通宵数据备份的磁带，在等待每盘磁带完成的同时，他在写一篇毕业论文，证明莎士比亚戏剧是由外星访客写成的。由于仅有一个系统，所以只能在正在做备份的系统上运行文本编辑程序。这样的安排有什么问题吗？

- Oliver Owl的论文可能不会像他所希望的那么可靠。备份程序可能备份当前打开用于写入的文件，但是该文件中的数据的状态可能是不确定的。

1. 在教材中我们详细讨论过增量转储。在Windows中很容易说明何时要转储一个文件，因为每个文件都有一个存档位。在UNIX中没有这个位，那么UNIX备份程序怎样知道哪个文件需要转储？

- 他们必须跟踪磁盘上的文件最后一次转储的时间。每次转储后，一个条目被附加到该文件上。在转储过程中，文件被读取，时间记录在最后一个条目上。任何从那以后被更改的文件都要被转储。

1. 假设图4-25中的文件21自上次转储之后没有修改过，在什么情况下图4-26中的四张位图会不同？

- （a）和（b）中，21不会被标记。在（c）中，没有变化。 在（d）中，21不会被标记。

1. 有人建议每个UNIX文件的第一部分最好和其i节点放在同一个磁盘块中，这样做有什么好处？

- 许多UNIX文件很短。如果整个文件与i节点放在同一个磁盘块中，则只需要一个磁盘访问即可读取文件，而不是两个。即使对于较长的文件，也会有一点好处，因为需要更少的磁盘访问。

1. 考虑图4-27。对某个特殊的块号，计数器的值在两个表中有没有可能都是数值2? 这个问题如何纠正？

- 这是不应该发生的，但由于Bug可能某个地方会发生这种问题。这意味着有些块会出现在两个文件中，而且在空闲块表中也会出现两次。修复这个问题的第一步是从空闲块表中删除这两个副本。接下来，必须获取一个空闲块，并将该错误块的内容复制到获取的空闲块中。最后，新获取的块的副本插到其中一个文件之中。这时，系统将再次一致。

1. 文件系统的性能与高速缓存的命中率有很大的关系（即在高速缓存中找到所需块的概率）。从高速缓存中读取数据需要1ms，而从磁盘上读取需要40ms，若命中率为h，给出读取数据所需平均时间的计算公式。并画出h从0到1.0变化时的函数曲线。

- 平均时间 T = 1×h + 40×(1-h)=-39h+40ms。

1. 考虑图4-21 背后的思想，目前磁盘平均寻道时间为8ms，旋转速率为15000rpm，每道为262 144 字节。对大小各为1KB、2KB和4KB的磁盘块，传送速率各是多少？

- 对于15000 rpm（每分钟旋转），每旋转一周需60/15000=0.004秒=4ms。那么读取k字节的平均存取时间为8ms（寻道时间）+ 2ms（旋转延迟：4ms/2）+(k/262144)×4ms（读取k字节的时间）。对于1 KB，2 KB，4 KB的块，访问时间分别为10.015625ms，10.03125ms和10.0625ms（几乎没有什么不同）。其数据速率分别为102240 KB/sec，204162 KB/sec，407056 KB/sec。

1. 某个文件系统使用2KB的磁盘块，而中间文件大小值为1KB。如果所有的文件都是正好1KB大，那么浪费掉的磁盘空间的比例是多少？你认为一个真正的文件系统所浪费的空间比这个数值大还是小？请说明理由。

- 1KB/2KB×100%=50%。在实践中，每个文件系统都有大文件以及许多小文件。例如，32769字节的文件将使用17个磁盘块进行存储，得到的空间利用效率为32768/34816，约为94%。

1. MS-DOS的FAT-16表有64K个表项，假设其中的一位必须用于其他用途，这样该表就只有32768个表项了。如果没有其他修改，在这个条件下最大的MS-DOS文件有多大？

- 最大的块是32KB。最多有32,768个块，所以最大的文件将为1 GB。

1. MS-DOS中的文件必须在内存中的FAT-16表中竞争空间。如果某个文件使用了k个表项，其他任何文件就不能使用这k个表项，这样会对所有文件的总长度带来什么限制？

- 它将所有文件长度的总和限制为不大于磁盘。这不是一个非常严重的限制。 如果文件总和大于磁盘，则不会将其全部存储在磁盘上。

1. 一个UNIX 系统使用1KB磁盘块和4字节磁盘地址。如果每个i节点中有10个直接表项以及一个一次间接块、一个二次间接块和一个三次间接块，那么文件的最大尺寸是多少？

- 由于1KB=1024B，所以1KB磁盘块可以容纳的磁盘地址个数是2^10B/4=256个。故一个一次间接块存储256个磁盘地址。一个二次间接块存储256^2个磁盘地址。一个三次间接块存储256^3磁盘地址。把这些全部加起来， 10+256+256^2+256^3=16843018块，每一块 1K，即16843018KB，约16.06 GB。

1. 对于文件/usr/ast/courscs/os/handout.t，若要调入其i节点需要多少个磁盘操作？ 假设其根目录的i节点在内存中，其他路径都不在内存中。并假设所有的目录都在一个磁盘块中。

- 需要以下磁盘读取操作：
  - (1) directory /
  - (2) i-node for /usr
  - (3) directory /usr
  - (4) i-node for /usr/ast
  - (5) directory /usr/ast
  - (6) i-node for /usr/ast/courses
  - (7) directory /usr/ast/courses
  - (8) i-node for /usr/ast/courses/os
  - (9)directory /usr/ast/courses/os/
  - (10)i-node for /usr/ast/courses/os/handout.t
- 一共需要10个磁盘读取操作。

1. 在许多UNIX系统中， i节点存放在磁盘的开始之处。一种替代设计方案是，在文件创建时分配i节点，并把i节点存放在该文件首个磁盘块的开始之处。请讨论这个方案的优缺点。

- 一些优点如下：
  - 首先，没有磁盘空间浪费在未使用的i节点上。
  - 第二，用不完的i节点。
  - 第三，需要更少的磁盘移动，
    - 因为可以在一个操作中读取i节点和初始数据。
- 一些缺点如下：
  - 首先，目录条目现在需要一个32位的磁盘地址，而不是一个16位的i节点号码。
  - 第二，对于不包含数据的文件（空文件，设备文件）也将使用整个磁盘块。
  - 第三，文件系统完整性检查将会更慢，因为需要为每个i节点读取整个块，并且i节点分散在磁盘上。
  - 第四，尺寸被仔细设计以适应块大小的文件因为i节点的存在将不再适合块大小，使得性能变差。

1. 编写一个将文件字节倒写的程序，这样最后一个字节成为第一个字节，而第一个字节成为最后一个字节。程序必须适合任何长度的文件，并保持适当的效率。

- 略。

1. 编写一个程序，该程序从给定的目录开始，从此点开始沿目录树向下，记录所找到的所有文件的大小。在完成这一切之后，该程序应该打印出文件大小分布的直方图，以该直方图的区间宽度为参数（比如，区间宽度为1024，那么大小为0~1023的文件同在一个区间宽度，大小为1024-2047的文件同在下一个区间宽度，如此类推）。

- 略。

1. 编写一个程序，扫描UNIX文件系统中的所有目录，并发现和定位有两个或更多硬连接计数的i节点。对于每个这样的文件，列出指向该文件的所有文件的名称。

- 略。

1. 编写UNIX的新版ls程序。这个版本将一个或多个目录名作为变量，并列出每个目录中所有的文件，一个文件一行。每个域应该对其类型进行合理的格式化。仅列出第一个磁盘地址（若该地址存在的话）。

- 略。