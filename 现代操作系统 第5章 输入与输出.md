# 第5章 输入/输出

- 操作系统必须向设备发送命令，捕捉中断，并处理设备的各种错误
  - 还应该在设备和系统的其他部分直接提供简单且易于使用的接口
  - 设备无关性
    - 接口对于所有设备都应该是相同的
- 本章的内容是这样组织的
  - 首先介绍I/O硬件的基本原理，然后介绍一般的I/O硬件
    - I/O软件可以分层构造，每层都有明确的任务
    - 我们将对这些软件层 进行研究，看一看它们做些什么，以及如何在一起配合工作
  - 在此之后将详细介绍几种I/O设备：磁盘、时钟、键盘和显示器
  - 介绍电源管理

## 5.1 I/O硬件原理

- 本书主要介绍怎样对I/O设备编程，而不是如何设计、制造和维护硬件

### 5.1.1 I/O设备

- I/O设备大致可以分成
  - block device，块设备
    - 块设备把信息存储在固定大小的块中，每个块有自己的地址
    - 块设备的基本特征是每个块都能独立于其他块而读写
    - 硬盘、CD-ROM和USB盘是最常见的块设备
  - character device，字符设备
    - 字符设备以字符为单位发送或接收一个字符流，而不考虑任何块结构
    - 字符设备是不可寻址的，也没有任何寻道操作
    - 打印机、网络接口、鼠标（用作指点设备）、老鼠（用作心理学实验室实验）以及大多数与磁盘不同的设备都看佐是字符设备
- 这种分类方法并不完美，有些设备就没有包括进去
  - 时钟
  - 内存映射的显示器
- 但是块设备和字符设备的模型具有足够的一般性，可以用作使处理I/O设备的某些操作系统软件具有设备无关性的基础
- I/O设备在速度上覆盖率巨大的范围

### 5.1.2 设备控制器

- I/O设备一般由机械部件和电子部件两部分组成
  - 电子设备
    - device controller，设备控制器，或adapter，适配器
      - 在个人计算上，它将经常以主板上芯片的形式出现，或以插入（PCI）扩展槽中的印制电路板的形式出现
  - 机械部件
    - 设备本身
- 控制器卡上通常有一个连接器，通向设备本身的电缆可以插入到这个连接器中
- 控制器与设备之间的接口通常是一个很底层次的接口
  - 实际从驱动器出来的是一个串行的位（比特）流
    - 它以一个前导符（preamble）开始
      - 包括柱面数和扇区号、扇区大小以及类似的数据，还包含同步信息
    - 接着是一个扇区中的40986位
    - Error-Correcting Code，ECC
      - 最后是一个校验和
- 控制器的任务是把串行的位流转换为字节块，并进行必要的错误校验工作
  - 在同样第的层次上，监视器的控制器也是一个位串行设备
    - 平板TFT显示器的工作原理不同，但是也同样复杂

### 5.1.3 内存映射I/O

- 每个控制器有几个寄存器用来与CPU进行通信
- 除了这些，许多设备还有一个操作系统可以读写的数据缓冲区
- CPU如何与设备的控制寄存器和数据缓冲区进行通信
  - 每个控制寄存器被分配一个I/O端口（I/O port）号
    - IN REG.PORT
      - CPU可以读取控制寄存器PORT的内容并将结果存入到CPU寄存器REG中
    - OUT PORT.REG
      - CPU可以将REG的内容写入到控制寄存器中
  - PDP-11引入的方法，它将所有控制寄存器映射到内存寄存器中
    - memory-mapping I/O，内存映射I/O
      - 每个控制器被分配唯一的一个内存地址
      - 通常分配给控制寄存器的地址位于地址空间的顶端
- 这两种寻址控制器的方案具有不同的优缺点
  - 内存映射I/O的优点
    - 内存映射I/O、I/O设备驱动程序可以完全用C语言编写
    - 不需要特殊的保护机制来阻止用户进程执行I/O操作
    - 可以引用内存的每一条指令也可以引用控制寄存器
  - 内存映射的缺点
    - 对一个设备控制器进行高速缓存可能是灾难性的
    - 缺点是需要在引导时判定那些内存不是真正的内存地址

### 5.1.4 直接存储器存取

- Direct Memory Access，DMA，直接存储器方案
  - CPU可以从I/O控制器首次请求一个字节的数据
    - 浪费CPU的时间
  - 无论DMA控制器在物理上处于什么地方，它都能够独立于CPU而访问系统总线
    - 它包含若干个可以被CPU读写的寄存器
- 没有使用DMA时磁盘如何读
  - 首先，控制器从磁盘驱动器串行地、一位一位地读一个块（一个或多个扇区，直到将整块信息，放入控制器的内部缓冲区中
  - 接着，它计算校验和
  - 然后控制器产生一个中断
  - 当操作系统开始运行时，它重复地读取，并存入内存中
- 使用DMA时，过程是不同的
  - 首先，CPU通过设置DMA控制器的寄存器对它进行编程
  - DMA控制器通过在总线上发出一个读请求到磁盘而发起DMA传送
  - 写到内存是另一个标准总线周期
  - 当写操作完成时，磁盘控制器在总线上发出一个应答信号到DMA
- DMA控制器在复杂性方面区别相当大
  - 最简单的DMA控制器每次处理一路传送
  - 复杂一些的DMA控制器经过编程可以一次处理多路传送
- 计数总线能够以两种模式操作
  - 每次一字模式
    - DMA控制器请求传送一个字并且得到这个字
    - cycle stealing，周期窃取
      - 如果CPU也想使用总线，它必须等待
  - 块模式
    - burst mode，突发模式
      - 在块模式中，DMA控制器通知设备获取总线，发起一连串的传送，然后释放总线
      - 比周期窃取效率更高
      - 缺点是，如果正在进行的是长时间突发传送，有可能将CPU和其他设备阻塞相当长的周期
- fly-by mode，飞越模式
  - DMA控制器通知设备控制器使用物理内存地址进行传送
- 大多数DMA控制器使用物理内存地址进行传送
- 为什么需要一个内部缓冲区
  - 首先，通过进行内部缓冲，磁盘控制器可以在传送之前检验校验和
  - 一旦磁盘传送开始工作，从磁盘读出的数据就是以固定速率到达的，而不论控制器是否准备好接受数据
    - 如果块被放入内部缓冲区，则在DMA启动前不需要使用总线

### 5.1.5 重温中断

- 在硬件层面，中断的工作
  - 当一个I/O设备完成交给它的工作是，它就产生一个中断
    - 它是通过在分配给它的一条总线信号线志气信号而产生中断的
    - 该信号被主板上的中断控制器检测到
  - 如果没有其他中断悬而未决，中断控制器将立即对中断进行处理
    - 中断控制器在地址线上放置一个数字表明按个设备需要关注
  - 中断信号导致CPU停止当前正在做的的工作并且开始做其他的事情
    - interrupt vector，中断向量
      - 地址线上的数字被用做指向一个称为中断向量的表格的索引
      - 中断向量的位置可以硬布线到机器中，也可以在内存中的任何地方通过一个CPU寄存器
  - 中断服务器开始运行后，它将立即通过将一个确定的值写到中断控制器的某个I/O端口来对中断做出应答
- 在开始服务程序之前，硬件总是要保存一定的信息
  - 将这些信息保存到什么地方时一个问题
    - 将其放入内部寄存器中，在需要时操作系统可以读出这些内部寄存器
      - 这一个策略在中断被禁止时将导致长时间的死机，并且可能丢失中断和丢失数据
    - 大多数CPU在堆栈中保存信息
- 精确中断和不精确中断
  - 现代CPU大量地使用流水线并且有时还采用超标量（内部并行）
    - 这一模型使用了隐含的假设，这就是如果一个中断正好在某一条指令之后，那么这条指令前的所有指令（包括这条指令）都完整执行过了，而这条指令也没有执行
      - 在老式的机器上，这一假设是正确的
      - 在现代计算机上，这一假设则未必是正确的
  - precise interrupt，精确中断
    - 将机器留在衣蛾明确的中断称为精确中断
    - 具有4个特性
      - PC（程序计数器）保存在一个已知的地方
      - PC所指向的指令之前的所有指令已经完全执行
      - PC所执行的指令之后的所有指令都没有执行
      - PC所指向的指令的执行状态是已知的
  - imprecise interrupt，不精确中断
    - 不满足这些要求的中断
    - 现在某些操作系统编写者必须断定已经法处理什么以及还要发生什么
    - 在每次中断发生时将大量的信息保存在内存中使得中断响应十分缓慢
      - 由于缓慢的中断使得非常快速的超标量CPU有时并不适合十分缓慢
  - 有些计算机设计成某些种类的中断和陷阱是精确的，而其他的不是
    - 可以让I/O中断时精确的，而归因于致命编程错误的陷阱是不精确的
    - 不精确中断使得操作系统更为复杂而且运行得更加缓慢

## 5.2 I/O软件原理

- 首先看一看I/O软件的目标，然后从操作系统的观点来看一看I/O实现的不同

### 5.2.1 I/O软件的目标

- device independent，设备独立性
  - 在设计I/O软件时一个关键的概念
  - 应该能够编写出这样的程序
    - 它可以访问任意I/O设备而无需事先指定设备
- uniform naming，统一命名
  - 一个文件或一个设备的名字应该是一个简单的字符串货一个整数，它不依赖于设备
  - 在UNIX系统中，所有存储盘都能以任意方式集成到文件系统层次结构中
    - 所有文件和设备都采用相同的方式——路径名进行寻址
- error handling，错误处理
  - 一般来说，错误应该尽可能地在接近硬件的层面得到处理
  - 在许多情况下，错误恢复可以在低层透明地得到解决，而高层软件甚至不知道存在这一错误
- synchronous，同步（即阻塞）和asynchronous，异步（即中断驱动）传输
  - 大多数物理I/O是异步的
- buffering，缓冲
  - 数据离开一个设备之后通常并不能直接存放在其最终的目的地
  - 缓冲涉及大量的复制工作，并且经常对I/O性能有重大影响
- 共享设备和独占设备
  - 有些I/O设备（如磁盘）能够同时让多个用户使用
  - 其他设备（如磁带机）则必须由单个用户独占使用

### 5.2.2 程序控制I/O

- programming I/O，程序控制I/O

  - 让CPU做全部工作

  - I/O的最简单形式

    - 首先，数据被复制到内核空间

    - 然后，操作系统进入一个密闭的循环，一次输出一个字符

    - polling，轮询或busy waiting，忙等待

      - 输出一个字符之后，CPU要不断的查询设备以了解它是否就绪准备接收另一个字符

      ```c
      copy_form_user(buffer, p, count);
      for(i=0;i<count;i++){
        while(*printer_status_reg != READY);
        *printer_data_register = p[i];
      }
      return_to_user();
      ```

- 程序控制I/O十分简单但是有缺点

  - 直到全部I/O完成之前要占用CPU的全部时间
  - 在更加复杂的系统中，CPU有其他工作要做，忙等待将是低效的，需要更好的I/O方法

### 5.2.3 中断驱动I/O

- 考虑在不缓冲字符而是在每个字符到来时便打印的打印机上进行打印的情形
  - 这种允许CPU在等待打印机变为就绪的同时做某些事情的方式就是使用中断

    - 系统调用所做的工作

    ```c
    copy_from_user(buffer, p, count);
    enable_interruptsZ();、
    while(*printer_status_reg != READY)；
    *printer_data_register = p[0];
    schedule();
    ```

  - 当打印机打印完并且准备好接收下一个字符时，它将产生衣蛾中断

    - 打印机中断服务过程的一个粗略的版本

    ```c
    if（count == 0){
      unable_user();
    }else{
      *printer_data_register = p[i];
      count = count + 1;
      i = i+1;
    }
    acknowledge_interrupt();
    ```

### 5.2.4 使用DMA的I/O

- 中断驱动I/o的一个明显缺点是中断发生在每个字符上

  - 一种解决方案是使用DMA

    - 思路是让DMA控制器一次给打印机提供一个字符，而不必打扰CPU

    ```c
    copy_form__user(buffer, p, count);
    set_up_DMA_controller();
    schedule();
    acknowledge_interrupt();
    unblock_user();
    return_from_interrupt();
    ```

- DMA重大的成果是将中断的次数从打印每个字符一次减少到打印每个缓冲区一次

- 另一方面，DAM控制器通常比主CPU要慢得多

### 5.3 I/O软件层次

- I/O软件层次通常组织成四个层次
  - 每一层具有一个要执行的定义明确的功能和一个定义明确的与邻近层次的接口
- 中断处理程序
  - 应当将其深深地隐藏在操作系统内部
    - 以便系统的其他部分尽量不与他发生联系
    - 隐藏它们最好办法是将启动一个I/O操作的驱动程序阻塞起来，直到I/O操作完成且产生一个中断
      - 在一个信号量上执行down操作、在一个条件变量上执行wait操作、在一个消息上执行receive操作或者某些类似的操作
  - 当中断发生时，中断处理程序将做它必须要做的全部工作以便对中断进行处理
    - 最终的结果是使先前被阻塞的驱动程序现在能够继续运行
  - 显示没有如此简单，对操作系统而言，还涉及更多的工作
    - 保存没有被中断硬件保存的所有寄存器（包括PSW）
    - 为中断服务过程设置上下文，可能包括设置TLB、MMU和页表
    - 为中断服务过程设置堆栈
    - 应答中断控制器，如果不存在集中的中断控制器，则再次开放中断
    - 将寄存器从它们被保存的地方（可能是某个堆栈）复制到进程表中
    - 运行中断服务过程，从发出中断的设备控制器的寄存器中提取信息
    - 选择下一次运行哪个进程，如果中断导致某个被阻塞的高优先级进程变为就绪，则可能选择它现在就运行
    - 为下一次要运行的进程设置MMU上下文，也许还需要设置某个TLB
    - 装入新进程的寄存器，包括其PSW
    - 开始运行新进程
  - 它要花费相当多的CPU指令

### 5.3.2 设备驱动程序

- 每一个控制器都设有某些设备寄存器用来向设备发出命令，或者设有某些设备寄存器用来向沈北发出命令
  - 设备寄存器的数量和命令的性质在不同设备之间有着根本性的不同


- device driver，驱动程序
  - 每个连接到计算机上的I/O设备都需要某些设备特定的代码对其进行控制
  - 它一般由设备的制造商编写并随同设备一起交付
- 每个设备驱动程序通常处理一种类型的设备，或者至多处理一类紧密相关的设备
- 设备驱动程序通常必须是操作系统内核的一部分
  - 为了访问设备的硬件，意味着访问设备控制器的寄存器
  - 至少对目前的体系结构是如此
    - 有可能构造运行在用户空间的驱动程序，使用系统调用来读写设备寄存器
    - MINIX3就是一个这样的系统
- 设备驱动程序通常位于操作系统其余部分的下面
  - 实际上，驱动程序和设备控制器之间的所有通信都通过总线
- 操作系统将驱动程序归类于少数的类别之一
  - 最为通用的类别是块设备（block device）和字符设备（character device）
    - 块设备（例如磁盘）包含多个可以独立寻址的数据块
    - 字符设备（例如键盘和打印机）则生成或接收字符流
  - 大多数操作系统都定义了一个所有块设备都必须支持的标准接口，并且还定义了另一个所有字符设备都必须支持的标准接口
- 在某些系统中，操作系统是一个二进制程序，包含需要编译到其内部的所有驱动程序
  - 随着个人计算机的出现，这一模型不再起作用
    - 因为个人计算机有太多种类的I/O设备
  - 从MS-DOS开始，操作系统转向驱动程序在执行期间动态地装载到系统中的另一个模型
- 设备驱动程序具有若干功能
  - 接收来自其上方与设备无关的软件所发出的抽象的读写请求，并且目睹这些请求被执行
  - 对设备进行初始化
  - 对电源需求和日志事件进行管理
- 许多设备具有相似的一般结构
  - 典型的驱动程序在启动时要检查输入参数
    - 如果输入参数是有效的，则可能需要进行抽象事项到具体事项的转换
  - 接着，驱动程序可能要检查设备当前是否在使用
    - 如果在使用，请求被排入队列以备稍后处理
    - 如果设备是空闲的，驱动程序将检查硬件状态以了解请求现在是否能够得到处理
  - 控制设备
    - 意味着向设备发出一系列命令
    - 命令发出之后，会牵扯两种情形之一
      - 在多数情况下，驱动程序将阻塞其自身直到中断来解除阻塞
        - 阻塞的驱动程序可以被中断唤醒
      - 在另外一些情况下，操作可以无延迟地完成
        - 在字符模式下滚动屏幕
        - 驱动程序根本就不会休眠
    - 无论哪一种情况，操作完成之后驱动程序都必须简化擦错误
      - 如果一些顺利，它向调用者返回一些用于错误报告的状态信息
      - 如果还有其他未完成的请求在排队，则选择一个启动执行
      - 如果队列中没有为完成的请求，则该驱动程序将阻塞以等待下一个请求
    - 许多因素使相关的代码比这要复杂得多
      - 驱动程序必须是重入的
        - 这意味着一个正在运行的驱动程序必须预料到在第一次调用完成之前第二次被调用
      - 在一个热插拔的系统中，设备可以在计算机运行时添加或删除
- 驱动程序不允许进行系统调用，但是经常与内核的其余部分进行交互
  - 调用内核过程来分配和释放硬接线的内存页面作为缓冲区
  - 需要其他调用来管理MMU、定时器、DMA控制器、中断控制器等

### 5.3.3 与设备无关的I/O软件

- 设备驱动程序和与设备无关的软件之间的确切界限依赖于具体系统（和设备）
- 与设备无关的软件的基本功能是执行对所有设备公共的I/O功能，并且向用户层软件提供一个统一的接口


####1. 设备驱动程序的统一接口

- 操作系统的一个主要问题是如何使所有I/O设备和驱动程序看起来或多或少是相同的
- 设备驱动程序与操作系统其余部分之间的接口是这一问题的一个方面
  - 每个设备驱动程序有不同的与操作系统的接口
    - 这意味着为每个新的驱动程序提供接口都需要大量全新的编程工作
  - 所有驱动程序具有相同的接口
    - 意味着驱动程序的编写人员知道驱动程序的接口应该是什么样子的
    - 虽然并非所有的设备都是绝对一样的，但是通常只存在少数设备类型，而它们的确大体上是相同的
- 这种设计的工作方式
  - 对于每一种设备类型，例如磁盘或打印机，操作系统定义一组驱动程序必须支持的函数
    - 驱动程序通常包含一张表格，这张表格具有针对这些函数指向驱动程序自身的指针
- 如何给I/O设备命名是统一接口问题的另一个方面
  - 与设备无关的软件要负责把符号化的设备名映射到适当的驱动程序上
    - 在UNIX系统中，像/dev/disk0这样的设备名唯一确定了一个特殊文件的i节点，包含
      - major device number，主设备号
        - 用于定位相应的驱动程序
      - minor device number，次设备号
        - 作为参数传递给驱动程序，用来确定要读或写的具体单元
  - 所有设备都具有主设备号和次设备号
    - 所有驱动程序都是通过使用主设备号来选择驱动程序而得到访问
- 与设备命名密切相关的是设备保护
  - 在UNIX和Windows中，设备是作为命名对象出现在文件系统中的
    - 这意味着针对文件的常规的保护规则也适用于I/O设备
    - 系统管理员可以为每个设备设置适当的访问权限

#### 2. 缓冲

- 无论对于块设备还是对于字符设备，由于种种原因，缓冲也是一个重要的问题
- 中断服务过程负责将字符递交给用户进程并且将其解除阻塞
  - 这种处理方式的问题在于
    - 对于每个到来的字符，都必须启动用户进程
- 一种改进措施
  - 用户进程在用户空间中提供了一个包含n个字符的缓冲区，并且执行读入n个字符的读操作
  - 中断服务过程负责将到来的字符放入缓冲区中知道缓冲区填满，然后唤醒用户进程
  - 缺点
    - 当一个字符到来时，缓冲区被分页而调出内存
    - 解决方法是将缓冲区锁定在内存中
- 另一种方法是在内核空间中创建一个缓冲区并且让中断处理程序将字符放入到这个缓冲区中
  - 当该缓冲区被填满的时候，将包含用户缓冲区的页面调入内存
  - 面临一个问题
    - 正当包含用户缓冲区的页面从磁盘调入内存的时候有新的字符的到来
      - 一种解决问题的方法是使用第二个内核缓冲区
        - double buffering，双缓冲
        - circle buffering，循环缓冲区
          - 它由一个内存区域和两个指针组成 
            - 一个指针指向下一个空闲的字
            - 另一个指针指向缓冲区中数据的第一个字
          - 当你添加新的数据时（例如刚刚从网络到来），硬件将推进第一个指针，而操作系统在取走并处理数据时推进第二个指针
- 缓冲对于输出也是十分重要的
  - 对于没有缓冲区的调制解调器，在低速电话线上可能花费非常长的时间
    - 对于内核来说更好的解决方法
      - 将数据复制到一个内核缓冲区中，并且立即将调用者解除阻塞
- 缓冲是一种广泛采用的技术，但是它也有不利的方面
  - 如果数据被缓冲太多次，性能就会降低
    - 内核将数据包复制到一个内核缓冲区中，从而立即使用户进程得以进行
    - 当驱动程序被调用时，它将数据复制到控制器上以供输出
    - 当数据包复制到控制器的内部缓冲区中之后，它就会被复制到控制器上以供输出
    - 数据包复制到接收器的内核缓冲区中
    - 最后，它被复制到接收进程的缓冲区中


#### 3. 错误报告

- 错误在I/O上下文中比在其他上下文中要常见得多
- 一种类型的I/O错误是编程错误
  - 发生在一个进程请求某些不可能的事情时
  - 其他的错误包括提供了一个无效的缓冲区地址或者其他参数，以及指定了一个无效的设备
- 另一种类型的是实际的I/O错误

#### 4. 分配与释放专用设备

- 某些设备，例如CD-ROM刻录机，在任意给定的时刻只能由一个进程使用
  - 这就要求操作系统对设备的请求进行检查
  - 处理这些请求的一种简单方法是要求进程在代表设备的特殊文件上直接执行open操作
  - 一种代替的方法是对于请求和释放专用设备要有特殊的机制
    - 试图得到不可用的设备可以将调用者阻塞

#### 5. 与设备无关的块大小

- 不同的磁盘可能具有不同的扇区大小、
  - 应该有与设备无关的软件来隐藏这一事实并且向高层提供一个统一的块大小
    - 将入若干扇区当作一个逻辑块

### 5.3.4 用户空间的I/O软件

- 大部分I/O软件都在操作系统内部

  - 小部分在用户空间，包括与用户程序连接在一起的库
    - 系统调用（包括I/O系统调用）通常由库过程实现

- 这些过程通过I/O过程实际实现真正的条件

  - 输入和输出的格式化是由库过程完成的

    - 一种是C语言中的printf，它以一个格式和可能的一些变量作为输入，构造一个ASCⅡ字符串，然后调用write以输出这个串

    ```C
    printf("The square of %3d is% 6d \n", i ,i*i);
    ```

    - 该语句格式化一个字符串“The square of “（注意of后有一个空格），随后是i值作为3个字符的串，然后是4个字符的串“is“ （注意前后各有一个空格），然后是i值作为6个字符的串，最后是一个换行

  - 对于输入而言，一个例子是scanf

    - 它读取输入并将其存放到一些变量中，采用与printf同样的语法的格式串来描述这些变量

- spooling，假脱机

  - 多道程序设计中处理独占I/O设备的一种方法
  - 不是由库过程组成的用户层I/O软件
  - daemon，守护进程和spooling directory，假脱机目录
    - 一个进程要打印一个文件时，首先生成要打印的整个文件，并且将其放在假脱机目录下
  - 假脱机目录不仅仅用于打印机，还可以在其他情况下使用
    - 通过网络传输文件常常使用一个网络守护进程
      - USENET新闻系统
        - 该网络由世界上使用因特网进行通信的成千上万台计算机组成，针对许多话题存在着几千个新闻组
        - 要发送一条新闻消息，用户可以调用新闻程序，该程序接收要发出的消息，然后将其存放在假脱机目录中，待以后发送到其他计算机上

-  I/O系统

  - 从最底层开始，这些层是硬件、中断处理程序、设备驱动程序、与设备无关的软件，最后是用户进程
  - 箭头表明了控制流
    - 当一个用户程序试图从一个文件中读一个块时
      - 操作系统被调用以实现这一请求
    - 与设备无关的软件在缓冲区高速缓冲中查找有无要读的块
    - 如果需要的块不在其中，则调用设备驱动程序，向硬件发出一个请求，让它从磁盘中获取该块
      - 进程被阻塞到磁盘操作完成
    - 当磁盘操作完成时，硬件产生一个中断
      - 中断处理程序从设备中提取状态信息，唤醒休眠的进程以结束此次I/O请求，并且让用户进程继续运行

## 5.4 盘

- 研究实际的I/O设备，如盘、时钟、键盘和显示器

### 5.4.1 盘的硬件

- 盘具有多种多样的类型
  - 最为常见的是磁盘（硬盘和软盘）
    - 理想的辅助存储器
      - 用于分页、文件系统等
    - 它们具有读写速度同样快的特点
- 对于程序，数据和电影的发行而言，各种光盘（CD-ROM、可刻录CD以及DVD）也是非常重要

#### 1. 磁盘

- 磁盘被组织成柱面，每个柱面包含若干柱面，每个柱面包含若干磁道，磁道数与垂直堆叠的磁头个数相同
- 磁道又被分成若干扇区
  - 软盘大约每条磁道有8~32个扇区
  - 硬盘上每条磁道上扇区的数目可以多达几百个
  - 磁头数大约是1~16个
- 老式的磁盘只有少量的电子设备
  - 只是传送简单的串行位流
- 在IDE（Intergrated Drive Electonics，集成驱动电子设备）和SATA（Serial ATA，串行）盘上
  - 磁盘驱动器本身包含一个微控制器
    - 承担了大量的工作并且允许实际的控制器发出一组高级命令
    - 经常做磁道高速缓存、坏块重映射以及更多的工作
    - overload seek，重叠寻道
      - 控制器是否可以同时控制两个或多个驱动器进行寻道
- 最初的IBM PC 360KB软盘参数与西部数据公司WD 18300硬盘参数

| 参数         | IBM 360KB软盘 | WD 18300硬盘 |
| ---------- | ----------- | ---------- |
| 柱面数        | 40          | 10601      |
| 每柱面磁道数     | 2           | 12         |
| 每磁道扇区数     | 9           | 281（平均）    |
| 每磁盘扇区数     | 720         | 35742000   |
| 每扇区字节数     | 512         | 512        |
| 磁盘容量       | 360KB       | 183GB      |
| 寻道时间（相邻柱面） | 6ms         | 0.8ms      |
|            | 77ms        | 6.9ms      |
|            | 200ms       | 8.33ms     |
| 电动机停止/启动时间 | 250ms       | 20ms       |
| 传输1个扇区的时间  | 22ms        | 17μs       |

- 标称的几何规格以及驱动程序软件使用的几何规格与物理格式几乎总是不同的
  - 在老式的磁盘上，每磁道扇区数对所有柱面都是相同的
  - 现代磁盘被划分成环带，外层的环带比内层的环带拥有更多的扇区
    - 一个实际的磁盘（例如WD 183000）常常有16个环带，从最内层的环带到最外层的环带，每个环带的扇区数增加大约4%
  - 大多数现代磁盘都有一个虚拟几何规格呈现给操作系统
    - 软件在工作时仿佛存在着x个柱面、y个磁头、每磁道z个扇区
    - 对于PC机而言，上述三个参数的最大值常常是（65535,16,63）
      - 为了突破这一限制，现代磁盘都支持逻辑块寻址的系统
      - logical block address，LBA
        - 磁盘扇区从0开始编号

#### 2. RAID

- CPU性能与磁盘性能之间的差距随着时间的推移将越来越大
- Redundant Array of Inexperisive Disk，RAID，廉价磁盘冗余阵列
  - 一种新型I/O设备的诞生
  - Single Large Expensive Disk，单个大容量昂贵磁盘
  - RAID背后的思想是将一个装满了磁盘的盒子安装到计算机（通常是一个大型服务器）上，用RAID控制器替换磁盘控制器卡，将数据复制到整个RAID，然后继续常规的操作
- RAID将数据分布在全部驱动器上，这样就可以并行操作
  - 为这样的操作定义几种不同的模式，称为0级RAID到5级RAID
- 0级RAID
  - 它将RAID模拟的虚拟单个磁盘划分成条带
    - 每个条带具有k个扇区，其中扇区0~k-1为条带1，以此类推
  - striping，划分条带
    - 将数据分布在多个驱动器上
  - 0级RAID对于大数据量的请求工作性能最好，数据量越大性能越好
    - 对于习惯于每次请求一个扇区的操作系统，0级RAID工作性能最糟糕
- 1级RAID
  - 它复制了所有的磁盘，所以存在四个主磁盘和四个备份磁盘
  - 容错性是突出的
- 2级RAID
  - 工作在字的基础上，甚至可能就是字节的基础上
  - 将单个虚拟磁盘的每个字节划分成4位的半字节对，然后对每个半字节对加入一个汉明码从而形成7位的字，其中1,2,4位为奇偶校验位
- 3级RAID
  - 2级RAID的简化版本
  - 要为每个数据字计算一个奇偶校验位并且将其写入一个奇偶驱动器中
  - 单个校验位能够纠正1位错误
- 4级RAID
  - 再次使用条带
  - 与0级
- 4级与5级RAID
  - 4级RAID与5级RAID相类似，但是它将条带对条带的奇偶条带写到一个额外的磁盘上
    - 结果，奇偶驱动器的负担十分沉重，它可能成为一个瓶颈
- 5级RAID
  - 5级RAID以循环方式在所有驱动器上均匀地分布奇偶校验位消除瓶颈

#### 3. CD-ROM

- 光盘比传统的磁盘具有更高的记录密度
- 光盘一直是大量研究工作的主题，并且经历了令人难以置信的快速发展
  - 第一代光盘是荷兰的电子公司飞利浦为保存电影而发明的
    - 直径30cm
    - Laster Vision
- Compact DIsc，CD，压缩光盘
  - 1980年飞利浦同索尼开发
  - 红皮书（Red Book）出版CD的准确技术细节
    - 正式国际标准（IS 10149）
      - 让来自不同音乐出版商的CD和来自不同电子设备制造商的播放器能够一同工作
  - 所有的CD都是直径120mm，厚度1.2mm，中间有一个15mm的圆孔
  - 音频CD都是直径120mm，厚度1.2mm，中间有一个15mm的圆孔
  - 音频CD是第一个成功的大众市场数字存储介质
  - 设想应该是能够耐用100年
- 一张CD的准备分成几个步骤
  - 使用高功率的红外激光在具有涂层的玻璃母盘上烧出许多直径为0.8μm的小孔
  - 从这张母盘可以制作出铸模，铸模在激光孔所在的位置具有突起
  - 将溶化的聚碳酸酯树脂注入这一铸模，就可以形成具有与玻璃母盘相同小孔模式的一张CD
  - 然后将一个非常薄的反射铝层沉积在聚碳酸酯上，再加上一层保护性的漆膜，最后加上一个标签
  - pit，凹痕
    - 聚碳酸酯基片中的凹陷处
  - land，槽脊
    - 凹痕之间未被烧的区域
- 在回放的时候
  - 低功率的激光二极管发出波长为0.78的红外光
    - 随着凹痕和槽脊的通过照射在其上
    - 激光在聚碳酸酯一面，所以凹痕朝着激光的方向突出
  - 从凹痕反射回来的光线与从周围表面反射回来的光线在相位上相差半个波长
    - 与从槽脊反射回的光线相比只返回很少的光线到播放器的光电探测器
    - 可以区分凹痕和槽脊
  - 使用凹痕/槽脊或槽脊/凹痕的过渡来记录1而用这种过渡的缺失来记录0却更加可靠
- 好狠和槽脊写在一个连续螺旋中
  - 螺旋环绕着光盘旋转22188圈（大约每毫米600圈）
    - 如果展开的话，它将有5.6m长
  - 必须让凹痕和槽脊以恒定的线速度通过
    - 为了以均匀的速度播放音乐
    - 因此，当CD的读出头从CD的内部向外部移动时，CD的旋转必须连续地降低
- Compact Disc-Read Only Memory，压缩光盘-只读存储器，CD-ROM
  - 1984年，飞利浦和索尼出版黄皮书（Yellow Book）
    - CD存放计算机数据的潜力
    - 定义的是计算机数据的格式化
      - CD-ROM的基本格式是以14位的符号进行编码
      - CD-ROM使用的是更为强大的编码系统
      - 在下一个层次上，一组42个连续符号形成一个588位的帧（frame）
        - 每一帧拥有192个数据位（24个字节）
        - 剩余的396

## 5.6 用户界面：键盘、鼠标和监视器

### 5.6.1 输入软件 

#### 键盘软件

- 回显
- 设备等效性问题
  - 逻辑上，在一个文本行的结尾，人们需要一个回车和一个换行，回车使光标移回到第一列，换行使光标前进到下一行
    - 在UNIX中，ENTER键被转换成一个换行用于内部存储
    - 在Window中，它被转换成一个回车跟随一个换行
  - 如果标准形式只是存储一个换行（UNIX约定）
    - 回车（由Enter键造成）应该转换为换行
  - 如果内部格式是存储两者（Windows约定）
    - 驱动程序应该在得到回车时生成一个换行并且在得到换行时生成一个回车
  - 在诸如大型计算机这样的多用户系统上，不同的用户可能拥有不同类型的终端连接到大型计算机上
    - 要求键盘驱动程序将所有不同的回车/换行组合转换成内部系统标准并且安排好正确地实现回显


- 在规范模式下操作，许多输入字符具有特殊的含义

  | 字符     | POSIX | 注释              |
  | ------ | ----- | --------------- |
  | CTRL-H | ERASE | 退格一个字符          |
  | CTRL-U | KILL  | 擦除正在键入的整行       |
  | CTRL-V | LNEXT | 按字面意义解释下一个字符    |
  | CTRL-S | STOP  | 停止输出            |
  | CTRL-Q | START | 开始输出            |
  | DEL    | INTR  | 中断进程（SIGINT）    |
  | CTRL-\ | QUIT  | 强制核心转储（SIGQUIT） |
  | CTRL-D | EOF   | 文件结尾            |
  | CTRL-M | CR    | 回车（不可修改的）       |
  | CTRL-J | NL    | 换行（不可修改的）       |

  - ERASE字符允许用户删除刚刚键入的字符
    - 通常是退格符（CTRL-H）
    - 应该被回显为三个字符的序列
      - 退格符、空格和退格符
      - 以便从屏幕上删除前一个字符
    - 如果前一个是制表符
      - 删除它取决于当它被键入的时候是如何处理的
    - 在大多数系统中，退格只删除当前行上的字符，不会删除回车并且后退到前一行
  - KILL字符擦除一整行

### 5.6.2 输出软件

#### x窗口系统

- X中的一个关键概念是资源（resource）

  - 资源是保存一定信息的数据结构
  - 应用程序在工作站上创建资源
  - 在工作站上，资源可以在多个进程之间共享
  - 典型的资源包括窗口、字体、颜色映射（调色板）、像素映射（位图）、光标以及图形上下文

- X程序的框架

  - 它以包含某些必需的头文件开始，之后声明某些变量
  - 它与X服务器连接
    - X服务器是作为XOpenDisplay的参数设定的
  - 它分配一个窗口资源并且将指向该窗口资源的句柄存放在win中

  ```c
  #include <X11/Xlib.h>
  #indclude <X11/Xutil.h>

  main(int argc, char *argv[])
  {
    Display disp;/*服务器标识符*/
    Window win;/*窗口标识符*/
    GC gc;/*图形上下文标识符*/
    XEvent event;/*用于存储一个事件*/
    int running = 1;
    
    disp = XOpenDisplay(*display_name*);/*连接到X服务器*/
    win = XcreateSimpleWindows（display，...);/*为新窗口分配内存*/
    XSetStandardProperties（disp, ...);/*为项窗口管理器宣布窗口*/
    XMapRaise(disp, win);/*显示窗口：发送Exprose事件*/
    while（running){
      XNextEvent(disp, &event);/*获得下一个事件*/
      switch(event.type){
        case Exprose:      ...; break;/*重绘窗口*/
        case ButtonPress:  ...; break;/*处理鼠标点击*/
        case Keypress:     ...; break;/*处理键盘输入*/
    	}
    }
    XFreeGC(disp, gc);/*释放图形上下文*/
    XDestroyWindows（disp, win);/*回收窗口的内存空间*/
    XCloseDisplay(disp);/*拆卸网络连接*/
  }
  ```

- 对XCreate的调用创建一个图形上下文

  - 窗口的的属性就存放在图形上下文中

- XSelectInput的调用通知X服务器程序准备处理那些事件

- 对XMapRaised的调用将新窗口作为最顶层的窗口映射到屏幕上

- 主循环由两条语句构成，并且在逻辑上比Windows中对应的循环要简单得多

  - 第一条语句获得一个事件
  - 第二条语句对事件类型进行分派从而进行处理

- X通过一个称为xterm的客户程序解决了这一问题

  - 该程序仿真了一台古老的VT102智能终端，完全具有所有的转义序列

#### 图形用户界面

- 大多数个人计算机提供了GUI（Graphical User Interface，图形用户界面）

- GUI是由斯坦福研究院的Douglas Engelbart和他的研究小组发明的

  - 之后GUI被Xerox PARC的研究人员摹仿
  - Apple公司的共同创立者Steve Jobs参观了PARC，并且在一台Xerox计算机上见到了GUI
    - 开发了一种新型计算机，Apple Lisa
      - 太过昂贵而在商业上失败
    - 它的后继者Macintosh获得了巨大的成功
  - 当Microsoft得到Macintosh的原型时，Microsoft请求Apple发放界面许可给所有新来者

- GUI具有字符WIMP表示的四个基本要素

  - Windows，窗口
    - 一个矩形块状的屏幕区域
    - 用来运行程序
  - Icon，图标
    - 小符号
    - 可以在其上点击导致某个动作发生
  - Menu，菜单
    - 动作列表
    - 人们可以从中进行选择
  - Pointing device，定点设备
    - 顶点设备是鼠标、跟踪球或者其他硬件设备
    - 用来在屏幕上移动光标以便选择项目

- GUI可以在用户级代码中实现（UNIX系统），也可以在操作系统中实现（Windows）

- graphics adapter，图形适配器

  - 输出几乎总是送往特殊的硬件电路板，称为图形适配器
  - 图形适配器包含特殊的内存，称为视频RAM（video RAM）
    - 保存出现在屏幕上的图像
    - 高端的图形适配器通常具有强大的32位或64位CPU和多达1GB自己的RAM
      - 独立于计算机的主存
  - 支持几种屏幕尺寸
    - 1024×768、1280×960、1600×1200和1920×1200
    - 除了1920×1200以外，宽高比都是4:3
      - 可以用在电视机的相同的监视器上产生正方形的像素
        - 符合NTSC和PAL电视机的屏幕宽高比
    - 1920×1200用于宽屏监视器
      - 每个限速具有24位的彩色显示，大约需要6.5MB的RAM

- GUI的输出软件是一个巨大的主题

  - Win32 API，被Windows的所有32位版本所支持

- Window，窗口

  - 屏幕上的基本项目
  - 位置和大小通过给定两个斜对角的坐标（以像素为单位）唯一地决定
  - 窗口可以包含一个标题条、一个菜单条、一个工具条、一个垂直滚动条和一个水平滚动条
  - Windows的坐标系将原点置于左上角并且y向下增长
  - 当窗口被创建时，有一些参数可以设定窗口是否可以被用户移动，是否可以被用户调整大小，或者是否可以被用户滚动
  - Windows程序是面向消息的、
  - UNIX模型是提请系统调用与操作系统相互作用
    - X是面向事件的


  - Windows主程序的框架

  ```c
  #include <windows.h>

  int WINAPI WinMain(HINSTANCE h, HINSTANCE hprev, char *szCmd, int iCmdShow)
  {
     WINCLASS wndclass;/*本窗口的类对象*/
     MSG msg；/*进入的消息存放在这里*/
     HWND hwnd；/*窗口对象的句柄（指针）*/
      
    /*初始化windclass*/
     windclass.ipfnWndProc = WndProc;/*指示调用哪个过程*/
    windclass.ipszClassName = "Program name";/*标题条的文本*/
    windclass.hlcon = LoadIcon(NULL, IDI _APPLICATION);/*装载程序图标*/
    windclass.hCursor = LoadCursor(NULL, IDC _ARROW);/*装载鼠标光标*/
    RegisterClass（&wndclass);/*向Windows注册wndclass*/
    hwnd = CreateWindows(...);/*为窗口分配存储*/
    ShowWindow(hwnd, iCmdShow);/*在屏幕上显示窗口*/
    UpdateWindow(hwnd);/*指示窗口绘制自身*/
    
    while(GetMessage(&msg, NULL, 0, 0)){/*从队列中获取消息*/
      TranslateMessage(&msg);/*转换消息*/
      DispatchMessage(&msg);/*将msg发送给适当的过程*/
    }
    return（msg， wParam）；
  }

  long CALLBACK WndProc(HWND hwnd, UINT message, UNIT wParam, long IParam)
  {
    /*这里是声明*/
    switch(message){
        case WM_CREATE;  ...; return ...;/*创建窗口*/
        case WM_PAINT;   ...; return ...;/*重绘窗口的内容*/
        case WM_DESTROY; ...; return ...;/*销毁窗口*/
    }
    return（DefWindowsProc(hwnd, message, wParam, lParam）；/*默认*/
  }
  ```

- 主程序以一个声明开始，该声明给出了它的名字和参数

  -  WINAPI宏是一条给编译器的指令，让编译器使用一定的参数传递约定并且不需要我们进一步关心
    - 第一个参数h是一个实例句柄
      - 用来向系统的其他部分标识程序
      - Win32是面向对象的，使用句柄来引用
        - h标识的是程序
    - 第二个参数只是为了向后兼容才出现的
    - 第三个采纳数szCmd是一个以零终止的字符串
      - 包含启动改程序的命令行
    - 第四个参数iCmdShow表明程序的初始窗口iCmdShow表明程序的初始窗口应该占据整个屏幕
  -  Hungarian notation，匈牙利记号
    - 该声明说明了一个广泛采用的Microsoft约定，称为匈牙利记号
    - 波拉记号的双关语
      - 波兰记号是波兰逻辑学家J.Lukasiewicz发明的后缀系统
      - 用于不适用优先级和括号表示代数公式
    - Microsoft的一名匈牙利程序员Charles Simonyi发明的
    - 它使用标识符的前几个字符来指定类型
      - c，character，字符
      - w，word，字，现在意指无符号16位整数
      - i，integer，32位有符号整数
      - l，long，32位有符号整数
      - s，string，字符串
      - sz，string terminated by a zero byte，以零字节终止的字符串
      - p，pointer，指针
      - fn，function，函数
      - h，Handle，句柄
    - 举例来说，szCmd是一个以零终止的字符串，iCmdShow是一个整数
  -  每个窗口必须具有一个相关的类对象定义其属性
    - 类对象是wndclass
    - 对象类型WNDCLASS具有10个字段
      - 最终要的额字段是lpfnWndProc
        - 它是一个指向函数的长（32位）指针
        - 该函数处理引用该窗口的消息
      - 此处被初始化的其他字段指出在标题条中使用哪个名字和图标，以及对于鼠标光标使用哪个符号
  -  在wndclass被初始化之后，RegisterClass被调用，将其发送给Windows
  -  下个调用CreateWindows为窗口的数据结构分配内存并且返回一个句柄以便以后引用它
  -  程序的主循环
    - 包括获取消息，对消息做一定的转换，然后将其传回Windows以便让Windows调用WndProc来处理它
    - 这一完整的机制能够化简，但是由于历史的缘故，现在坚持这样做

- 过程WndProc

  - 它处理发送给窗口的各种消息
  - CALLBACK的使用与WINAPI类似，为参数指明要使用的调用序列
    - 第一个参数是要使用的窗口的句柄
    - 第二个参数是消息类型
    - 第三和第四个参数可以用来在需要的时候提供附加的信息
  - 消息类型WM_CREATE和WM_DESTROY分别在程序的开始和结束时发送
    - 为数据结构分配内存，并且将其返回
  - 第三个消息类型WM_PAINT是一条指令
    - 让程序填充窗口
    - 在Windows中不能够假定它在屏幕上画的东西将一直保持在那里知道将其删除
      - 与基于文本的系统相反
      - Windows告知一个程序重绘窗口的方法是发送WM_PAINT消息
    - Windows有两种方法可以让一个程序做某些事情
      - 投递一条消息到消息队列
        - 用于键盘输入、鼠标输入以及定时器到时
      - 发送一条消息到窗口
        - 使Windows直接调用WndProc本身
        - 用于所有其他事件
        - 当一条消息完全被处理后Windows会得到通报，避免竞争条件
  - 还有许多其他消息类型

- Windows程序通常创建一个或多个窗口

  - 每个窗口具有一个类对象

  - 相关联的的是一个消息队列和一组处理过程

  - 程序的行为由到来的事件驱动

    - 事件由处理过程来处理

  - UNIX采用过程化世界观模型（观点）

  - Graphics Device Interface，GDI，图形设备接口

    - 对屏幕的实际绘图是由包含几百个过程的程序包处理的，捆绑在一起形成了GDI
    - 能够处理文本和各种类型的图形
    - 与平台和设备无关
    - device context，设备上下文
      - 在窗口中绘图之前
      - 一个内部数据结构
        - 包含窗口的属性，诸如当前字体、文本颜色、背景颜色等
    - 大多数GDI调用使用设备上下文

    ```c
    hdc = GetDC(hwnd);
    TextOut(hdc, x, y, psText, iLength);
    ReleaseDC(hwnd, hdc);
    ```

    - 第一条语句获取一个设备上下文的句柄hdc
      - 程序只能够写窗口的客户区，而不能写标题条和窗口的其他部分
    - 第二条语句使用设备上下文在屏幕上写一行文本
      - 设定了字符串开始处的（x, y)坐标、一个指向字符串本身的指针以及字符串的长度
    - 第三个调用释放设备上下文，表明程序在当时已通过绘图操作
    - hdc的使用方式与UNIX的文件描述符相类似
      - ReleaseDC包含冗余的信息
        - 使用hdc就可以惟一地指定一个窗口
        - 使用不具有实际价值的冗余信息在Windows中是很常见的
    - 修剪区域
      - 在设备上下的数据结构中
      - 在修剪之外的任何绘图操作都将被忽略
    - 另一种获取设备上下文的的方法是GetWindowDC
      - 它将修改修剪区域设置为整个窗口
      - 拥有多种调用做几乎相同的事情
        - Windows的另一个特性

- GDI具有各种各样的过程调用

  - 以获取和释放设备上下文
  - 获取关于设备上下文的属性
    - 背景颜色
  - 使用GDI对象
    - 画笔、画刷和字体
    - 每个对象都有自己的属性
  - 在屏幕上绘图
    - 绘图过程分成四种类型
      - 绘制直线和曲线
      - 绘制填充区域
      - 管理位图
      - 显示文本

#### 位图

- GDI过程是矢量图形学的实例

  - 用于在屏幕上放置几何图形和文本
  - 设备无关的

- metafile，Windows元文件

  - 一组对GDI过程的调用聚集在一个文件中
  - 用于从一个Windows程序到另一个Windows程序传送图画
  - 拓展名.wmf
  - 许多Windows程序允许用户复制图画
    - 一种方法是由第一个程序将图画表示为Windows元文件并且将其以.wmf格式放在剪贴板上
  - 并不是计算法处理的所有图形都能够使用矢量图形学来生成
    - 照片和视频

- bitmap，位图

  - 通过在图像上覆盖一层网络扫描输入。每个网格方块的平均红、绿、蓝取值别采样并且保存为一个像素的值

  - Windows中有大量的工具用于处理位图

  - 用于文本

    - 在某种字体中表示一个特殊字符的一种方法是将其表示为小的位图

  - 使用位图的一般方法是

    - 调用BitBlt

    ```c
    BitBlt(dsthdc, dx, dy, wid, ht, srchdc, sx, sy, rasterop);
    ```

    - BitBlt还可以做很多事情

## 5.7 瘦客户端

- 主流计算机范式一直在中心化和分散化计算之间振荡
  - 最早的计算机是个人计算机之间
     - 庞然大物
  - 在分时系统中许多用户在简单的终端上共享一个大型的中心计算机
  - PC时代
- 分散的PC模型
   - 最大的问题是
      - 每台PC机都有一个大容量的硬盘以及复杂的软件必须维护
- 中心化的系统
  - 只有一台或几台机器必须升级，并且有专家班子做这些工作
  - 自动化的磁带机器人在每天夜里都可以做备份
  - 资源共享更加容易
- 以PC为中心的计算到以Web为中心的计算的转移
  - 电子邮件
  - 一个合理的结论
    - 大多数用户想要高性能的交互式计算，但是实在不想管理一台计算机
    - 导致了研究人员重新研究了分时系统 使用的哑终端
    - 现在称为瘦客户机（thin client）
- holy grial，圣杯
  - 是一个高性能的交互式计算系统
  - 该系统中用户的机器根本就没有软件
- THINC
  - 哥伦比亚大学的研究人员开放的
  - 基本思想是从客户机剥离一切智能和软件，只是将其用作一台显示器，使所有计算（包括建立待显示的位图）都在服务器端完成
  - 两端之间的协议中使用了五条命令

| 命令   | 描述             |
| ---- | -------------- |
| Raw  | 在给定的位置显示原始像素数据 |
| Copy | 复制帧缓冲器区域到指定的坐标 |
|Sfill|以给定的像素颜色值填充一个区域
Pfill|以给定的像素模式填充一个区域
Bitmap|使用位图图像填充一个区域
- Raw用于传输像素数据并且将它们逐字地显示在屏幕上
- Copy指示显示器从其视频RAM的一个部分移动到另一个部分
- Sfill以单一的像素值填充屏幕的一个区域
  - 用于首先生成背景，然后可以绘制文本、图标和其他项目
- Pfill在某个区域复制一个模式
  - 用于背景
- Bitmap也是用于绘制区域
  - 但是具有前景色和背景色
- 在客户端需要很少的软件
  - 所有建立位图填充屏幕的复杂操作都是在服务器上完成的
  - 多条命令可以聚集成单一的数据包，通过网络从服务器传送到客户机
    - 在服务器端，图形程序使用高级命令以绘制屏幕
- 性能超过了其他广域网系统
  - 即使对于实时视频也是如此
## 5.8 电源管理
- 晶体管发明后，电力的使用量戏剧性地下降
- 如今电源管理由于若干原因又像过去一样成为焦点
  - 并且操作系统在这里扮演着重要的角色
- 桌面PC
  - 桌面PC通常具有200瓦的电源
    - 其效率一般是85%，15%进来的能量损失为热量
- 另一个着重考虑电源的场合是电池供电的计算机
  - 包括笔记本电脑、掌上机以及Web便筏薄等
  - 问题的核心是
    - 电池不能保存足够的电荷以持续非常长的时间
  - 在最低的层次，硬件厂商试图使他们的电子装置具有更高的效率
    - 减少晶体管尺寸
    - 利用动态电压调节
    - 使用低摆幅并隔热的总线以及类似的技术
  - 存在两种减少能量消耗的一般方法
    - 当计算机的某些部件（主要是I/O设备）不用的时候由操作系统关闭它们
    - 应用程序使用较少的能量

### 5.8.1 硬件问题

- 电池一般分为两种类型
  - 一次性使用的
    - 可以用来运转掌上设备
  - 可再充电的
    - 能够存储足够的能量为笔记本电脑供电几个小时
    - 镍镉电池、镍氢电池、锂电池
      - 容量非常有限
- 大多数计算机厂商对于电池节约采用的一般措施
  - 将CPU、内存以及I/O设备设计成具有多种状态
    - 工作、睡眠、休眠和关闭
  - 当设备具有这些状态时，应该由操作系统在正确的时机管理状态的变迁
- 某些计算机具有两个甚至三个电源按钮
- 电源管理提出了操作系统必须处理的若干问题
  - 选择性地、临时地关闭设备
  - 当它们空闲时减少它们的功率消耗
  - 必须回答的问题
    - 那些设备能够被控制？
    - 它们是工作还是关闭的，或者它们具有中间状态吗？
    - 在低功耗状态下节省了多少电能？
    - 重启设备消耗能量吗？
    - 当进入低功耗状态时是不是必须保存某些上下文？
    - 返回到全功耗状态要花费多长时间？

### 5.8.2 操作系统问题

- 操作系统在能量管理上扮演着一个重要的角色
  - 控制着所有的设备
    - 所以它必须决定关闭什么设备以及何时关闭
  - 找到算法和试探法
    - 让操作系统对于关闭什么设备以及何时关闭能够做出良好的决策
    - 问题是“良好”是高度主观的

#### 1. 显示器

- 在每个人的能量预算中最大的项目是显示器
  - 为了获得明亮而清晰的图像，屏幕必须是背光照明的
    - 这样会消耗大量的能量
  - 关闭显示器是一个睡眠状态
    - 当任意键被敲击或者定点设备移动时，它能够（从视频RAM）即时地再生
- 一种可能的改进
  - 让显示器由若干数目的区域组成，这些区域能够独立地开启和关闭

#### 2. 硬盘

- 硬盘消耗大量的能量以保持高速旋转
  - 即使不存在存取操作
- 许多计算机，特别是笔记本电脑，在几秒钟或者几分钟不活动之后将停止磁盘旋转
  - 停止的磁盘是休眠
    - 因为要花费相当多的时间将磁盘再次旋转起来，导致用户感到明显的延迟
  - 重新启动磁盘将消耗相当多额外的能量
    - 每个磁盘都有一个特征时间Td为它的盈亏平衡点
      - Td通常在5~15s的范围之间
  - 大多数操作系统是保守的，往往是几分钟不活动之后才停止磁盘
- 节省磁盘能量的另一种方法是在RAM中拥有一个大容量的磁盘高速缓存
- 避免不必要的磁盘启动的另一种方法是
  - 操作系统通过发送消息或信号保持将磁盘的状态通知给正在运行的程序
    - 某些程序具有可以自由决定的写操作，这样的写操作可以被略过或推迟

#### 3. CPU

- CPU也能被管理以节省能源
  - 笔记本电脑的CPU能够用软件置为睡眠状态
    - CPU唯一能做的事情是当中断发生时醒来
- 在许多计算机上，在CPU电压、时钟周期和电能消耗之间存在着关系

## 5.8 电源管理
- 晶体管发明后，电力的使用量戏剧性地下降
- 如今电源管理由于若干原因又像过去一样成为焦点
  - 并且操作系统在这里扮演着重要的角色
- 桌面PC
  - 桌面PC通常具有200瓦的电源
    - 其效率一般是85%，15%进来的能量损失为热量
- 另一个着重考虑电源的场合是电池供电的计算机
### 5.8.1 应用程序管理
- 指示应用程序使用较少的能量
  - 一般情况下，当电池的电荷低于某个阈值时传递这样的信息，然后由应用程序负责在退化性能以延长电池寿命以维持性能
- 程序怎样退化其性能以节省能量
  - 信息以各种形式呈现给用户
    - 当退化不存在时，呈现的是最优可能的信息
    - 当退化存在时，呈现给用户的信息的保真度（准确度）比它能够达到的保真度要差
    - PowerScope软件工具
      - 提供一个程序的电能使用量的概要剖析
      - 计算机必须通过一个软件控制的数字万用表接通一个外部电源
    - 视频播放器
      - 在为退化模式下，播放器以全分辨率和彩色方式每秒播放30帧
      - 退化形式
        - 舍弃彩色信息并且以黑白方式显示视频
        - 降低帧速率
        - 在两个方向上减少像素数目
        - 通过降低空间分辨率
        - 使显示的图像更小
    - 语音识别器
      - 对麦克风进行采样以构造波形
      - 通过使用比较小的词汇量和比较简单的声学模型可以实现退化
        - 这样做的收益大约是35%
    - 通过无线链路获取地图的地图观察器
      - 将地图修剪到比较小的尺寸
      - 远程服务器省略比较小的道路
      - 这样获得的收益大约也是35%
    - 传送JPEG图像到一个Web浏览器
      - JPEG标准允许各种算法，在图像质量与文件大小之间进行
## 5.9 有关输入/输出的研究
- 大多数研究集中在特别的设备上，而不是一般性的I/O
  - 改进性能
- 磁盘系统
  - 磁盘臂调度算法
  - 磁盘阵列
  - 优化完整的I/O路径
  - 磁盘工作量特性
  - 高性能闪存盘
  - 设备驱动程序
  - 新的存储技术
    - Micro-Electrical-Mechanical System，MEMS，微电子机械系统
    - 潜在的可以取代磁盘，或者至少是磁盘的补充
  - 如何在磁盘控制器内部最好地利用CPU
    - 为了改进性能
    - 为了检测病毒
- 时钟
  - 为了提供更好的分辨率，某些系统在1000Hz的时钟下运行，着会导致相当大的开销
- 瘦客户机
- 笔记本电脑
  - 利用软件技术减少电能消耗
    - 编写应用程序代码以最大化磁盘空闲时间
    - 当使用比较少时让磁盘降低转速
    - 使用程序模型预测无线网卡何时可以关闭
    - 节省VoIP的电能
    - 调查安全性的能量代价
    - 以能源效率高的方式执行多媒体调度
    - 让内置的摄像机检测是否有人在看显示器并且在没有人看的时候将其关闭
    - 传感网络中能源的使用
    - 在大型服务器园区中节省能源

## 5.10 小结
- 任何一个操作系统都有大量的组分与I/O有关
- I/O可以用三种方式来实现
  - 程序控制I/O
    - 主CPU输入或输出每个字节或字并且在一个密封的循环中等待，知道它能够获得或者发送下一个字节或字
  - 中断驱动的I/O
    - CPU针对一个字节或字开始I/O传送并且离开去做别的事情，直到一个中断到来发出信号通知I/O完成
  - DMA
    - 有一个单独的芯片管理着一个数据块的完整传送过程，只有当整个数据块完成传送时才引发一个中断
- I/O可以组织成4个层次
  - 中断服务程序
  - 设备驱动程序
    - 设备驱动程序处理运行设备的细节并且向操作系统的其余部分提供统一的接口
  - 与设备无关的I/O软件
  - 运行在用户空间的I/O库与假脱机程序
    - 做类似缓冲与错误报告这样的事情
- 盘具有多种类型
  - 包括磁盘、RAID和各类光盘
  - 磁盘臂调度算法经常用来改进磁盘性能
  - 虚拟几何规格的出现使事情变得十分复杂
  - 通过将两块磁盘组成一对，可以构造稳定的存储介质
- 时钟可以用于跟踪实际时间
  - 限制进程可以运行多长时间
  - 处理监视器定时器
  - 进行记账
- 面向字符的终端具有多种多样的问题
  - 特殊的字符如何输入以及特殊的转义序列如何输出
  - 输入采用原始模式或加工模式
  - 针对输出的转义序列控制着光标的移动并且允许在屏幕上插入和删除文本
- 大多数UNIX系统使用X窗口系统作为用户界面的基础
  - 包含于特殊的库相绑定并发出绘图命令的程序
  - 在显示器上执行绘图的服务器
- 许多个人计算机使用GUI作为它们的输出
  - GUI基于WIMP范式
    - 窗口、图标、菜单和定点设备
  - 基于GUI的程序一般是事件驱动的
  - 在UNIX系统中，GUI几乎总是运行在X之上
- 瘦客户机与标准PC相比具有某些优势
  - 对用户而言
    - 简单性并且需要较少维护
  - 以五条简单的原语就能制造出具有良好性能的客户机
- 电源管理对于笔记本来说是一个主要的主题

## 习题
8. 一台计算机具有如图1-6a所示的三阶段流水线。在每个时钟周期，一条新的指令从PC所指向的地址处的内存中取出并放入流水线，同时PC值增加。每条指令恰好占据一个内存字。已经在流水线中的指令每个时钟周期前进一个阶段。当中断发生时，当前PC压入堆栈，并且将PC设置为中断处理程序的地址。然后，流水线右移一个阶段并且中断处理程序的第一条指令被取入流水线。该机器具有精确的中断吗？请解释你的答案。
- 具有精确的中断。入栈的PC指向第一条未读取的指令。之前的所有指令都已执行而指向的指令及其后续指令均未执行，这就是精确中断的条件。精确中断在单管线的机器上不难实现，但是当指令不按序执行时会有麻烦，此时就不在具有精确的中断。
9. 一个典型的文本打印页面包含50行，每行80个字符。设想某一台打印机每分钟可以打印6个页面，并且将字符写到打印机输出寄存器的时间很短以至于可以忽略。如果打印机每个字符要请求一次中断，而进行中断服务要花费总计50μs的时间，那么使用中断驱动的I/O来运行该打印机有没有意义？
 - 该打印机打印每分钟打印50×80×6=24000个字符，也就是400字符/s，每个字符使用50ns的CPU时间用于中断，因此，每秒总共的中断时间是20ms。使用中断驱动I/O余下的980ms可供其它使用。换句话说，中断耗时只占CPU时间的2%，这几乎不会影响运行的程序。
10. 请解释OS如何帮助安装新的驱动而无须重新编译OS
- UNIX通过以下的方法实现。有一个由设备编号索引的表，每个表项是一个C结构，其中包含指向打开、关闭、读取和写入功能的指针，以及来设备的其他一些东西。要安装新设备，必须在此表中新建一个条目，并将指针填充到新加载的设备驱动程序中。
11. 以下各项工作是在四个I/O软件的哪一层完成的？
   a) 为一个磁盘读操作计算磁道、扇区、磁头
- 设备驱动程序
  b) 向设备寄存器写命令
- 设备驱动程序
  c) 检查用户是否允许使用设备
- 设备无关的软件
  d) 将二进制整数转换成ASCⅡ以便打印
- 用户级软件
12. 一个局域网以如下方式使用：用户发出一个系统调用，请求将数据包写到网上，然后操作系统将数据复制到一个内核缓冲区，再将数据复制到网络控制器接口板上。当所有数据都安全地存放在控制器中时，再将它们通过网络以10Mb/s的速率发送。在每一位被发送后，接收的网络控制器以每微秒一位的速率保存它们。当最后一位到达时，目标CPU被中断，内核将新到达的数据包复制到内核缓冲区中进行检查。一旦该数据包是发送给哪个用户的，内核就将数据复制到该用户空间。如果我们假设每一个中断及其相关的处理过程花费1ms时间，数据包为1024字节（忽略包头），并且复制一个字节花费1μs时间，那么将数据从一个进程转储到另一个进程的最大速率是多少？假设发送进程被阻塞直到接收端结束工作并且返回一个应答。为简单期间，假设获得返回应答的时间非常短，可以忽略不计。
- 在这个过程中，包必须复制四次，需要4.1毫秒。有两个中断，占两毫秒。最后，传输时间为0.83毫秒，1024字节的数据包共需要6.93毫秒。最大数据传输速率为147763字节/秒，或约10兆位的网络标称容量的12%。（如果我们考虑协议开销，结果会变得更糟）
13. 为什么打印机的输出文件在打印前通常都假脱机输出在磁盘上？
- 如果每次输出都立即分配打印机，某进程可以通过打印机1个字符来冻结打印机然后休眠一星期。
14. 3级RAID只使用一个奇偶驱动器就能够纠正一位错误。那么2级RAID的意义是什么？毕竟2级RAID以只能纠正一位错误而且需要更多的驱动器。
- RAID level 2不仅可以从故障驱动器来恢复错误位，还可以从未被检测到的瞬时差错中恢复。如果某驱动器发送一个坏数据位，RAID level 2可以纠正，而RAID level 3不能。

15. 如果两个或更多的驱动器在很短的时间内崩溃，那么RAID就可能失效。假设在给定的一个小时内一个驱动器崩溃的概率是p，那么在给定的一小时内具有k个驱动器的RAID失效的概率是多少？

- 0次故障的概率$P_0$ 为$(1-p)^k$ 。1次故障的概率$P_1$ 为$kp(1-p)^{k-1}$ 。 而整个RAID发生故障的概率为$1-P_0-P_1$ ，也就是$1-(1-p)^k-kp(1-p)^{k-1}$ 

16. 从读性能、写性能、空间开销以及可靠性方面对0级RAID到5级RAID进行比较

- 读取性能：RAID级别0，2，3，4和5允许一个读请求并行读取服务。然而，RAID级别1进一步允许两个读取请求同时进行。、
- 写入性能：所有RAID级别提供类似的写入性能。
- 空间开销：第0级没有空间开销，而第1级100%的开销。第2级带32位数据字和六位奇偶校验驱动器，空间开销约为18.75%。对于32位数据字，3级空间开销约为3.13%。最后，假设4级和5级别具有33个驱动器，则他们的空间开销为3.13%。
- 可靠性：0级没有可靠性支持。所有其他RAID级别可以在一个磁盘驱动崩溃时保证数据。此外，对于3,4和5级别，在一个字内的一个单一的随机位错误可以被检测到，而第2级，在一个字内的一个单一的随机位错误可以被检测和纠正。

27. 在关于稳定存储器的讨论中，证明如果在写过程中发生了CPU崩溃，磁盘可以恢复到一个一致的状态（写操心或者已完成，或者完全没有发生）。如果在恢复过程中CPU再次崩溃，这一特性是否还保持？请解释你的答案。

- 是的，即使在恢复程序运行的过程中CPU再次崩溃，磁盘依然能恢复一致状态。考虑图5-31，（a）或（e）中没有恢复。假设CPU在（b）恢复期间崩溃，如果CPU在驱动器2的块被完全复制到驱动器1之前崩溃，情况仍然和以前一样。随后的恢复过程将检测驱动器1的ECC错误，然后再次从驱动器2复制块到驱动器1。如果CPU在驱动器1块已完全复制到驱动器2，情况和（d）是一样的。随后的恢复过程将检测驱动器2中的ECC错误，并将该块从驱动器1复制到驱动器2。如果CPU从驱动器1的块被完全复制到驱动器2后崩溃，情况仍和以前一样。随后的恢复过程将检测驱动器2中的ECC错误，然后再次从驱动器1复制块到驱动器2。如果CPU从驱动器1的块被复制到驱动器2后崩溃，情况和（e）是一样的。

28. 某计算机上的时钟中断处理程序每一时钟滴答需要2ms（包括进程切换的开销），时钟以60Hz的频率运行，那么CPU用于时钟处理的时间比例是多少？

- 时钟频率60Hz，故时钟周期T=1000ms/60=50/3ms；CPU用于时间处理的比例为2/(50/3)×100%=12%

29. 一台计算机以方波模式使用一个可编程时钟。如果使用500MHz的晶体，为了达到如下时钟分辨率，存储寄存器的值应该是多少？

a) 1ms（每毫秒一个时钟滴答）

b) 100μs

- 使用一个500MHz的晶体，计数器可以每2纳秒的递减。所以，每毫秒一次，寄存器应该是1000000/2=50000。
- 每100秒获得一个时钟刻度，持有寄存器值应为50000

30. 一个系统通过将所有未决的时钟请求链接在一起而模拟多个时钟，如图5-34所示。假设当前时刻是5000，并且存在针对时刻5008、5012、5029和5037的未决的时钟请求。请指出在时刻5000、5005和5013时钟头、当前时刻以及下一信号的值。请指出在时刻5023时钟头、当前时刻以及下一个信号的值。

- 时间5000：当前时间= 5000；下一个信号= 8；头→8→4→3→14→8；
- 时间5005：当前时间=5005；下一个信号=3；头→3→4→3→14→8
- 时间5013：下一个信号=2；头2→14→8
- 时间5023：下一个信号=6；头→6→4→5

31. 许多UNIX版本使用一个32位无符号整数作为从时间原点计算的秒数来跟踪时间。这些系统什么时候会溢出（年与月）？你盼望这样的事情实际发生吗？

- 一年的平均秒数为365.25×24×3600=31557600。计数器大约在$2^{32}$ ，秒之后回绕。$2^32/31557600=136.1$ 年，也就是大约在2106年2月。如果到那时所有计算机至少是64位的，因此该情形将不会发生。

32. 一个位图模式的终端包含1280×960个像素。为了滚动一个窗口，CPU（或者控制器）必须向上移动所有的文本行，这是通过将文本的所有位从视频RAM的一部分复制到另一部分实现的。如果一个特殊的窗口高60行宽80个字符（总共4800个字符），每个字符框高8个像素高16个像素，那么以每个字节50ns的复制速率滚动整个窗口需要多长时间？如果所有的行都是80个字符长，那么终端的等价波特率是多少？将一个字符显示在屏幕上需要5μs，每秒能够显示多少行？

- 滚动窗口需要复制59行×80字符=4720字符。复制1个字符（16个字节）需800ns，因此整个窗口需要3.776ms。向屏幕写80个字符需400ns，因此滚动和显示新的行需4.176ms。大约239.5行/sec。

33. 接收到一个DEL（SIGINT）字符之后，显示驱动程序将丢弃当前排队等候显示的所有输出。为什么？

- 假设用户无意中要求编辑器打印数千条线，然后他点DEL停止它。如果驱动器没有放弃输出，则输出可能会持续几秒钟后，当没有发生的事情时，这将使用户一次又一次地击中DEL并且刷新。

34. 在最初IBM PC的彩色显示器上，在除了CRT电子束垂直回归扫描期间以外的任何时间向视频RAM中写数据都会导致屏幕上出现难看的斑点。一个屏幕映像为25×80个字符，每个字符占据8×8像素的方框。每行640像素在电子束的一次水平扫描中绘出，需要花费63.6μs，包括水平回扫。屏幕每秒钟刷新60次，每次刷新均需要一个垂直回扫期以便使电子束回到屏幕顶端。在这一过程中可供写视频RAM的时间比例是多少？

- 25行字符，每行高8个像素，需要200次扫描才能绘制。每秒刷新60次屏幕，或者120000次行扫描/秒。在63.6微秒/扫描，每秒中用于波束水平移动763毫秒，留下了237毫秒的时间可供视频RAM写入。因此，视频RAM可用的时间占23.7%

35.  计算机系统的设计人员期望鼠标移动的最大速率为20cm/s。如果一个鼠标步是0.1mm，并且每个鼠标消息3个字节，假设每个鼠标步都是单独报告的，那么鼠标步的最大数据传输率是多少？

- 鼠标的最大速率为200mm/sec，也就是2000mickeys/sec，如果每次报告为3个字节，输出速率为6000字节/sec。

36. 基本的加性颜色是红色、绿色和蓝色，这意味着任何颜色都可以通过这些颜色的线性叠加而构造出来。某人拥有一张不能使用全24位颜色表示的彩色照片，这可能吗？

- 对于24位彩色系统，仅能够表示$2^{24}$ 种颜色。这不是颜色的全部。例如，假设某摄影师以300种纯蓝绘图，每种都有一点区别。那么，而（R，G，B）中的B位只有8位，只能表示256种蓝色，而无法表示300种蓝色。

37. 将字符放置在位图模式的屏幕上，一种方法是使用BitBlt从一个字体表复制位图。假设一种特殊的字体使用16×24像素的字符，并且采用RGB真彩色。

a) 每个字符占用多少字体表空间？

b) 如果复制一个字节花费100ns（包括系统开销）。那么到屏幕的输出率是每秒多少个字符？

- 24位真彩RGB中每个像素需3个字节，因此该表中的字符为16×24×3=1152字节
- 如果每字节100纳秒，那么每个字符需1152×100ns=115.2微秒。也就是大约每秒输出8681字符。

38. 假设复制一个字节花费10ns，那么对于80字符×25行文本模式的内存映射的屏幕，完全重写屏幕要花费多长时间？采用24位彩色的1024×768像素的图形屏幕情况怎样？

- 重写文本屏幕需要复制2000个字节，也就是20微秒。重写图形屏幕需要复制1024×768×3=2359296字节，大约为23.6毫秒。

39. 在图5-40中存在一个窗口类需要调用RegisterClass进行注册，在图5-38中对应的X窗口代码中，并不存在这样的调用或与此相似的任何调用，为什么？

- 在Windows中，OS自己调用处理例程。在X Windows中，不会发生类似的事情。X只是获取消息，并在内部处理它。

40. 在课文中我们给出了一个如何在屏幕上画一个矩形的例子，即使用Windows GDI：

```c
Rectangle(hdc, xleft, ytop, xright, ybottom);
```

是否存在对于第一个参数（hdc）的实际需要？如果存在，是什么？毕竟，矩形的坐标作为参数而显式地指明了。

- 第一个参数是必须的。首先，坐标是对应于某个窗口的，因此需要hdc来指定窗口，也就是其坐标原点。第二，如果该矩形落在窗口外面，将被截除。因此还需要该窗口的坐标。第三，矩形颜色和其他属性必须由hdc指定。因此，hdc是十分重要的。

41. 一台THINC终端用于显示一个网页，该网页包含一个动画卡通，卡通大小为400×160像素，以每秒10帧的速度播放。显示该卡通会消耗100Mbps以太网带宽多大的部分？

- 显示大小为400×160×3=192000字节。10fps也就是192000字节/sec=15360000位/sec，占用100Mbps。对于一个共享网络TV节目是多点传送的，因此视频包只需发送一次，无论多少用户在观看都不影响其效果。而如果是100个用户浏览Web，每个用户的性能可能迅速降低。

42. 在一次测试中，THINC系统被观测到对于1Mbps的网络工作良好。在多用户的情形中会有问题吗？提示：考虑大量大用户在观看时间表排好的TV节目，并且相同数目的用户在浏览万维网。

- 网络带宽是共享的，因此100个用户同时请求不同的数据，1Mbps的网络将使得每个用户的有效带宽为10Kbps。对于一个共享网络，TV节目是多点传送的，因此视频包只需发送一次，无论多少用户在观看都不影响其效果。而如果是100个用户浏览Web，每个用户的性能可能迅速降低。

43. 如果一个CPU的最大电压被削减到V/n，那么它的功率消耗将下降到其原始值的$1/n^{2}$ ，并且、它的时钟速度下降到其原始值的1/n。假设一个用户以每秒1个字符的速度键入字符，处理每个字符所需要的CPU时间是100ms，n的最优值是多少？与不削减电压相比，以百分比表示相应的能量节约了多少？假设空闲的CPU完全不消耗能量。

- 如果n=10，CPU仍能按时完成操作，但是消耗的能源明显下降。如果CPU在1秒内全速运行100毫秒，然后闲置900毫秒消耗的能量为E/10。那么，以1/10的速度运行在消耗的能量为E/100，节省了9E/100，通过降低电压节约了90%的能量。

44. 一台笔记本电脑被设置成最大地利用功率节省特性，包括在一段时间不活动之后关闭显示器和硬盘。一个用户有时在文本模式下运行UNIX程序，而在其他时间使用X窗口系统。她惊讶地发现当她使用仅限文本模式的程序时，电池的寿命相当长。为什么？

- X窗口系统使用更多的内不能用于显示，并比文本模式需要更大的虚拟内存。硬盘将很难长时间处于非活动状态，无法被自动断电以节能。

45. 编写一个程序模拟稳定的存储器，在你的磁盘上使用两个大型的固定长度的文件来模拟两块磁盘。

- 略

46. 编写一个程序实现三个磁盘臂调度算法。编写一个驱动程序随机生成一个柱面号序列（0~999），针对该序列运行丧哥算法并且打印出在三个算法中磁盘臂需要来回移动的总距离（柱面数）

- 略


47. 编写一个程序使用单一的时钟实现多个定时器。该程序的输入包含四种命令（S<int>，T, E<int>, P）的序列：S<int>设置当前时刻为<int> ；T是一个时钟滴答；E<int> 调度一个信号在<int> 时刻发生；P打印出当前时刻、下一信号和时钟头的值。当唤起一个信号时，你的程序还应该打印出一条语句。

- 略


